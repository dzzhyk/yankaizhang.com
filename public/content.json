{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"DNS协议相关问题整理","text":"DNS协议域名解析协议DNS (Domain Name System)将域名和 IP 地址相互映射，方便人使用便于记忆的域名而不是 IP 地址。 将域名映射成 IP 地址称为正向解析，将 IP 地址映射成域名称为反向解析 DNS使用到的协议和端口DNS同时占用UDP和TCP的53号端口；DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区域中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区域传送（zone transfer）。 区域传送时使用TCP： 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 TCP是一种可靠的连接，保证了数据的准确性。 域名解析时使用UDP： 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。 DNS服务器分类 根域名服务器 顶级域名服务器 权限域名服务器 本地域名服务器 DNS记录类型笔者从阿里云截图得到的： DNS协议解析方式 递归查询：主机向本地域名服务器器的查询 如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报⽂(代替主机继续查询)。最终的查询结果有两种，要么找到了 IP 地址，要么返回错误。 迭代查询：本地域名服务器器向根域名服务器器的查询 当根域名服务器收到本地域名服务器发出的迭代查询请求报⽂时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个DNS服务器进⾏查询，然后让本地服务器进行后续的查询。 根域名服务器器常是把⾃己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下⼀步应当向哪⼀个权限域名服务器进⾏查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。 DNS解析过程1）首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表； 2）若没有命中，则继续搜索操作系统的 DNS 缓存； 3）若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是递归查询）； 4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行迭代查询（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）： 首先本地域名服务器向根域名服务器发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址 4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来 5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来 6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来 DNS域名缓存为了提高DNS查询效率，并减少因特网上的DNS查询保存数量，在DNS域名服务器中使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。 计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS 操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件。 DNS协议故障原因 DNS服务器自身出现问题 域名受到DNS攻击 DNS解析配置错误，如：域名解析目标IP设置错误 客户机或者服务器本地的hosts文件配置不当 常用的DNS协议工具nslookupnslookup全称是”query Internet name server interactively”，主要用来查询DNS。 mac下自带了这个工具： 直接查询域名ip12345678$ nslookup&gt; google.comServer: 192.168.1.1Address: 192.168.1.1#53Non-authoritative answer:Name: google.comAddress: 46.82.174.69 连接指定DNS服务器查询域名ip123456789101112$ nslookup# 连接到8.8.8.8域名服务器&gt; server 8.8.8.8Default server: 8.8.8.8Address: 8.8.8.8#53&gt; google.comServer: 8.8.8.8Address: 8.8.8.8#53Name: google.comAddress: 59.24.3.174 查看DNS配置信息12345678910111213$ nslookup&gt; set allDefault server: 192.168.1.1Address: 192.168.1.1#53Default server: 192.168.0.1Address: 192.168.0.1#53Set options: novc nodebug nod2 search recurse timeout = 0 retry = 3 port = 53 ndots = 1 querytype = A class = IN srchlist = man nslookup找到的可用的set字段： INthe Internet class CHthe Chaos class HSthe Hesiod class ANYwildcard The class specifies the protocol group of the information. (Default = IN; abbreviation = cl) [no]debugTurn on or off the display of the full response packet and any intermediate response packets when searching. (Default = nodebug; abbreviation = [no]deb) [no]d2Turn debugging mode on or off. This displays more about what nslookup is doing. (Default = nod2) domain=nameSets the search list to name. [no]searchIf the lookup request contains at least one period but doesn’t end with a trailing period, append the domain names in the domainsearch list to the request until an answer is received. (Default = search) port=valueChange the default TCP/UDP name server port to value. (Default = 53; abbreviation = po) querytype=value type=valueChange the type of the information query. (Default = A; abbreviations = q, ty) [no]recurseTell the name server to query other servers if it does not have the information. (Default = recurse; abbreviation = [no]rec) ndots=numberSet the number of dots (label separators) in a domain that will disable searching. Absolute names always stop searching. retry=numberSet the number of retries to number. timeout=numberChange the initial timeout interval for waiting for a reply to number seconds. [no]vcAlways use a virtual circuit when sending requests to the server. (Default = novc) [no]failTry the next nameserver if a nameserver responds with SERVFAIL or a referral (nofail) or terminate query (fail) on such aresponse. (Default = nofail) digdig工具是用于查询DNS记录的工具，功能比nslookup更加强大，mac下自带了这个工具： dig有意思的玩法： 查看某个域名的DNS解析过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ dig yankaizhang.com +trace; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; yankaizhang.com +trace# 先找到本地域名服务器;; global options: +cmd. 3153 IN NS m.root-servers.net.. 3153 IN NS h.root-servers.net.. 3153 IN NS a.root-servers.net.. 3153 IN NS b.root-servers.net.. 3153 IN NS k.root-servers.net.. 3153 IN NS l.root-servers.net.. 3153 IN NS i.root-servers.net.. 3153 IN NS f.root-servers.net.. 3153 IN NS j.root-servers.net.. 3153 IN NS e.root-servers.net.. 3153 IN NS c.root-servers.net.. 3153 IN NS g.root-servers.net.. 3153 IN NS d.root-servers.net.;; Received 239 bytes from 192.168.1.1#53(192.168.1.1) in 36 ms# 本地域名服务器请求根域名服务器（递归查询）com. 172800 IN NS a.gtld-servers.net.com. 172800 IN NS b.gtld-servers.net.com. 172800 IN NS c.gtld-servers.net.com. 172800 IN NS d.gtld-servers.net.com. 172800 IN NS e.gtld-servers.net.com. 172800 IN NS f.gtld-servers.net.com. 172800 IN NS g.gtld-servers.net.com. 172800 IN NS h.gtld-servers.net.com. 172800 IN NS i.gtld-servers.net.com. 172800 IN NS j.gtld-servers.net.com. 172800 IN NS k.gtld-servers.net.com. 172800 IN NS l.gtld-servers.net.com. 172800 IN NS m.gtld-servers.net.com. 86400 IN DS 30909 8 2 E2D3C916F6DEEAC73294E8268FB5885044A833FC5459588F4A9184CF C41A5766com. 86400 IN RRSIG DS 8 1 86400 20210909050000 20210827040000 26838 . ZLTCRLor3hezbp3CvYQbJCE+4XLPCvLOPlWx+cXru6A0snY2Dkv44JX8 hMpgiueL+Jp1rem/CqAZbLfacGe3cpJJpEkxK5Xob8BKRj4bQE+wH6Et gLy97rFKvCmpf80q29GEgxD5XwRFZoMSqnoNRGMUjPe8yTBoCiGPo+RF UBm0oQ0L2YmNeBEy0KSe+EI4ySUw3BLPSRAu2R/CkpISY2JFmnuG6jSE uM7T9Y5tgFYS7Kvba1NiMsBIiLy3KrijjwczSVCWl+9IKCqaQpCmVqES npK7x9Y0uzlTgNwo8IC1nKzKqvBz7S1UibvTQNxaKK/+Kd8R2lixbO8Y 4ErY0Q==;; Received 1175 bytes from 193.0.14.129#53(k.root-servers.net) in 47 ms# 根域名服务器通知本地域名服务器去yankaizhang.com.顶级域名服务器（迭代查询）yankaizhang.com. 172800 IN NS dns2.hichina.com.yankaizhang.com. 172800 IN NS dns1.hichina.com.CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN NSEC3 1 1 0 - CK0Q1GIN43N1ARRC9OSM6QPQR81H5M9A NS SOA RRSIG DNSKEY NSEC3PARAMCK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN RRSIG NSEC3 8 2 86400 20210901042504 20210825031504 39343 com. UjMhvFuOAHV8bbjokUqcBsgJe3Bf2xtTLT2JLkt5wXb40qu6XWzZArOl jTO3BwtnAj7D/KQIqNsBRq0P/Djh8GGgSUhMFCbcel9G6CVESLYq6/E1 SKhGl72pxNtYDHEB5RYnBxsg55rh+gZWZMlhS5h+EjTkz692t8U8lB2C OmIyJpCUsldl7ciWmxMRHwennzbemMT5rhfDSe/SRT4WsQ==RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN NSEC3 1 1 0 - RTC22ASFHJHTLN9NCAREUK0D41R9BA1B NS DS RRSIGRTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN RRSIG NSEC3 8 2 86400 20210831051456 20210824040456 39343 com. lmTGKCex0R26RXHbTQbyUcWejz0KIeJtpYhHNs2lyGWV8rY3E9vf+moL Kwqk3Fkk5YU8DEiMLCzkyWxGeqmnlxZVtGqmxDLnkrt83frflR2piT9k uWnJXlocN6XNvrlsEk+eGyzFGRPRMMdnu2JlWx6RYVS1b0PqmJJTLOPL EHqUYaZshDNhE2Bo9JMPtZMDRQoI+/GlTc+4htFDFxT9Iw==;; Received 951 bytes from 192.41.162.30#53(l.gtld-servers.net) in 281 ms# 查询结束，得到记录值（这里是CNAME）yankaizhang.com. 600 IN CNAME yankaizhang.com.cdn.dnsv1.com.;; Received 87 bytes from 106.11.211.64#53(dns2.hichina.com) in 27 ms 查找一个域名的授权DNS服务器 1234567891011121314151617$ dig yankaizhang.com +nssearchSOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.24 in 26 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.63 in 27 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.64 in 27 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.23 in 28 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.13 in 31 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.53 in 31 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.54 in 31 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.23 in 31 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.14 in 31 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.14 in 37 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.13 in 37 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.24 in 37 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.123 in 47 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.114 in 48 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.124 in 49 ms.SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.113 in 62 ms 查看域名的正向解析和反向解析 12$ dig yankaizhang.com$ dig -x yankaizhang.com hosthost工具也是mac自带的一个DNS查询工具，其功能和输入输出和dig差不多，参数操作方式有所不同 个人使用： 123456789101112131415$ host -a yankaizhang.comTrying &quot;yankaizhang.com&quot;;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64983;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;yankaizhang.com. IN ANY;; ANSWER SECTION:yankaizhang.com. 600 IN CNAME yankaizhang.com.cdn.dnsv1.com.yankaizhang.com. 3600 IN NS dns1.hichina.com.yankaizhang.com. 3600 IN NS dns2.hichina.com.Received 119 bytes from 192.168.1.1#53 in 207 ms 参考https://segmentfault.com/a/1190000039039275 https://www.cnblogs.com/549294286/p/5172435.html https://cloud.tencent.com/developer/article/1083201 https://www.cnblogs.com/machangwei-8/p/10353216.html","link":"/2021/08/27/DNS%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"},{"title":"unix网络编程-1-简单时间服务器","text":"根据书上内容，编写一个简单的获取时间的客户端、服务器如下： time client12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;commons.h&quot;/** * time check client */int main(int argc, char const *argv[]) { // fd socket描述符 int fd; // 目标服务器socket包装体 struct sockaddr_in svraddr; if (argc &lt; 2) { perror(&quot;usage: client &lt;ip&gt;\\n&quot;); } fd = common_socket(AF_INET, SOCK_STREAM, 0); // 初始化目标服务器信息 memset(&amp;svraddr, 0, sizeof(svraddr)); svraddr.sin_family = AF_INET; svraddr.sin_port = htons(13); // 时间服务器，端口13 // 将ip地址串转换为in_addr(整数)，然后赋值给svraddr if (inet_pton(AF_INET, argv[1], &amp;svraddr.sin_addr) &lt;= 0) { perror(&quot;inet_pton error\\n&quot;); } // 尝试连接服务器 common_connect(fd, (SA *)&amp;svraddr, sizeof(svraddr)); // 读取服务器发送的信息，写入buf中并且打印 int len; char recvbuf[MAXLINE + 1]; while ((len = common_read(fd, recvbuf, MAXLINE)) &gt; 0) { recvbuf[len] = '\\0'; printf(&quot;%s&quot;, recvbuf); } return EXIT_SUCCESS;} time server123456789101112131415161718192021222324252627282930313233343536#include &quot;commons.h&quot;#define LISTEN_NUMBER 1024int main(int argc, char const *argv[]) { // 监听socket描述符，连接socket描述符 int listenfd, connfd; struct sockaddr_in svraddr; char wrtbuf[MAXLINE]; time_t ticks; listenfd = common_socket(AF_INET, SOCK_STREAM, 0); // 初始化服务器信息 memset(&amp;svraddr, 0, sizeof(svraddr)); svraddr.sin_family = AF_INET; svraddr.sin_port = htons(13); svraddr.sin_addr.s_addr = htonl(INADDR_ANY); // 绑定监听socket和服务器socket信息 common_bind(listenfd, (SA *)&amp;svraddr, sizeof(svraddr)); // 最多同时监听1024个连接 common_listen(listenfd, LISTEN_NUMBER); // 接收客户端连接socket while (1) { connfd = accept(listenfd, NULL, NULL); ticks = time(NULL); snprintf(wrtbuf, sizeof(wrtbuf), &quot;%.24s\\r\\n&quot;, ctime(&amp;ticks)); common_write(connfd, wrtbuf, strlen(wrtbuf)); common_close(connfd); } exit(EXIT_SUCCESS);} commons.h 公共头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 公共头文件 */#include &lt;arpa/inet.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#define MAXLINE 1024typedef struct sockaddr SA;// 新建socketint common_socket(int family, int sock_type, int protocol) { int fd; if ((fd = (socket(family, sock_type, protocol))) &lt; 0) { perror(&quot;common_socket error\\n&quot;); exit(EXIT_FAILURE); } return fd;}// 连接socketvoid common_connect(int sockfd, const SA *svraddr, socklen_t socklen) { if (connect(sockfd, svraddr, socklen) &lt; 0) { perror(&quot;common_connect error\\n&quot;); exit(EXIT_FAILURE); }}// 绑定socketvoid common_bind(int listenfd, const SA *svraddr, socklen_t socklen) { if (bind(listenfd, svraddr, socklen) &lt; 0) { perror(&quot;common_bind error\\n&quot;); exit(EXIT_FAILURE); }}// 监听socketvoid common_listen(int listenfd, int conn_number) { if (listen(listenfd, conn_number) &lt; 0) { perror(&quot;common_listen error\\n&quot;); exit(EXIT_FAILURE); }}// 读取socketint common_read(int sockfd, void *recvbuf, size_t recvlen) { int len; if ((len = read(sockfd, recvbuf, recvlen)) &lt; 0) { perror(&quot;common_read error\\n&quot;); exit(EXIT_FAILURE); } return len;}// 写入socketvoid common_write(int connfd, const void *buf, size_t nbytes) { if (write(connfd, buf, nbytes) &lt; 0) { perror(&quot;common_write error\\n&quot;); exit(EXIT_FAILURE); }}// 关闭socketvoid common_close(int connfd) { if (close(connfd) &lt; 0) { perror(&quot;common_close error\\n&quot;); exit(EXIT_FAILURE); }} 运行效果","link":"/2021/09/06/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1-%E7%AE%80%E5%8D%95%E6%97%B6%E9%97%B4%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"线程池的shutdown和shutdownNow方法","text":"使用Java的线程池ThreadPoolExecutor类时候发现了两个不同的关闭线程池的方法：shutdown和shutdownNow方法，具体这两个方法有啥区别呢？这次一起来探讨一下： 线程池的状态runState阅读ThreadPoolExecutor类的源码不难看出，线程池实现类中定义了线程池具有几个状态： 12345678910111213141516/** The runState provides the main lifecycle control, taking on values:* RUNNING: Accept new tasks and process queued tasks* SHUTDOWN: Don't accept new tasks, but process queued tasks* STOP: Don't accept new tasks, don't process queued tasks,* and interrupt in-progress tasks* TIDYING: All tasks have terminated, workerCount is zero,* the thread transitioning to state TIDYING* will run the terminated() hook method* TERMINATED: terminated() has completed*/private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 同时，类源码中也解释了上面五个状态之间是如何切换的，这里笔者整理成一个状态转换图好了： 从上面的图中可以看到，这次要讨论的shutdown和shutdownNow方法是和SHUTDOWN、STOP状态相关联的 shutdown()方法线程池内部主要存在两个部分：保存工作线程的HashSet集合Workers，保存待执行任务的BlockingQueue集合taskQueue，线程池释放的时候，主要需要处理并且释放的资源内容也就是这两块。 对于shutdown方法，这个方法返回值为void。 执行了shutdown方法之后，线程池的状态切换为SHUTDOWN状态 对于taskQueue，线程池不再接受新的任务提交请求，但是会等待队列中已存在的任务全部执行完成 shutdownNow()方法对于shutdownNow方法，这个方法返回List&lt;Runnable&gt;，尚未开始执行的任务列表 执行了shutdownNow方法之后，线程池的状态切换为STOP状态 对于taskQueue，线程池不再接受新的任务提交请求，并且尝试interrupt中断开始执行的任务（不一定中断成功），队列中尚未执行的任务全部以列表形式返回 何时进入TERMINATED状态从线程池的状态转换图中可以看到，从调用了shutdown或者shutdownNow方法到最终线程池结束工作的TERMINATED状态仍然有一段距离，因为可能执行的任务还需要执行完成。 一般来说，因为调用shutdown或shutdownNow方法是立即返回的，并不会阻塞等待所有任务完成，所以线程池提供了额外的awaitTermination函数来实现阻塞等待所有工作完成，并且到达了TERMINATED状态。 1public boolean awaitTermination(long timeout, TimeUnit unit); 方法内部借助一个condition变量实现了阻塞等待，并且在所有任务结束时唤醒返回true","link":"/2021/09/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84shutdown%E5%92%8CshutdownNow%E6%96%B9%E6%B3%95/"},{"title":"unix网络编程-2-实现一个pthread_pool","text":"这次使用C语言，设计一个基于pthread的线程池吧。 想要设计线程池的原因有三个： 想要重新锻炼下C语言的编码能力 面试经常出现一些线程池的内容，笔者比较反感这些八股文，所以就简单实现一个线程池好了 线程池所谓服务端必不可少的组件，后面继续学习unix网络编程的时候会用到 在开始之前按照惯例介绍一下环境： macOS 10.15 gcc工具链（clang） gdb调试（brew install gdb） 开始设计线程池结构笔者参考了Java提供的ThreadPoolExecutor类，也就是线程池类，当然也顺便研究了一下源码，发现略有点复杂，我们这次就实现一个Fixed_Pool，也就是核心线程就等于工作线程数好了。 给出线程池pthread_pool的设计图如下： 单看图的话还是比较简单的，因为这次写一个固定核心线程数的线程池，比如上图，核心线程数为2，等待队列长度为4，某一时刻，这个线程池能负载的最大任务数为6个（2个正在执行，4个等待执行） 如果等待队列已满，此时再尝试提交任务的话就会返回-1，代表提交失败。 定义核心结构体从上面的设计图中看到，需要设计的结构有两个：pthread_pool类型和task任务类型 于是给出下面的设计： 123456789101112131415161718192021222324252627282930313233/** * pthread_pool * 实现一个基于pthread的Fixed线程池，创建初期就初始化n个线程，n个核心线程全部活跃 * 线程池真正可以负载的任务数量t = 线程数量w + 等待队列长度n * 例如：一个3核心线程，队列长度为2的线程池，其负载能力最大为5 */typedef enum _pthread_pool_state { RUNNING, // 运行 TERMINATED // 结束} pthread_pool_state;typedef struct _pthread_pool_task_t { void *(*func)(void *); // 任务函数 void *args; // 函数参数} pthread_pool_task_t;struct pthread_pool_t { pthread_mutex_t mutex; // 内部锁 pthread_cond_t cond; // 同步条件 pthread_t *threads; // 线程数组 int thread_count; // 核心线程数量 pthread_pool_task_t *task_queue; // 任务队列 int task_head; // 头部指针 int task_tail; // 尾部指针 int task_queue_size; // 最大任务队列长度 int task_count; // 当前任务数量 pthread_pool_state pool_state; // 线程池状态};#define SPP struct pthread_pool_t 笔者这里额外加了一个state枚举类型来表示线程池当前的执行状态，当然执行状态很简单只有两种：运行中和终止 设计线程池的关键函数对于一个线程池，不难想到有几个核心方法需要设计并且实现：创建、提交任务、核心线程工作函数、关闭、释放资源 下面给出笔者设计的这5个函数的定义： 12345void *pthread_pool_worker(void *);void pthread_pool_release(SPP *);int pthread_pool_submit(SPP *, void *(*)(void *), void *);void pthread_pool_shutdown(SPP *);SPP *pthread_pool_create(int, int); pthread_pool_create函数实现创建一个线程池，即定义一个结构体对象，然后分配相应的内存，同时初始化其中的一些参数即可。 因为是核心线程全部运行，所以创建的时候就初始化核心线程数量的工作线程数组 12345678910111213141516171819202122232425262728293031323334353637383940// 新建一个线程池SPP *pthread_pool_create(int thread_count, int queue_size) { assert(thread_count &gt; 0 &amp;&amp; queue_size &gt; 0); SPP *tmp = (SPP *)malloc(sizeof(SPP)); if (pthread_mutex_init(&amp;tmp-&gt;mutex, NULL) != 0) return NULL; if (pthread_cond_init(&amp;tmp-&gt;cond, NULL) != 0) return NULL; pthread_attr_t tmp_attr; if (pthread_attr_init(&amp;tmp_attr) != 0) return NULL; tmp-&gt;thread_count = thread_count; tmp-&gt;threads = (pthread_t *)malloc(thread_count * sizeof(pthread_t)); tmp-&gt;task_queue_size = queue_size; tmp-&gt;task_queue = (pthread_pool_task_t *)malloc(queue_size * sizeof(pthread_pool_task_t)); tmp-&gt;task_head = 0; tmp-&gt;task_tail = 0; tmp-&gt;task_count = 0; tmp-&gt;pool_state = RUNNING; // 设置线程退出时自动回收资源 pthread_attr_setdetachstate(&amp;tmp_attr, PTHREAD_CREATE_DETACHED); int flag = 1; for (int i = 0; i &lt; tmp-&gt;thread_count; ++i) { // printf(&quot;创建%d号线程\\n&quot;, i); int ret = pthread_create(&amp;(tmp-&gt;threads[i]), &amp;tmp_attr, pthread_pool_worker, tmp); if (ret != 0) { flag = 0; break; } } if (!flag) { pthread_pool_shutdown(tmp); return NULL; } return tmp;} pthread_pool_worker函数实现worker函数是线程池每个内置工作线程不断运行的一个方法，在这个方法里线程不断检查任务队列是否有任务需要完成，否则就阻塞等待被唤醒；如何唤醒呢？当提交任务的时候会通过condition唤醒阻塞的线程检查任务队列执行。 当确认存在任务需要完成的时候，线程会获取这个任务并且将任务队列头指针后移一位，然后执行这个任务 如果线程池需要关闭，那么worker函数会break退出，同时回收工作线程资源 1234567891011121314151617181920212223242526272829// 线程池内置线程处理函数void *pthread_pool_worker(void *args) { SPP *pool = (SPP *)args; pthread_pool_task_t task; while (1) { pthread_mutex_lock(&amp;(pool-&gt;mutex)); // 尝试循环获取任务，没有任务就阻塞等待 while (pool-&gt;task_count == 0 &amp;&amp; pool-&gt;pool_state == RUNNING) { pthread_cond_wait(&amp;(pool-&gt;cond), &amp;(pool-&gt;mutex)); } if (pool-&gt;pool_state != RUNNING) break; task.func = pool-&gt;task_queue[pool-&gt;task_head].func; task.args = pool-&gt;task_queue[pool-&gt;task_head].args; pool-&gt;task_head++; if (pool-&gt;task_head == pool-&gt;task_queue_size) pool-&gt;task_head = 0; pool-&gt;task_count--; pthread_mutex_unlock(&amp;(pool-&gt;mutex)); // 执行任务 task.func(task.args); } pthread_mutex_unlock(&amp;(pool-&gt;mutex)); pthread_exit(NULL); return NULL;} pthread_pool_submit函数实现向线程池中提交一个任务，然后尝试唤醒阻塞等待的工作线程，移动tail指针 1234567891011121314151617181920212223242526// 提交一个任务int pthread_pool_submit(SPP *pool, void *(*func)(void *), void *args) { if (!pool || !func) return -1; pthread_mutex_lock(&amp;(pool-&gt;mutex)); int flag = -1; do { // 判断下一个tail位置 int pos = pool-&gt;task_tail + 1; pos = ((pos == pool-&gt;task_queue_size) ? 0 : pos); if (pool-&gt;task_queue_size == pool-&gt;task_count) break; if (pool-&gt;pool_state != RUNNING) break; pool-&gt;task_queue[pool-&gt;task_tail].func = func; pool-&gt;task_queue[pool-&gt;task_tail].args = args; pool-&gt;task_tail = pos; pool-&gt;task_count++; pthread_cond_signal(&amp;(pool-&gt;cond)); flag = 0; } while (0); pthread_mutex_unlock(&amp;(pool-&gt;mutex)); return flag;} 剩余函数实现关闭和回收线程池资源，C语言的动态内存操作需要小心一点 1234567891011121314151617181920212223242526272829// 关闭线程池void pthread_pool_shutdown(SPP *pool) { pthread_mutex_lock(&amp;(pool-&gt;mutex)); while (pool-&gt;pool_state == RUNNING) { pool-&gt;pool_state = TERMINATED; } // 唤醒所有可能等待的核心线程 pthread_cond_signal(&amp;(pool-&gt;cond)); // 尝试取消所有正在运行的线程 for (int i = 0; i &lt; pool-&gt;thread_count; i++) { printf(&quot;尝试取消线程%d...\\n&quot;, i); pthread_cancel(pool-&gt;threads[i]); } pthread_mutex_unlock(&amp;(pool-&gt;mutex)); pthread_pool_release(pool);}// 释放线程池资源void pthread_pool_release(SPP *pool) { if (pool-&gt;threads) free(pool-&gt;threads); if (pool-&gt;task_queue) free(pool-&gt;task_queue); pthread_mutex_destroy(&amp;(pool-&gt;mutex)); pthread_cond_destroy(&amp;(pool-&gt;cond)); free(pool);} 关闭线程池的方法这里是非阻塞的，调用了之后不一定会结束所有正在工作的线程。 关闭线程池的时候尝试取消正在运行的线程，如果运行线程内部是个死循环并且没有监听取消事件，会造成程序无法结束。 验证线程池功能简单写一个程序验证线程池的功能 首先给出上面线程池必须依赖的头文件内容： 1234567891011121314151617181920#ifndef _COMMONS_H_#define _COMMONS_H_#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;memory.h&gt;#include &lt;netinet/in.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#endif 然后简单写一个main.c来测试线程池的功能： 123456789101112131415161718192021222324252627282930313233#include &quot;pool.h&quot;#include &quot;time.h&quot;void *task(void *args) { time_t t = time(NULL); printf(&quot;[Thread-%d]: %s&quot;, pthread_self(), ctime(&amp;t)); sleep(1); return NULL;}int main(int argc, char const *argv[]) { // 新建一个线程池 SPP *pool = pthread_pool_create(3, 50); int cnt = 0; for (int i = 1; i &lt;= 100; i++) { int ret = pthread_pool_submit(pool, task, NULL); if (ret != 0) { printf(&quot;%d 号任务提交失败...\\n&quot;, i); } else { printf(&quot;%d 号任务提交成功!!!\\n&quot;, i); cnt++; } } printf(&quot;成功提交任务数量：%d\\n&quot;, cnt); // 主线程阻塞不退出 pthread_exit(NULL); // 尝试关闭线程池 pthread_pool_shutdown(pool); return 0;} 这里创建了一个核心数量为3，等待队列大小为50的线程池，所以可以得到同一时刻可以提交的最大任务数量是53个任务，其余的任务会提交失败。 因为核心数量是3，所以同一时刻运行会有3个不同线程执行任务，并且打出当前时间，这里直接给出一部分的输出吧： 12$ cc -g pool.c main.c -lpthread$ ./a.out 输出如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561 号任务提交成功!!!2 号任务提交成功!!!3 号任务提交成功!!!4 号任务提交成功!!!5 号任务提交成功!!!6 号任务提交成功!!!7 号任务提交成功!!!8 号任务提交成功!!!9 号任务提交成功!!!10 号任务提交成功!!!11 号任务提交成功!!!12 号任务提交成功!!!13 号任务提交成功!!!14 号任务提交成功!!!15 号任务提交成功!!!16 号任务提交成功!!!17 号任务提交成功!!!18 号任务提交成功!!!19 号任务提交成功!!!20 号任务提交成功!!!21 号任务提交成功!!!22 号任务提交成功!!!23 号任务提交成功!!!24 号任务提交成功!!!25 号任务提交成功!!!26 号任务提交成功!!!27 号任务提交成功!!!28 号任务提交成功!!!29 号任务提交成功!!!30 号任务提交成功!!!31 号任务提交成功!!!32 号任务提交成功!!!33 号任务提交成功!!!34 号任务提交成功!!!35 号任务提交成功!!!36 号任务提交成功!!!37 号任务提交成功!!!38 号任务提交成功!!!39 号任务提交成功!!!40 号任务提交成功!!!41 号任务提交成功!!!42 号任务提交成功!!!43 号任务提交成功!!!44 号任务提交成功!!!45 号任务提交成功!!!46 号任务提交成功!!!47 号任务提交成功!!!48 号任务提交成功!!!49 号任务提交成功!!!50 号任务提交成功!!!51 号任务提交成功!!!52 号任务提交成功!!!53 号任务提交成功!!!54 号任务提交失败...55 号任务提交失败...56 号任务提交失败...57 号任务提交失败...58 号任务提交失败...59 号任务提交失败...60 号任务提交失败...61 号任务提交失败...62 号任务提交失败...63 号任务提交失败...64 号任务提交失败...65 号任务提交失败...66 号任务提交失败...67 号任务提交失败...68 号任务提交失败...69 号任务提交失败...70 号任务提交失败...71 号任务提交失败...72 号任务提交失败...73 号任务提交失败...74 号任务提交失败...75 号任务提交失败...76 号任务提交失败...77 号任务提交失败...78 号任务提交失败...79 号任务提交失败...80 号任务提交失败...81 号任务提交失败...82 号任务提交失败...83 号任务提交失败...84 号任务提交失败...85 号任务提交失败...86 号任务提交失败...87 号任务提交失败...88 号任务提交失败...89 号任务提交失败...90 号任务提交失败...91 号任务提交失败...92 号任务提交失败...93 号任务提交失败...94 号任务提交失败...95 号任务提交失败...96 号任务提交失败...97 号任务提交失败...98 号任务提交失败...99 号任务提交失败...100 号任务提交失败...成功提交任务数量：53[Thread-27713536]: Thu Sep 9 18:40:49 2021[Thread-28250112]: Thu Sep 9 18:40:49 2021[Thread-28786688]: Thu Sep 9 18:40:49 2021[Thread-28786688]: Thu Sep 9 18:40:50 2021[Thread-28250112]: Thu Sep 9 18:40:50 2021[Thread-27713536]: Thu Sep 9 18:40:50 2021[Thread-28786688]: Thu Sep 9 18:40:51 2021[Thread-28250112]: Thu Sep 9 18:40:51 2021[Thread-27713536]: Thu Sep 9 18:40:51 2021[Thread-28786688]: Thu Sep 9 18:40:52 2021[Thread-28250112]: Thu Sep 9 18:40:52 2021[Thread-27713536]: Thu Sep 9 18:40:52 2021[Thread-28786688]: Thu Sep 9 18:40:53 2021[Thread-28250112]: Thu Sep 9 18:40:53 2021[Thread-27713536]: Thu Sep 9 18:40:53 2021[Thread-28250112]: Thu Sep 9 18:40:54 2021[Thread-27713536]: Thu Sep 9 18:40:54 2021[Thread-28786688]: Thu Sep 9 18:40:54 2021[Thread-28250112]: Thu Sep 9 18:40:55 2021[Thread-27713536]: Thu Sep 9 18:40:55 2021[Thread-28786688]: Thu Sep 9 18:40:55 2021[Thread-28250112]: Thu Sep 9 18:40:56 2021[Thread-27713536]: Thu Sep 9 18:40:56 2021[Thread-28786688]: Thu Sep 9 18:40:56 2021[Thread-28786688]: Thu Sep 9 18:40:57 2021[Thread-28250112]: Thu Sep 9 18:40:57 2021[Thread-27713536]: Thu Sep 9 18:40:57 2021[Thread-28786688]: Thu Sep 9 18:40:58 2021[Thread-28250112]: Thu Sep 9 18:40:58 2021[Thread-27713536]: Thu Sep 9 18:40:58 2021[Thread-28786688]: Thu Sep 9 18:41:00 2021[Thread-28250112]: Thu Sep 9 18:41:00 2021[Thread-27713536]: Thu Sep 9 18:41:00 2021[Thread-28786688]: Thu Sep 9 18:41:01 2021[Thread-28250112]: Thu Sep 9 18:41:01 2021[Thread-27713536]: Thu Sep 9 18:41:01 2021[Thread-27713536]: Thu Sep 9 18:41:02 2021[Thread-28250112]: Thu Sep 9 18:41:02 2021[Thread-28786688]: Thu Sep 9 18:41:02 2021[Thread-27713536]: Thu Sep 9 18:41:03 2021[Thread-28786688]: Thu Sep 9 18:41:03 2021[Thread-28250112]: Thu Sep 9 18:41:03 2021[Thread-28250112]: Thu Sep 9 18:41:04 2021[Thread-27713536]: Thu Sep 9 18:41:04 2021[Thread-28786688]: Thu Sep 9 18:41:04 2021[Thread-28250112]: Thu Sep 9 18:41:05 2021[Thread-28786688]: Thu Sep 9 18:41:05 2021[Thread-27713536]: Thu Sep 9 18:41:05 2021[Thread-28250112]: Thu Sep 9 18:41:06 2021[Thread-27713536]: Thu Sep 9 18:41:06 2021[Thread-28786688]: Thu Sep 9 18:41:06 2021[Thread-28786688]: Thu Sep 9 18:41:07 2021[Thread-28250112]: Thu Sep 9 18:41:07 2021$ ^C 其他内容vscode配置的调试debug只能调试单文件，这次调试就是用的gdb来调试的 编译的时候加入-g参数生成debug信息，然后gdb a.out就可以调试程序了 对于多线程的调试，gdb也是很方便的，具体参考：https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html","link":"/2021/09/09/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-2-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApthread-pool/"}],"tags":[{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"DNS协议","slug":"DNS协议","link":"/tags/DNS%E5%8D%8F%E8%AE%AE/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"socket","slug":"socket","link":"/tags/socket/"},{"name":"Java并发编程","slug":"Java并发编程","link":"/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"线程池","slug":"线程池","link":"/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"pthread","slug":"pthread","link":"/tags/pthread/"}],"categories":[{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"网络编程","slug":"网络编程","link":"/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}