<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>听风合笙</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="听风合笙博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="听风合笙博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Personal Blog"><meta property="og:type" content="website"><meta property="og:title" content="听风合笙"><meta property="og:url" content="https://yankaizhang.com/"><meta property="og:site_name" content="听风合笙"><meta property="og:description" content="Personal Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yankaizhang.com/img/og_image.png"><meta property="article:author" content="Yankai"><meta property="article:tag" content="Java Spring Golang C++ MySQL Redis"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://yankaizhang.com"},"headline":"听风合笙","image":["https://yankaizhang.com/img/og_image.png"],"author":{"@type":"Person","name":"Yankai"},"publisher":{"@type":"Organization","name":"听风合笙","logo":{"@type":"ImageObject"}},"description":"Personal Blog"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?7fcd38d5517d90f8436b1e190a0a4055";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-VKKJ6LXQ9W" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-VKKJ6LXQ9W');</script><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">听风合笙</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">主页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/archives">文章列表</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/dzzhyk"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-13T14:11:06.000Z" title="2021/9/13 下午10:11:06">2021-09-13</time>发表</span><span class="level-item"><time dateTime="2021-09-13T15:00:25.520Z" title="2021/9/13 下午11:00:25">2021-09-13</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="level-item">13 分钟读完 (大约2008个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/09/13/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8ELRU%E3%80%81LFU%E7%9A%84%E5%AE%9E%E7%8E%B0/">双向链表与LRU、LFU的实现</a></h1><div class="content"><p>可以说LRU、LFU两种缓存淘汰策略是最近面试中常见的问题了，这次笔者就准备采用双向链表来实现一个LRU和LFU。</p>
<h2 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h2><p>缓存淘汰策略：一个缓存系统如果缓存大小达到了上限，如果有新的缓存内容存入时，需要淘汰掉一部分旧的缓存内容，这样才有空间存放缓存数据，同时要保证缓存替换的频率尽量低。</p>
<ul>
<li>  FIFO淘汰策略：队列式缓存，前出后进</li>
<li>  LRU淘汰策略：空间不足会淘汰掉最近最少使用的缓存</li>
<li>  LFU淘汰策略：根据缓存请求次数排序，空间不足会淘汰掉请求次数最少的缓存</li>
</ul>
<h2 id="实现LRU"><a href="#实现LRU" class="headerlink" title="实现LRU"></a>实现LRU</h2><p>实现LRU是经典的题目，这里采用哈希表+双向链表来实现LRU，具体的设计图如下：</p>
<p><img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913223510931.png" alt="LRU缓存（哈希表+双向链表）"></p>
<ol>
<li>  map中存放(key, 节点指针)，指针指向具体的双线链表节点</li>
<li>  维护一个双向链表，其头部是最近最多使用的缓存，尾部是最近最少使用缓存，如果缓存空间不足，淘汰掉尾部</li>
<li>  每次访问、存入新的缓存，将其放置在双向链表头部，表示刚刚使用</li>
</ol>
<h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>哈希表借助STL中的map，定义一个LRU结构体和双向链表节点Node</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU缓存，&quot;最近最少使用&quot;缓存淘汰策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Node *prev;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRU</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cap;	<span class="comment">// 总容量</span></span><br><span class="line">    <span class="keyword">int</span> len;	<span class="comment">// 当前容量</span></span><br><span class="line">    Node *head;</span><br><span class="line">    Node *tail;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, Node *&gt; cache;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LRU *<span class="title">lru_create</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lru_put</span><span class="params">(LRU *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lru_get</span><span class="params">(LRU *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lru_destroy</span><span class="params">(LRU *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lru_print</span><span class="params">(LRU *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">lru_remove_node</span><span class="params">(LRU *, Node *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lru_push_first</span><span class="params">(LRU *, Node *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lru_pop_last</span><span class="params">(LRU *)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>对于LRU，笔者这里核心实现了下面三个方法：</strong></p>
<ol>
<li>  <strong>lru_remove_node：移除任意一个节点</strong></li>
<li>  <strong>lru_push_first：向双向链表首部添加节点</strong></li>
<li>  <strong>lru_pop_last：移除双向链表最后一个节点</strong></li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRU *<span class="title">lru_create</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    LRU *tmp = (LRU *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LRU));</span><br><span class="line">    tmp-&gt;cache = map&lt;<span class="keyword">int</span>, Node *&gt;();</span><br><span class="line">    tmp-&gt;cap = size;</span><br><span class="line">    tmp-&gt;len = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;head = (Node *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line">    tmp-&gt;tail = (Node *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line">    tmp-&gt;head-&gt;next = tmp-&gt;tail;</span><br><span class="line">    tmp-&gt;tail-&gt;prev = tmp-&gt;head;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lru_destroy</span><span class="params">(LRU *lru)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lru) <span class="keyword">return</span>;</span><br><span class="line">    Node *tmp = lru-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">        Node *t = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lru_put</span><span class="params">(LRU *lru, <span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lru) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (lru-&gt;len &gt;= lru-&gt;cap) <span class="built_in">lru_pop_last</span>(lru);</span><br><span class="line">    <span class="keyword">if</span> (lru-&gt;cache.<span class="built_in">find</span>(key) != lru-&gt;cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        Node *tmp = lru-&gt;cache[key];</span><br><span class="line">        tmp = <span class="built_in">lru_remove_node</span>(lru, tmp);</span><br><span class="line">        tmp-&gt;v = val;</span><br><span class="line">        <span class="built_in">lru_push_first</span>(lru, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *tmp = (Node *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line">        tmp-&gt;k = key;</span><br><span class="line">        tmp-&gt;v = val;</span><br><span class="line">        <span class="built_in">lru_push_first</span>(lru, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lru_get</span><span class="params">(LRU *lru, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lru) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lru-&gt;cache.<span class="built_in">find</span>(key) != lru-&gt;cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        Node *tmp = <span class="built_in">lru_remove_node</span>(lru, lru-&gt;cache[key]);</span><br><span class="line">        <span class="built_in">lru_push_first</span>(lru, tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双向链表中移除一个节点</span></span><br><span class="line"><span class="function">Node *<span class="title">lru_remove_node</span><span class="params">(LRU *lru, Node *node)</span> </span>&#123;</span><br><span class="line">    Node *tmp = node-&gt;next;</span><br><span class="line">    node-&gt;prev-&gt;next = tmp;</span><br><span class="line">    tmp-&gt;prev = node-&gt;prev;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    lru-&gt;len--;</span><br><span class="line">    lru-&gt;cache.<span class="built_in">erase</span>(node-&gt;k);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点插入到双向链表头部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lru_push_first</span><span class="params">(LRU *lru, Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lru || !node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (lru-&gt;len &gt;= lru-&gt;cap) <span class="built_in">lru_pop_last</span>(lru);</span><br><span class="line">    Node *tmp = lru-&gt;head-&gt;next;</span><br><span class="line">    node-&gt;next = tmp;</span><br><span class="line">    tmp-&gt;prev = node;</span><br><span class="line">    lru-&gt;head-&gt;next = node;</span><br><span class="line">    node-&gt;prev = lru-&gt;head;</span><br><span class="line">    lru-&gt;len++;</span><br><span class="line">    lru-&gt;cache[node-&gt;k] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除双向链表的尾部节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lru_pop_last</span><span class="params">(LRU *lru)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lru-&gt;len &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node *tmp = lru-&gt;tail-&gt;prev;</span><br><span class="line">    Node *t = tmp-&gt;prev;</span><br><span class="line">    t-&gt;next = lru-&gt;tail;</span><br><span class="line">    lru-&gt;tail-&gt;prev = t;</span><br><span class="line">    lru-&gt;cache.<span class="built_in">erase</span>(tmp-&gt;k);</span><br><span class="line">    lru-&gt;len--;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即时打印缓存内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lru_print</span><span class="params">(LRU *lru)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------\n&quot;</span>;</span><br><span class="line">    Node *tmp = lru-&gt;head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (tmp != lru-&gt;tail) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; tmp-&gt;k &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; tmp-&gt;v &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="验证LRU效果"><a href="#验证LRU效果" class="headerlink" title="验证LRU效果"></a>验证LRU效果</h3><p>补充main函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LRU *lru = <span class="built_in">lru_create</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lru_put</span>(lru, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">lru_print</span>(lru);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lru_put</span>(lru, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">lru_print</span>(lru);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">lru_get</span>(lru, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">lru_print</span>(lru);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lru_put</span>(lru, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">lru_print</span>(lru);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">lru_get</span>(lru, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">lru_print</span>(lru);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">lru_get</span>(lru, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">lru_print</span>(lru);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lru_put</span>(lru, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">lru_print</span>(lru);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">lru_get</span>(lru, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">lru_print</span>(lru);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lru_destroy</span>(lru);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证一下效果，从左到右是双向链表首至尾的内容：</p>
<img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913224007315.png" alt="LRU执行结果" style="zoom: 67%;" />



<h2 id="实现LFU"><a href="#实现LFU" class="headerlink" title="实现LFU"></a>实现LFU</h2><p>对于LFU，虽然比较好理解，但是实现起来笔者还是需要仔细思考一会的，如果是面试场景下问到LRU之后，很容易连坐扯出LFU，所以这里也思考了一下LFU的实现方式，并且给出的具体实现。</p>
<p><img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913224436981.png" alt="LFU缓存（哈希表+双向链表）"></p>
<p>这里笔者继续采用一种基于双向链表的实现方式，不同的是每个双向链表节点Node里面需要多出cnt属性来记录访问该Node节点的次数。除此之外，双向链表的头部是急需淘汰的元素，反而尾部是使用次数cnt最多，不需要淘汰的元素</p>
<p>对于哈希表，这里依然采用STL中的map来实现。</p>
<h3 id="定义结构体-1"><a href="#定义结构体-1" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>和LRU的结构体几乎相同，除了节点多出了cnt属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LFU缓存，&quot;最不经常使用&quot;缓存淘汰策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> cnt;	<span class="comment">// 访问次数</span></span><br><span class="line">    Node *prev;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LFU</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    Node *head;</span><br><span class="line">    Node *tail;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, Node *&gt; cache;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LFU *<span class="title">lfu_create</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfu_put</span><span class="params">(LFU *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lfu_get</span><span class="params">(LFU *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfu_destroy</span><span class="params">(LFU *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfu_print</span><span class="params">(LFU *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">lfu_insert_node</span><span class="params">(LFU *, Node *)</span></span>;</span><br><span class="line"><span class="function">Node *<span class="title">lfu_remove_node</span><span class="params">(LFU *, Node *)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>对于LFU，笔者这里核心实现了下面两个方法：</strong></p>
<ol>
<li>  <strong>lru_remove_node：移除任意一个节点</strong></li>
<li>  <strong>lfu_insert_node：将一个节点插入到双向链表中的合适位置（大于node节点cnt数的第一个节点的左边）</strong></li>
</ol>
<img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913225834248.png" alt="LFU双向链表-插入一个节点" style="zoom:50%;" />



<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LFU *<span class="title">lfu_create</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    LFU *tmp = (LFU *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LFU));</span><br><span class="line">    tmp-&gt;head = (Node *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line">    tmp-&gt;tail = (Node *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line">    tmp-&gt;head-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;tail-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;cap = size;</span><br><span class="line">    tmp-&gt;len = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;head-&gt;next = tmp-&gt;tail;</span><br><span class="line">    tmp-&gt;tail-&gt;prev = tmp-&gt;head;</span><br><span class="line">    tmp-&gt;cache = map&lt;<span class="keyword">int</span>, Node *&gt;();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfu_destroy</span><span class="params">(LFU *lfu)</span> </span>&#123;</span><br><span class="line">    lfu-&gt;cache.<span class="built_in">clear</span>();</span><br><span class="line">    Node *tmp = lfu-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">        Node *t = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个节点插入到双向链表中的合适位置(大于node节点cnt数的第一个节点的左边)</span></span><br><span class="line"><span class="function">Node *<span class="title">lfu_insert_node</span><span class="params">(LFU *lfu, Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lfu-&gt;cap &lt;= lfu-&gt;len) &#123;</span><br><span class="line">        Node *t = <span class="built_in">lfu_remove_node</span>(lfu, lfu-&gt;head-&gt;next);</span><br><span class="line">        <span class="built_in">free</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    Node *tmp = lfu-&gt;head;</span><br><span class="line">    <span class="keyword">while</span> (tmp != lfu-&gt;tail &amp;&amp; tmp-&gt;cnt &lt;= node-&gt;cnt) tmp = tmp-&gt;next;</span><br><span class="line"></span><br><span class="line">    tmp-&gt;prev-&gt;next = node;</span><br><span class="line">    node-&gt;prev = tmp-&gt;prev;</span><br><span class="line">    node-&gt;next = tmp;</span><br><span class="line">    tmp-&gt;prev = node;</span><br><span class="line"></span><br><span class="line">    lfu-&gt;cache[node-&gt;k] = node;</span><br><span class="line">    lfu-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个节点从原有双向链表上移除，返回这个移除的节点</span></span><br><span class="line"><span class="function">Node *<span class="title">lfu_remove_node</span><span class="params">(LFU *lfu, Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lfu-&gt;len &lt;= <span class="number">0</span> || !node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    lfu-&gt;len--;</span><br><span class="line">    lfu-&gt;cache.<span class="built_in">erase</span>(node-&gt;k);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfu_put</span><span class="params">(LFU *lfu, <span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lfu) <span class="keyword">return</span>;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, Node *&gt; mp = lfu-&gt;cache;</span><br><span class="line">    <span class="keyword">if</span> (mp.<span class="built_in">find</span>(key) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        Node *tmp = mp[key];</span><br><span class="line">        tmp = <span class="built_in">lfu_remove_node</span>(lfu, tmp);</span><br><span class="line">        tmp-&gt;cnt++;</span><br><span class="line">        tmp-&gt;v = val;</span><br><span class="line">        <span class="built_in">lfu_insert_node</span>(lfu, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *tmp = (Node *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line">        tmp-&gt;cnt = <span class="number">1</span>;</span><br><span class="line">        tmp-&gt;k = key;</span><br><span class="line">        tmp-&gt;v = val;</span><br><span class="line">        <span class="built_in">lfu_insert_node</span>(lfu, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lfu_get</span><span class="params">(LFU *lfu, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lfu) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lfu-&gt;cache.<span class="built_in">find</span>(key) != lfu-&gt;cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        Node *tmp = lfu-&gt;cache[key];</span><br><span class="line">        tmp = <span class="built_in">lfu_remove_node</span>(lfu, tmp);</span><br><span class="line">        tmp-&gt;cnt++;</span><br><span class="line">        tmp = <span class="built_in">lfu_insert_node</span>(lfu, tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfu_print</span><span class="params">(LFU *lfu)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------\n&quot;</span>;</span><br><span class="line">    Node *tmp = lfu-&gt;head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (tmp != lfu-&gt;tail) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; tmp-&gt;k &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; tmp-&gt;v &lt;&lt; <span class="string">&quot;) -&gt; cnt: &quot;</span> &lt;&lt; tmp-&gt;cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="验证LFU效果"><a href="#验证LFU效果" class="headerlink" title="验证LFU效果"></a>验证LFU效果</h3><p>定义一个main函数同时调用LFU即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LFU *lfu = <span class="built_in">lfu_create</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lfu_put</span>(lfu, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">lfu_print</span>(lfu);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lfu_put</span>(lfu, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">lfu_print</span>(lfu);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">lfu_get</span>(lfu, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">lfu_print</span>(lfu);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lfu_put</span>(lfu, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">lfu_print</span>(lfu);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">lfu_get</span>(lfu, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">lfu_print</span>(lfu);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">lfu_get</span>(lfu, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">lfu_print</span>(lfu);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lfu_put</span>(lfu, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">lfu_print</span>(lfu);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">lfu_get</span>(lfu, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">lfu_print</span>(lfu);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lfu_destroy</span>(lfu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到双向链表内部是根据cnt从小到大排列缓存k-v的：</p>
<img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913225229277.png" alt="LFU效果" style="zoom: 67%;" />



<h2 id="LFU的其他实现方式"><a href="#LFU的其他实现方式" class="headerlink" title="LFU的其他实现方式"></a>LFU的其他实现方式</h2><p>上面实现LFU使用的是map+双向链表的方法，每次淘汰双向链表头部的元素。</p>
<p>除此之外，还可以使用优先队列priority_queue来代替双向链表，因为优先队列内部维护了一个二叉队，如果按照cnt元素从小到大维护一个优先队列，每次pop队首元素也是可以的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-09T09:52:59.000Z" title="2021/9/9 下午5:52:59">2021-09-09</time>发表</span><span class="level-item"><time dateTime="2021-09-09T10:57:20.329Z" title="2021/9/9 下午6:57:20">2021-09-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span><span class="level-item">20 分钟读完 (大约3064个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/09/09/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-2-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApthread-pool/">unix网络编程-2-实现一个pthread_pool</a></h1><div class="content"><p>这次使用C语言，设计一个基于pthread的线程池吧。</p>
<p>想要设计线程池的原因有三个：</p>
<ol>
<li>  想要重新锻炼下C语言的编码能力</li>
<li>  面试经常出现一些线程池的内容，笔者比较反感这些八股文，所以就简单实现一个线程池好了</li>
<li>  线程池所谓服务端必不可少的组件，后面继续学习unix网络编程的时候会用到</li>
</ol>
<p>在开始之前按照惯例介绍一下环境：</p>
<ul>
<li>  macOS 10.15</li>
<li>  gcc工具链（clang）</li>
<li>  gdb调试（brew install gdb）</li>
</ul>
<h2 id="开始设计线程池结构"><a href="#开始设计线程池结构" class="headerlink" title="开始设计线程池结构"></a>开始设计线程池结构</h2><p>笔者参考了Java提供的ThreadPoolExecutor类，也就是线程池类，当然也顺便研究了一下源码，发现略有点复杂，我们这次就实现一个Fixed_Pool，也就是核心线程就等于工作线程数好了。</p>
<p>给出线程池pthread_pool的设计图如下：</p>
<img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909182922612.png" alt="pthread_pool设计" style="zoom:50%;" />

<p>单看图的话还是比较简单的，因为这次写一个固定核心线程数的线程池，比如上图，核心线程数为2，等待队列长度为4，某一时刻，这个线程池能负载的最大任务数为6个（2个正在执行，4个等待执行）</p>
<p>如果等待队列已满，此时再尝试提交任务的话就会返回-1，代表提交失败。</p>
<h2 id="定义核心结构体"><a href="#定义核心结构体" class="headerlink" title="定义核心结构体"></a>定义核心结构体</h2><p>从上面的设计图中看到，需要设计的结构有两个：pthread_pool类型和task任务类型</p>
<p>于是给出下面的设计：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pthread_pool</span></span><br><span class="line"><span class="comment"> * 实现一个基于pthread的Fixed线程池，创建初期就初始化n个线程，n个核心线程全部活跃</span></span><br><span class="line"><span class="comment"> * 线程池真正可以负载的任务数量t = 线程数量w + 等待队列长度n</span></span><br><span class="line"><span class="comment"> * 例如：一个3核心线程，队列长度为2的线程池，其负载能力最大为5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">pthread_pool_state</span> &#123;</span></span><br><span class="line">    RUNNING,   <span class="comment">// 运行</span></span><br><span class="line">    TERMINATED <span class="comment">// 结束</span></span><br><span class="line">&#125; pthread_pool_state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">pthread_pool_task_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *); <span class="comment">// 任务函数</span></span><br><span class="line">    <span class="keyword">void</span> *args;            <span class="comment">// 函数参数</span></span><br><span class="line">&#125; <span class="keyword">pthread_pool_task_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread_pool_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex; <span class="comment">// 内部锁</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;   <span class="comment">// 同步条件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> *threads; <span class="comment">// 线程数组</span></span><br><span class="line">    <span class="keyword">int</span> thread_count;   <span class="comment">// 核心线程数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_pool_task_t</span> *task_queue; <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">int</span> task_head;                   <span class="comment">// 头部指针</span></span><br><span class="line">    <span class="keyword">int</span> task_tail;                   <span class="comment">// 尾部指针</span></span><br><span class="line">    <span class="keyword">int</span> task_queue_size;             <span class="comment">// 最大任务队列长度</span></span><br><span class="line">    <span class="keyword">int</span> task_count;                  <span class="comment">// 当前任务数量</span></span><br><span class="line">    pthread_pool_state pool_state;   <span class="comment">// 线程池状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPP struct pthread_pool_t</span></span><br></pre></td></tr></table></figure>

<p>笔者这里额外加了一个state枚举类型来表示线程池当前的执行状态，当然执行状态很简单只有两种：运行中和终止</p>
<h2 id="设计线程池的关键函数"><a href="#设计线程池的关键函数" class="headerlink" title="设计线程池的关键函数"></a>设计线程池的关键函数</h2><p>对于一个线程池，不难想到有几个核心方法需要设计并且实现：创建、提交任务、核心线程工作函数、关闭、释放资源</p>
<p>下面给出笔者设计的这5个函数的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_pool_worker</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_pool_release</span><span class="params">(SPP *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_pool_submit</span><span class="params">(SPP *, <span class="keyword">void</span> *(*)(<span class="keyword">void</span> *), <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_pool_shutdown</span><span class="params">(SPP *)</span></span>;</span><br><span class="line"><span class="function">SPP *<span class="title">pthread_pool_create</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="pthread-pool-create函数实现"><a href="#pthread-pool-create函数实现" class="headerlink" title="pthread_pool_create函数实现"></a>pthread_pool_create函数实现</h3><p>创建一个线程池，即定义一个结构体对象，然后分配相应的内存，同时初始化其中的一些参数即可。</p>
<p>因为是核心线程全部运行，所以创建的时候就初始化核心线程数量的工作线程数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个线程池</span></span><br><span class="line"><span class="function">SPP *<span class="title">pthread_pool_create</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> queue_size)</span> </span>&#123;</span><br><span class="line">    assert(thread_count &gt; <span class="number">0</span> &amp;&amp; queue_size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    SPP *tmp = (SPP *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SPP));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;tmp-&gt;mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pthread_cond_init(&amp;tmp-&gt;cond, <span class="literal">NULL</span>) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> tmp_attr;</span><br><span class="line">    <span class="keyword">if</span> (pthread_attr_init(&amp;tmp_attr) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tmp-&gt;thread_count = thread_count;</span><br><span class="line">    tmp-&gt;threads = (<span class="keyword">pthread_t</span> *)<span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">    tmp-&gt;task_queue_size = queue_size;</span><br><span class="line">    tmp-&gt;task_queue = (<span class="keyword">pthread_pool_task_t</span> *)<span class="built_in">malloc</span>(queue_size * <span class="keyword">sizeof</span>(<span class="keyword">pthread_pool_task_t</span>));</span><br><span class="line">    tmp-&gt;task_head = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;task_tail = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;task_count = <span class="number">0</span>;</span><br><span class="line">    tmp-&gt;pool_state = RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程退出时自动回收资源</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;tmp_attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp-&gt;thread_count; ++i) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;创建%d号线程\n&quot;, i);</span></span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create(&amp;(tmp-&gt;threads[i]), &amp;tmp_attr, pthread_pool_worker, tmp);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        pthread_pool_shutdown(tmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="pthread-pool-worker函数实现"><a href="#pthread-pool-worker函数实现" class="headerlink" title="pthread_pool_worker函数实现"></a>pthread_pool_worker函数实现</h3><p>worker函数是线程池每个内置工作线程不断运行的一个方法，在这个方法里线程不断检查任务队列是否有任务需要完成，否则就阻塞等待被唤醒；如何唤醒呢？当提交任务的时候会通过condition唤醒阻塞的线程检查任务队列执行。</p>
<ul>
<li><p>  当确认存在任务需要完成的时候，线程会获取这个任务并且将任务队列头指针后移一位，然后执行这个任务</p>
</li>
<li><p>  如果线程池需要关闭，那么worker函数会break退出，同时回收工作线程资源</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池内置线程处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_pool_worker</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    SPP *pool = (SPP *)args;</span><br><span class="line">    <span class="keyword">pthread_pool_task_t</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;mutex));</span><br><span class="line">        <span class="comment">// 尝试循环获取任务，没有任务就阻塞等待</span></span><br><span class="line">        <span class="keyword">while</span> (pool-&gt;task_count == <span class="number">0</span> &amp;&amp; pool-&gt;pool_state == RUNNING) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;(pool-&gt;cond), &amp;(pool-&gt;mutex));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;pool_state != RUNNING) <span class="keyword">break</span>;</span><br><span class="line">        task.func = pool-&gt;task_queue[pool-&gt;task_head].func;</span><br><span class="line">        task.args = pool-&gt;task_queue[pool-&gt;task_head].args;</span><br><span class="line"></span><br><span class="line">        pool-&gt;task_head++;</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;task_head == pool-&gt;task_queue_size) pool-&gt;task_head = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;task_count--;</span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        task.func(task.args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="pthread-pool-submit函数实现"><a href="#pthread-pool-submit函数实现" class="headerlink" title="pthread_pool_submit函数实现"></a>pthread_pool_submit函数实现</h3><p>向线程池中提交一个任务，然后尝试唤醒阻塞等待的工作线程，移动tail指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 提交一个任务</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_pool_submit</span><span class="params">(SPP *pool, <span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pool || !func) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;mutex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 判断下一个tail位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = pool-&gt;task_tail + <span class="number">1</span>;</span><br><span class="line">        pos = ((pos == pool-&gt;task_queue_size) ? <span class="number">0</span> : pos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;task_queue_size == pool-&gt;task_count) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;pool_state != RUNNING) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        pool-&gt;task_queue[pool-&gt;task_tail].func = func;</span><br><span class="line">        pool-&gt;task_queue[pool-&gt;task_tail].args = args;</span><br><span class="line"></span><br><span class="line">        pool-&gt;task_tail = pos;</span><br><span class="line">        pool-&gt;task_count++;</span><br><span class="line">        pthread_cond_signal(&amp;(pool-&gt;cond));</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剩余函数实现"><a href="#剩余函数实现" class="headerlink" title="剩余函数实现"></a>剩余函数实现</h3><p>关闭和回收线程池资源，C语言的动态内存操作需要小心一点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_pool_shutdown</span><span class="params">(SPP *pool)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;mutex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pool-&gt;pool_state == RUNNING) &#123;</span><br><span class="line">        pool-&gt;pool_state = TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有可能等待的核心线程</span></span><br><span class="line">    pthread_cond_signal(&amp;(pool-&gt;cond));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试取消所有正在运行的线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;thread_count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;尝试取消线程%d...\n&quot;</span>, i);</span><br><span class="line">        pthread_cancel(pool-&gt;threads[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class="line">    pthread_pool_release(pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放线程池资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_pool_release</span><span class="params">(SPP *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;threads) <span class="built_in">free</span>(pool-&gt;threads);</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue) <span class="built_in">free</span>(pool-&gt;task_queue);</span><br><span class="line">    pthread_mutex_destroy(&amp;(pool-&gt;mutex));</span><br><span class="line">    pthread_cond_destroy(&amp;(pool-&gt;cond));</span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭线程池的方法这里是非阻塞的，调用了之后不一定会结束所有正在工作的线程。</p>
<p>关闭线程池的时候尝试取消正在运行的线程，如果运行线程内部是个死循环并且没有监听取消事件，会造成程序无法结束。</p>
<h2 id="验证线程池功能"><a href="#验证线程池功能" class="headerlink" title="验证线程池功能"></a>验证线程池功能</h2><p>简单写一个程序验证线程池的功能</p>
<p>首先给出上面线程池必须依赖的头文件内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _COMMONS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _COMMONS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后简单写一个main.c来测试线程池的功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">task</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> t = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Thread-%d]: %s&quot;</span>, pthread_self(), ctime(&amp;t));</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个线程池</span></span><br><span class="line">    SPP *pool = pthread_pool_create(<span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = pthread_pool_submit(pool, task, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 号任务提交失败...\n&quot;</span>, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 号任务提交成功!!!\n&quot;</span>, i);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功提交任务数量：%d\n&quot;</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程阻塞不退出</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试关闭线程池</span></span><br><span class="line">    pthread_pool_shutdown(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个核心数量为3，等待队列大小为50的线程池，所以可以得到同一时刻可以提交的最大任务数量是53个任务，其余的任务会提交失败。</p>
<p>因为核心数量是3，所以同一时刻运行会有3个不同线程执行任务，并且打出当前时间，这里直接给出一部分的输出吧：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cc -g pool.c main.c -lpthread</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./a.out</span></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">1 号任务提交成功!!!</span><br><span class="line">2 号任务提交成功!!!</span><br><span class="line">3 号任务提交成功!!!</span><br><span class="line">4 号任务提交成功!!!</span><br><span class="line">5 号任务提交成功!!!</span><br><span class="line">6 号任务提交成功!!!</span><br><span class="line">7 号任务提交成功!!!</span><br><span class="line">8 号任务提交成功!!!</span><br><span class="line">9 号任务提交成功!!!</span><br><span class="line">10 号任务提交成功!!!</span><br><span class="line">11 号任务提交成功!!!</span><br><span class="line">12 号任务提交成功!!!</span><br><span class="line">13 号任务提交成功!!!</span><br><span class="line">14 号任务提交成功!!!</span><br><span class="line">15 号任务提交成功!!!</span><br><span class="line">16 号任务提交成功!!!</span><br><span class="line">17 号任务提交成功!!!</span><br><span class="line">18 号任务提交成功!!!</span><br><span class="line">19 号任务提交成功!!!</span><br><span class="line">20 号任务提交成功!!!</span><br><span class="line">21 号任务提交成功!!!</span><br><span class="line">22 号任务提交成功!!!</span><br><span class="line">23 号任务提交成功!!!</span><br><span class="line">24 号任务提交成功!!!</span><br><span class="line">25 号任务提交成功!!!</span><br><span class="line">26 号任务提交成功!!!</span><br><span class="line">27 号任务提交成功!!!</span><br><span class="line">28 号任务提交成功!!!</span><br><span class="line">29 号任务提交成功!!!</span><br><span class="line">30 号任务提交成功!!!</span><br><span class="line">31 号任务提交成功!!!</span><br><span class="line">32 号任务提交成功!!!</span><br><span class="line">33 号任务提交成功!!!</span><br><span class="line">34 号任务提交成功!!!</span><br><span class="line">35 号任务提交成功!!!</span><br><span class="line">36 号任务提交成功!!!</span><br><span class="line">37 号任务提交成功!!!</span><br><span class="line">38 号任务提交成功!!!</span><br><span class="line">39 号任务提交成功!!!</span><br><span class="line">40 号任务提交成功!!!</span><br><span class="line">41 号任务提交成功!!!</span><br><span class="line">42 号任务提交成功!!!</span><br><span class="line">43 号任务提交成功!!!</span><br><span class="line">44 号任务提交成功!!!</span><br><span class="line">45 号任务提交成功!!!</span><br><span class="line">46 号任务提交成功!!!</span><br><span class="line">47 号任务提交成功!!!</span><br><span class="line">48 号任务提交成功!!!</span><br><span class="line">49 号任务提交成功!!!</span><br><span class="line">50 号任务提交成功!!!</span><br><span class="line">51 号任务提交成功!!!</span><br><span class="line">52 号任务提交成功!!!</span><br><span class="line">53 号任务提交成功!!!</span><br><span class="line">54 号任务提交失败...</span><br><span class="line">55 号任务提交失败...</span><br><span class="line">56 号任务提交失败...</span><br><span class="line">57 号任务提交失败...</span><br><span class="line">58 号任务提交失败...</span><br><span class="line">59 号任务提交失败...</span><br><span class="line">60 号任务提交失败...</span><br><span class="line">61 号任务提交失败...</span><br><span class="line">62 号任务提交失败...</span><br><span class="line">63 号任务提交失败...</span><br><span class="line">64 号任务提交失败...</span><br><span class="line">65 号任务提交失败...</span><br><span class="line">66 号任务提交失败...</span><br><span class="line">67 号任务提交失败...</span><br><span class="line">68 号任务提交失败...</span><br><span class="line">69 号任务提交失败...</span><br><span class="line">70 号任务提交失败...</span><br><span class="line">71 号任务提交失败...</span><br><span class="line">72 号任务提交失败...</span><br><span class="line">73 号任务提交失败...</span><br><span class="line">74 号任务提交失败...</span><br><span class="line">75 号任务提交失败...</span><br><span class="line">76 号任务提交失败...</span><br><span class="line">77 号任务提交失败...</span><br><span class="line">78 号任务提交失败...</span><br><span class="line">79 号任务提交失败...</span><br><span class="line">80 号任务提交失败...</span><br><span class="line">81 号任务提交失败...</span><br><span class="line">82 号任务提交失败...</span><br><span class="line">83 号任务提交失败...</span><br><span class="line">84 号任务提交失败...</span><br><span class="line">85 号任务提交失败...</span><br><span class="line">86 号任务提交失败...</span><br><span class="line">87 号任务提交失败...</span><br><span class="line">88 号任务提交失败...</span><br><span class="line">89 号任务提交失败...</span><br><span class="line">90 号任务提交失败...</span><br><span class="line">91 号任务提交失败...</span><br><span class="line">92 号任务提交失败...</span><br><span class="line">93 号任务提交失败...</span><br><span class="line">94 号任务提交失败...</span><br><span class="line">95 号任务提交失败...</span><br><span class="line">96 号任务提交失败...</span><br><span class="line">97 号任务提交失败...</span><br><span class="line">98 号任务提交失败...</span><br><span class="line">99 号任务提交失败...</span><br><span class="line">100 号任务提交失败...</span><br><span class="line">成功提交任务数量：53</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:40:49 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:40:49 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:40:49 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:40:50 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:40:50 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:40:50 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:40:51 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:40:51 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:40:51 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:40:52 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:40:52 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:40:52 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:40:53 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:40:53 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:40:53 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:40:54 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:40:54 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:40:54 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:40:55 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:40:55 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:40:55 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:40:56 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:40:56 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:40:56 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:40:57 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:40:57 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:40:57 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:40:58 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:40:58 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:40:58 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:41:00 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:41:00 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:41:00 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:41:01 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:41:01 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:41:01 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:41:02 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:41:02 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:41:02 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:41:03 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:41:03 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:41:03 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:41:04 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:41:04 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:41:04 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:41:05 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:41:05 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:41:05 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:41:06 2021</span><br><span class="line">[Thread-27713536]: Thu Sep  9 18:41:06 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:41:06 2021</span><br><span class="line">[Thread-28786688]: Thu Sep  9 18:41:07 2021</span><br><span class="line">[Thread-28250112]: Thu Sep  9 18:41:07 2021</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ^C</span></span><br></pre></td></tr></table></figure>



<h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><p>vscode配置的调试debug只能调试单文件，这次调试就是用的gdb来调试的</p>
<p>编译的时候加入-g参数生成debug信息，然后gdb a.out就可以调试程序了</p>
<p>对于多线程的调试，gdb也是很方便的，具体参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html">https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html</a></p>
<img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909184526181.png" alt="使用gdb调试" style="zoom:50%;" />

<img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909184608119.png" alt="gdb显示所有线程" style="zoom:50%;" />
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-08T12:29:54.000Z" title="2021/9/8 下午8:29:54">2021-09-08</time>发表</span><span class="level-item"><time dateTime="2021-09-08T12:48:46.234Z" title="2021/9/8 下午8:48:46">2021-09-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">5 分钟读完 (大约741个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/09/08/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84shutdown%E5%92%8CshutdownNow%E6%96%B9%E6%B3%95/">线程池的shutdown和shutdownNow方法</a></h1><div class="content"><p>使用Java的线程池ThreadPoolExecutor类时候发现了两个不同的关闭线程池的方法：shutdown和shutdownNow方法，具体这两个方法有啥区别呢？这次一起来探讨一下：</p>
<h2 id="线程池的状态runState"><a href="#线程池的状态runState" class="headerlink" title="线程池的状态runState"></a>线程池的状态runState</h2><p>阅读ThreadPoolExecutor类的源码不难看出，线程池实现类中定义了线程池具有几个状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The runState provides the main lifecycle control, taking on values:</span></span><br><span class="line"><span class="comment">*   RUNNING:  Accept new tasks and process queued tasks</span></span><br><span class="line"><span class="comment">*   SHUTDOWN: Don&#x27;t accept new tasks, but process queued tasks</span></span><br><span class="line"><span class="comment">*   STOP:     Don&#x27;t accept new tasks, don&#x27;t process queued tasks,</span></span><br><span class="line"><span class="comment">*             and interrupt in-progress tasks</span></span><br><span class="line"><span class="comment">*   TIDYING:  All tasks have terminated, workerCount is zero,</span></span><br><span class="line"><span class="comment">*             the thread transitioning to state TIDYING</span></span><br><span class="line"><span class="comment">*             will run the terminated() hook method</span></span><br><span class="line"><span class="comment">*   TERMINATED: terminated() has completed</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>同时，类源码中也解释了上面五个状态之间是如何切换的，这里笔者整理成一个状态转换图好了：</p>
<p><img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210908203537430.png" alt="线程池状态转换图"></p>
<p>从上面的图中可以看到，这次要讨论的shutdown和shutdownNow方法是和SHUTDOWN、STOP状态相关联的</p>
<h2 id="shutdown-方法"><a href="#shutdown-方法" class="headerlink" title="shutdown()方法"></a>shutdown()方法</h2><p>线程池内部主要存在两个部分：保存工作线程的HashSet集合Workers，保存待执行任务的BlockingQueue集合taskQueue，线程池释放的时候，主要需要处理并且释放的资源内容也就是这两块。</p>
<p>对于shutdown方法，这个方法返回值为void。</p>
<ul>
<li>  执行了shutdown方法之后，线程池的状态切换为SHUTDOWN状态</li>
<li>  对于taskQueue，线程池不再接受新的任务提交请求，但是会等待队列中已存在的任务全部执行完成</li>
</ul>
<h2 id="shutdownNow-方法"><a href="#shutdownNow-方法" class="headerlink" title="shutdownNow()方法"></a>shutdownNow()方法</h2><p>对于shutdownNow方法，这个方法返回List&lt;Runnable&gt;，尚未开始执行的任务列表</p>
<ul>
<li>  执行了shutdownNow方法之后，线程池的状态切换为STOP状态</li>
<li>  对于taskQueue，线程池不再接受新的任务提交请求，并且尝试interrupt中断开始执行的任务（不一定中断成功），队列中尚未执行的任务全部以列表形式返回</li>
</ul>
<h2 id="何时进入TERMINATED状态"><a href="#何时进入TERMINATED状态" class="headerlink" title="何时进入TERMINATED状态"></a>何时进入TERMINATED状态</h2><p>从线程池的状态转换图中可以看到，从调用了shutdown或者shutdownNow方法到最终线程池结束工作的TERMINATED状态仍然有一段距离，因为可能执行的任务还需要执行完成。</p>
<p>一般来说，因为调用shutdown或shutdownNow方法是立即返回的，并不会阻塞等待所有任务完成，所以线程池提供了额外的awaitTermination函数来实现阻塞等待所有工作完成，并且到达了TERMINATED状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure>

<p>方法内部借助一个condition变量实现了阻塞等待，并且在所有任务结束时唤醒返回true</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-06T09:48:09.000Z" title="2021/9/6 下午5:48:09">2021-09-06</time>发表</span><span class="level-item"><time dateTime="2021-09-06T09:54:36.555Z" title="2021/9/6 下午5:54:36">2021-09-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span><span class="level-item">4 分钟读完 (大约565个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/09/06/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1-%E7%AE%80%E5%8D%95%E6%97%B6%E9%97%B4%E6%9C%8D%E5%8A%A1%E5%99%A8/">unix网络编程-1-简单时间服务器</a></h1><div class="content"><p>根据书上内容，编写一个简单的获取时间的客户端、服务器如下：</p>
<h2 id="time-client"><a href="#time-client" class="headerlink" title="time client"></a>time client</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;commons.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * time check client</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fd socket描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">// 目标服务器socket包装体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">svraddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;usage: client &lt;ip&gt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = common_socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化目标服务器信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;svraddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(svraddr));</span><br><span class="line">    svraddr.sin_family = AF_INET;</span><br><span class="line">    svraddr.sin_port = htons(<span class="number">13</span>); <span class="comment">// 时间服务器，端口13</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将ip地址串转换为in_addr(整数)，然后赋值给svraddr</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;svraddr.sin_addr) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_pton error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试连接服务器</span></span><br><span class="line">    common_connect(fd, (SA *)&amp;svraddr, <span class="keyword">sizeof</span>(svraddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取服务器发送的信息，写入buf中并且打印</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> recvbuf[MAXLINE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = common_read(fd, recvbuf, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        recvbuf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, recvbuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="time-server"><a href="#time-server" class="headerlink" title="time server"></a>time server</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;commons.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTEN_NUMBER 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 监听socket描述符，连接socket描述符</span></span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">svraddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> wrtbuf[MAXLINE];</span><br><span class="line">    <span class="keyword">time_t</span> ticks;</span><br><span class="line"></span><br><span class="line">    listenfd = common_socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;svraddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(svraddr));</span><br><span class="line">    svraddr.sin_family = AF_INET;</span><br><span class="line">    svraddr.sin_port = htons(<span class="number">13</span>);</span><br><span class="line">    svraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定监听socket和服务器socket信息</span></span><br><span class="line">    common_bind(listenfd, (SA *)&amp;svraddr, <span class="keyword">sizeof</span>(svraddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多同时监听1024个连接</span></span><br><span class="line">    common_listen(listenfd, LISTEN_NUMBER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端连接socket</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        connfd = accept(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(wrtbuf, <span class="keyword">sizeof</span>(wrtbuf), <span class="string">&quot;%.24s\r\n&quot;</span>, ctime(&amp;ticks));</span><br><span class="line">        common_write(connfd, wrtbuf, <span class="built_in">strlen</span>(wrtbuf));</span><br><span class="line">        common_close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="commons-h-公共头文件"><a href="#commons-h-公共头文件" class="headerlink" title="commons.h 公共头文件"></a>commons.h 公共头文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公共头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">SA</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">common_socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> sock_type, <span class="keyword">int</span> protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = (socket(family, sock_type, protocol))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;common_socket error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接socket</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">common_connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> SA *svraddr, <span class="keyword">socklen_t</span> socklen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, svraddr, socklen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;common_connect error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定socket</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">common_bind</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">const</span> SA *svraddr, <span class="keyword">socklen_t</span> socklen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, svraddr, socklen) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;common_bind error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">common_listen</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> conn_number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, conn_number) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;common_listen error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">common_read</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *recvbuf, <span class="keyword">size_t</span> recvlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span> ((len = read(sockfd, recvbuf, recvlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;common_read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入socket</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">common_write</span><span class="params">(<span class="keyword">int</span> connfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (write(connfd, buf, nbytes) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;common_write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭socket</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">common_close</span><span class="params">(<span class="keyword">int</span> connfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (close(connfd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;common_close error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210906175210048.png" alt="运行截图" style="zoom:50%;" />
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-27T12:47:35.000Z" title="2021/8/27 下午8:47:35">2021-08-27</time>发表</span><span class="level-item"><time dateTime="2021-08-27T15:42:39.893Z" title="2021/8/27 下午11:42:39">2021-08-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="level-item">21 分钟读完 (大约3119个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/08/27/DNS%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">DNS协议相关问题整理</a></h1><div class="content"><h1 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h1><p>域名解析协议DNS (Domain Name System)将域名和 IP 地址相互映射，方便人使用便于记忆的域名而不是 IP 地址。</p>
<p>将域名映射成 IP 地址称为<strong>正向解析</strong>，将 IP 地址映射成域名称为<strong>反向解析</strong></p>
<h2 id="DNS使用到的协议和端口"><a href="#DNS使用到的协议和端口" class="headerlink" title="DNS使用到的协议和端口"></a>DNS使用到的协议和端口</h2><p>DNS同时占用UDP和TCP的53号端口；DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； </p>
<p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区域中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区域传送（zone transfer）。 </p>
<p><strong>区域传送</strong>时使用TCP：</p>
<ol>
<li>  辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 </li>
<li>  TCP是一种可靠的连接，保证了数据的准确性。 </li>
</ol>
<p><strong>域名解析</strong>时使用UDP： </p>
<p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p>
<h2 id="DNS服务器分类"><a href="#DNS服务器分类" class="headerlink" title="DNS服务器分类"></a>DNS服务器分类</h2><ol>
<li>根域名服务器</li>
<li>顶级域名服务器</li>
<li>权限域名服务器</li>
<li>本地域名服务器</li>
</ol>
<h2 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h2><p>笔者从阿里云截图得到的：</p>
<img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827225505585.png" align="middle" alt="DNS记录类型" style="zoom:50%;" />



<h2 id="DNS协议解析方式"><a href="#DNS协议解析方式" class="headerlink" title="DNS协议解析方式"></a>DNS协议解析方式</h2><ol>
<li><strong>递归查询</strong>：主机向本地域名服务器器的查询</li>
</ol>
<p>如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报⽂(代替主机继续查询)。<br>最终的查询结果有两种，要么找到了 IP 地址，要么返回错误。</p>
<ol start="2">
<li><strong>迭代查询</strong>：本地域名服务器器向根域名服务器器的查询</li>
</ol>
<p>当根域名服务器收到本地域名服务器发出的迭代查询请求报⽂时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个DNS服务器进⾏查询，然后让本地服务器进行后续的查询。</p>
<p>根域名服务器器常是把⾃己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下⼀步应当向哪⼀个权限域名服务器进⾏查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。</p>
<h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><p>1）首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护一张域名与 IP 地址的对应表；</p>
<p>2）若没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>；</p>
<p>3）若仍然没有命中，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是<strong>递归查询</strong>）；</p>
<p>4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong>（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</p>
<ul>
<li>  首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li>
<li>  本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址</li>
<li>  本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>
</ul>
<p>4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p>
<p>5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p>
<p>6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</p>
<p><img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/1460000039039286.png" alt="DNS解析过程"></p>
<h2 id="DNS域名缓存"><a href="#DNS域名缓存" class="headerlink" title="DNS域名缓存"></a>DNS域名缓存</h2><p>为了提高DNS查询效率，并减少因特网上的DNS查询保存数量，在DNS域名服务器中使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p>
<p>计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。</p>
<ol>
<li><strong>浏览器缓存</strong>：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS</li>
<li><strong>操作系统缓存</strong>：操作系统的缓存其实是用户自己配置的 hosts 文件。</li>
</ol>
<h2 id="DNS协议故障原因"><a href="#DNS协议故障原因" class="headerlink" title="DNS协议故障原因"></a>DNS协议故障原因</h2><ul>
<li>DNS服务器自身出现问题</li>
<li>域名受到DNS攻击</li>
<li>DNS解析配置错误，如：域名解析目标IP设置错误</li>
<li>客户机或者服务器本地的hosts文件配置不当</li>
</ul>
<h2 id="常用的DNS协议工具"><a href="#常用的DNS协议工具" class="headerlink" title="常用的DNS协议工具"></a>常用的DNS协议工具</h2><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>nslookup全称是”query Internet name server interactively”，主要用来查询DNS。</p>
<p>mac下自带了这个工具：</p>
<img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827223648429.png" alt="nslookup工具" style="zoom:50%;" />

<h4 id="直接查询域名ip"><a href="#直接查询域名ip" class="headerlink" title="直接查询域名ip"></a>直接查询域名ip</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nslookup</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> google.com</span></span><br><span class="line">Server:		192.168.1.1</span><br><span class="line">Address:	192.168.1.1#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	google.com</span><br><span class="line">Address: 46.82.174.69</span><br></pre></td></tr></table></figure>



<h4 id="连接指定DNS服务器查询域名ip"><a href="#连接指定DNS服务器查询域名ip" class="headerlink" title="连接指定DNS服务器查询域名ip"></a>连接指定DNS服务器查询域名ip</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nslookup</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接到8.8.8.8域名服务器</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> server 8.8.8.8</span></span><br><span class="line">Default server: 8.8.8.8</span><br><span class="line">Address: 8.8.8.8#53</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> google.com</span></span><br><span class="line">Server:		8.8.8.8</span><br><span class="line">Address:	8.8.8.8#53</span><br><span class="line"></span><br><span class="line">Name:	google.com</span><br><span class="line">Address: 59.24.3.174</span><br></pre></td></tr></table></figure>



<h4 id="查看DNS配置信息"><a href="#查看DNS配置信息" class="headerlink" title="查看DNS配置信息"></a>查看DNS配置信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nslookup</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> all</span></span><br><span class="line">Default server: 192.168.1.1</span><br><span class="line">Address: 192.168.1.1#53</span><br><span class="line">Default server: 192.168.0.1</span><br><span class="line">Address: 192.168.0.1#53</span><br><span class="line"></span><br><span class="line">Set options:</span><br><span class="line">  novc			nodebug		nod2</span><br><span class="line">  search		recurse</span><br><span class="line">  timeout = 0		retry = 3	port = 53	ndots = 1</span><br><span class="line">  querytype = A     class = IN</span><br><span class="line">  srchlist =</span><br></pre></td></tr></table></figure>



<p>man nslookup找到的可用的set字段：</p>
<p><strong>IN</strong><br>the Internet class</p>
<p><strong>CH</strong><br>the Chaos class</p>
<p><strong>HS</strong><br>the Hesiod class</p>
<p><strong>ANY</strong><br>wildcard</p>
<p>The class specifies the protocol group of the information.</p>
<p>(Default = IN; abbreviation = cl)</p>
<p><strong>[no]debug</strong><br>Turn on or off the display of the full response packet and any intermediate response packets when searching.</p>
<p>(Default = nodebug; abbreviation = [no]deb)</p>
<p><strong>[no]d2</strong><br>Turn debugging mode on or off. This displays more about what nslookup is doing.</p>
<p>(Default = nod2)</p>
<p><strong>domain=name</strong><br>Sets the search list to name.</p>
<p><strong>[no]search</strong><br>If the lookup request contains at least one period but doesn’t end with a trailing period, append the domain names in the domain<br>search list to the request until an answer is received.</p>
<p>(Default = search)</p>
<p><strong>port=value</strong><br>Change the default TCP/UDP name server port to value.</p>
<p>(Default = 53; abbreviation = po)</p>
<p><strong>querytype=value</strong></p>
<p><strong>type=value</strong><br>Change the type of the information query.</p>
<p>(Default = A; abbreviations = q, ty)</p>
<p><strong>[no]recurse</strong><br>Tell the name server to query other servers if it does not have the information.</p>
<p>(Default = recurse; abbreviation = [no]rec)</p>
<p><strong>ndots=number</strong><br>Set the number of dots (label separators) in a domain that will disable searching. Absolute names always stop searching.</p>
<p><strong>retry=number</strong><br>Set the number of retries to number.</p>
<p><strong>timeout=number</strong><br>Change the initial timeout interval for waiting for a reply to number seconds.</p>
<p><strong>[no]vc</strong><br>Always use a virtual circuit when sending requests to the server.</p>
<p>(Default = novc)</p>
<p><strong>[no]fail</strong><br>Try the next nameserver if a nameserver responds with SERVFAIL or a referral (nofail) or terminate query (fail) on such a<br>response.</p>
<p>(Default = nofail)</p>
<h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>dig工具是用于查询DNS记录的工具，功能比nslookup更加强大，mac下自带了这个工具：</p>
<img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827225040112.png" alt="dig工具" style="zoom:50%;" />



<p>dig有意思的玩法：</p>
<ol>
<li><p>查看某个域名的DNS解析过程</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dig yankaizhang.com +trace</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; yankaizhang.com +trace</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先找到本地域名服务器</span></span><br><span class="line">;; global options: +cmd</span><br><span class="line">.			3153	IN	NS	m.root-servers.net.</span><br><span class="line">.			3153	IN	NS	h.root-servers.net.</span><br><span class="line">.			3153	IN	NS	a.root-servers.net.</span><br><span class="line">.			3153	IN	NS	b.root-servers.net.</span><br><span class="line">.			3153	IN	NS	k.root-servers.net.</span><br><span class="line">.			3153	IN	NS	l.root-servers.net.</span><br><span class="line">.			3153	IN	NS	i.root-servers.net.</span><br><span class="line">.			3153	IN	NS	f.root-servers.net.</span><br><span class="line">.			3153	IN	NS	j.root-servers.net.</span><br><span class="line">.			3153	IN	NS	e.root-servers.net.</span><br><span class="line">.			3153	IN	NS	c.root-servers.net.</span><br><span class="line">.			3153	IN	NS	g.root-servers.net.</span><br><span class="line">.			3153	IN	NS	d.root-servers.net.</span><br><span class="line">;; Received 239 bytes from 192.168.1.1#53(192.168.1.1) in 36 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地域名服务器请求根域名服务器（递归查询）</span></span><br><span class="line">com.			172800	IN	NS	a.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	b.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	c.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	d.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	e.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	f.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	g.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	h.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	i.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	j.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	k.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	l.gtld-servers.net.</span><br><span class="line">com.			172800	IN	NS	m.gtld-servers.net.</span><br><span class="line">com.			86400	IN	DS	30909 8 2 E2D3C916F6DEEAC73294E8268FB5885044A833FC5459588F4A9184CF C41A5766</span><br><span class="line">com.			86400	IN	RRSIG	DS 8 1 86400 20210909050000 20210827040000 26838 . ZLTCRLor3hezbp3CvYQbJCE+4XLPCvLOPlWx+cXru6A0snY2Dkv44JX8 hMpgiueL+Jp1rem/CqAZbLfacGe3cpJJpEkxK5Xob8BKRj4bQE+wH6Et gLy97rFKvCmpf80q29GEgxD5XwRFZoMSqnoNRGMUjPe8yTBoCiGPo+RF UBm0oQ0L2YmNeBEy0KSe+EI4ySUw3BLPSRAu2R/CkpISY2JFmnuG6jSE uM7T9Y5tgFYS7Kvba1NiMsBIiLy3KrijjwczSVCWl+9IKCqaQpCmVqES npK7x9Y0uzlTgNwo8IC1nKzKqvBz7S1UibvTQNxaKK/+Kd8R2lixbO8Y 4ErY0Q==</span><br><span class="line">;; Received 1175 bytes from 193.0.14.129#53(k.root-servers.net) in 47 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根域名服务器通知本地域名服务器去yankaizhang.com.顶级域名服务器（迭代查询）</span></span><br><span class="line">yankaizhang.com.	172800	IN	NS	dns2.hichina.com.</span><br><span class="line">yankaizhang.com.	172800	IN	NS	dns1.hichina.com.</span><br><span class="line">CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN NSEC3 1 1 0 - CK0Q1GIN43N1ARRC9OSM6QPQR81H5M9A  NS SOA RRSIG DNSKEY NSEC3PARAM</span><br><span class="line">CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN RRSIG NSEC3 8 2 86400 20210901042504 20210825031504 39343 com. UjMhvFuOAHV8bbjokUqcBsgJe3Bf2xtTLT2JLkt5wXb40qu6XWzZArOl jTO3BwtnAj7D/KQIqNsBRq0P/Djh8GGgSUhMFCbcel9G6CVESLYq6/E1 SKhGl72pxNtYDHEB5RYnBxsg55rh+gZWZMlhS5h+EjTkz692t8U8lB2C OmIyJpCUsldl7ciWmxMRHwennzbemMT5rhfDSe/SRT4WsQ==</span><br><span class="line">RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN NSEC3 1 1 0 - RTC22ASFHJHTLN9NCAREUK0D41R9BA1B  NS DS RRSIG</span><br><span class="line">RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN RRSIG NSEC3 8 2 86400 20210831051456 20210824040456 39343 com. lmTGKCex0R26RXHbTQbyUcWejz0KIeJtpYhHNs2lyGWV8rY3E9vf+moL Kwqk3Fkk5YU8DEiMLCzkyWxGeqmnlxZVtGqmxDLnkrt83frflR2piT9k uWnJXlocN6XNvrlsEk+eGyzFGRPRMMdnu2JlWx6RYVS1b0PqmJJTLOPL EHqUYaZshDNhE2Bo9JMPtZMDRQoI+/GlTc+4htFDFxT9Iw==</span><br><span class="line">;; Received 951 bytes from 192.41.162.30#53(l.gtld-servers.net) in 281 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询结束，得到记录值（这里是CNAME）</span></span><br><span class="line">yankaizhang.com.	600	IN	CNAME	yankaizhang.com.cdn.dnsv1.com.</span><br><span class="line">;; Received 87 bytes from 106.11.211.64#53(dns2.hichina.com) in 27 ms</span><br></pre></td></tr></table></figure>

</li>
<li><p>查找一个域名的授权DNS服务器</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dig  yankaizhang.com +nssearch</span></span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.24 in 26 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.63 in 27 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.64 in 27 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.23 in 28 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.13 in 31 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.53 in 31 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.54 in 31 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.23 in 31 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.14 in 31 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.14 in 37 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.13 in 37 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.24 in 37 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.123 in 47 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.114 in 48 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.124 in 49 ms.</span><br><span class="line">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.113 in 62 ms</span><br></pre></td></tr></table></figure></li>
<li><p>查看域名的正向解析和反向解析</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dig yankaizhang.com</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dig -x yankaizhang.com</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>host工具也是mac自带的一个DNS查询工具，其功能和输入输出和dig差不多，参数操作方式有所不同</p>
<img src="https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827231223945.png" alt="host工具" style="zoom:50%;" />

<p>个人使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> host -a yankaizhang.com</span></span><br><span class="line"></span><br><span class="line">Trying &quot;yankaizhang.com&quot;</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64983</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;yankaizhang.com.		IN	ANY</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">yankaizhang.com.	600	IN	CNAME	yankaizhang.com.cdn.dnsv1.com.</span><br><span class="line">yankaizhang.com.	3600	IN	NS	dns1.hichina.com.</span><br><span class="line">yankaizhang.com.	3600	IN	NS	dns2.hichina.com.</span><br><span class="line"></span><br><span class="line">Received 119 bytes from 192.168.1.1#53 in 207 ms</span><br></pre></td></tr></table></figure>




<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039039275">https://segmentfault.com/a/1190000039039275</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/549294286/p/5172435.html">https://www.cnblogs.com/549294286/p/5172435.html</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1083201">https://cloud.tencent.com/developer/article/1083201</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/machangwei-8/p/10353216.html">https://www.cnblogs.com/machangwei-8/p/10353216.html</a></p>
</div></article></div></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">听风合笙</a><p class="is-size-7"><span>&copy; 2021 Yankai</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="渝ICP备20009371号-1" href="http://beian.miit.gov.cn/">渝ICP备20009371号-1</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://s9.cnzz.com/z_stat.php?id=1280271894&amp;web_id=1280271894" async></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>