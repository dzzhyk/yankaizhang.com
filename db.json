{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","path":"css/default.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","path":"img/og_image.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","path":"js/column.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/DNS协议相关问题整理.md","hash":"7dbcb7c8863986e57849812b7cf366fe07c09d38","modified":1630078959893},{"_id":"source/_posts/UNIX网络编程-1-简单时间服务器.md","hash":"385e329f0f1fa76fe9fb1685413702c2e90bedc0","modified":1630922076555},{"_id":"source/_posts/unix网络编程-2-实现一个pthread-pool.md","hash":"4d5a6bd96bd1fb7bad90ca5a34e7e7d03cef2f51","modified":1631185040329},{"_id":"source/_posts/双向链表与LRU、LFU的实现.md","hash":"e0ffe1e7fd7b92e26b4f6bfdaa677d0ee77038a4","modified":1631545225520},{"_id":"source/_posts/线程池的shutdown和shutdownNow方法.md","hash":"000339a3d48ca21dc4f3f47529252bd7ae716cb5","modified":1631105326234},{"_id":"source/categories/index.md","hash":"3603092f3ebdf70c1dc1224ac891ce73d3417021","modified":1629954648040},{"_id":"source/tags/index.md","hash":"2bb991e0a267be639cdaf991fc43330903c04ad9","modified":1629954687711},{"_id":"source/.DS_Store","hash":"27aa8fc6a4fd4146edd797dfcbb167a00bbf8664","modified":1630921923289},{"_id":"node_modules/hexo-theme-icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/README.md","hash":"2dd0997639a8cf8a83c69115de30afa858e3da96","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/package.json","hash":"cbdf3ce67da2d65e70be4e7db2f44e05f2ff0af2","modified":1630078569899},{"_id":"node_modules/hexo-theme-icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/fr.yml","hash":"06d5c819d6108a42b28cff7b52e5410d0bed55d1","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/tr.yml","hash":"74e438bb42619666050192d6f3dc39023777eee2","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/layout.jsx","hash":"a5829907b219e95266f7ed5ee6203e60e2273f93","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/article.jsx","hash":"16513ab1745533d0f4cdbdee323339ebab6d02c1","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/head.jsx","hash":"5625c4040a885aaf150f35fe9d07d844d7f94a27","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/article.json","hash":"8d78149f44629d0848921c6fb9c008b03cef3116","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/comment.json","hash":"7d744391a8abee9a2c450b6fdd36a3866a488025","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":499162500000},{"_id":"node_modules/hexo-theme-icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":499162500000},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1631547051745},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1631547051745},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1631547051745},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1631547051745},{"_id":"public/content.json","hash":"4302e049ebd826c861f8861f241d059eb7b737d8","modified":1631547051745},{"_id":"public/manifest.json","hash":"dc3f02209450ba6a2a35b0537bddaf4edb600613","modified":1631547051745},{"_id":"public/categories/index.html","hash":"d90fa1a064fb65c99e8e54f50699d7fd38556e81","modified":1631547051745},{"_id":"public/tags/index.html","hash":"af13221b2bfd34eb3e8403837bb68ec803ea01c3","modified":1631547051745},{"_id":"public/archives/index.html","hash":"d93b4b5285e7e01d0c40b6d725e3c3f3c3371083","modified":1631547051745},{"_id":"public/archives/2021/index.html","hash":"2bbda7af86215fba826218116e833f53b48e0bf8","modified":1631547051745},{"_id":"public/archives/2021/08/index.html","hash":"aae145ad0293254e6888a5e7afc6f412c93a0ee1","modified":1631547051745},{"_id":"public/archives/2021/09/index.html","hash":"7ca06fe1d138b94ec25dd24ae12307b88af17a90","modified":1631547051745},{"_id":"public/categories/Java/index.html","hash":"48d1f796d54c9801b65525d175750ab963a9ceb9","modified":1631547051745},{"_id":"public/tags/Java并发编程/index.html","hash":"aa0342e46be2799d50bef8c433c707b611d70283","modified":1631547051745},{"_id":"public/2021/09/13/双向链表与LRU、LFU的实现/index.html","hash":"a666bd9a86c350a555049c125e78a42a427f82c0","modified":1631547051745},{"_id":"public/2021/09/09/unix网络编程-2-实现一个pthread-pool/index.html","hash":"c587d90b3ec0fa1f1c6bde6158f7b6ce40362ce4","modified":1631547051745},{"_id":"public/2021/09/08/线程池的shutdown和shutdownNow方法/index.html","hash":"7ea356def404c8e0a03b61bf009ec36a5ab1d5da","modified":1631547051745},{"_id":"public/2021/09/06/UNIX网络编程-1-简单时间服务器/index.html","hash":"56a77b63b2b29ed6b673a8d38888cbdf71c0a89a","modified":1631547051745},{"_id":"public/2021/08/27/DNS协议相关问题整理/index.html","hash":"7e78360aae441ef0adf8cac7b3441337b30efa36","modified":1631547051745},{"_id":"public/categories/面试/index.html","hash":"624d9304091c92899c1ee0aa8afd935cc790edfb","modified":1631547051745},{"_id":"public/categories/网络编程/index.html","hash":"a47a10d51103c236a7c84a0828130bff38295bef","modified":1631547051745},{"_id":"public/index.html","hash":"cfc783f686b51bcf3c7ff6c5013cfbab5882a384","modified":1631547051745},{"_id":"public/tags/面试/index.html","hash":"6bbef69a163210dc9181459ba3be9afe9d5408af","modified":1631547051745},{"_id":"public/tags/计算机网络/index.html","hash":"b89f0b00a2f2a00567894bca2b0a940618767d42","modified":1631547051745},{"_id":"public/tags/DNS协议/index.html","hash":"2dba058bc457d26f9f1c27637652363cb291b66e","modified":1631547051745},{"_id":"public/tags/Linux/index.html","hash":"ce5a8214439ee77550973091241262e82c2fd53e","modified":1631547051745},{"_id":"public/tags/网络编程/index.html","hash":"5cab9c0600ef8314a58f5788b46ad85562288321","modified":1631547051745},{"_id":"public/tags/socket/index.html","hash":"0a16985357a742bc9cb3a7b5e5a38f461e3067d8","modified":1631547051745},{"_id":"public/tags/线程池/index.html","hash":"6975de1456ff4e16aec37bb5d951bfde473a9f99","modified":1631547051745},{"_id":"public/tags/pthread/index.html","hash":"41330f5aabe5e747b551766568340faab8932c50","modified":1631547051745},{"_id":"public/tags/数据结构/index.html","hash":"3e609afc4943e8cf4d4786170ff4a40f1d36fe74","modified":1631547051745},{"_id":"public/tags/双向链表/index.html","hash":"2579ed0b546704cff0064b185716816879be6eb6","modified":1631547051745},{"_id":"public/tags/LRU缓存策略/index.html","hash":"745db058ae37d1a020c1bc8a94198d06c3353f7e","modified":1631547051745},{"_id":"public/tags/LFU缓存策略/index.html","hash":"674c356efa18c055100fccc27003bdabb4e037bb","modified":1631547051745},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1631547051745},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1631547051745},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1631547051745},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1631547051745},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1631547051745},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1631547051745},{"_id":"public/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1631547051745},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1631547051745},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1631547051745},{"_id":"public/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1631547051745},{"_id":"public/css/cyberpunk.css","hash":"073797b87e28376604d586c48beb66f6fe9cb504","modified":1631547051745},{"_id":"public/css/default.css","hash":"49786c0fefcaa20821d9853a4a6ca81904322793","modified":1631547051745},{"_id":"public/css/style.css","hash":"49786c0fefcaa20821d9853a4a6ca81904322793","modified":1631547051745}],"Category":[{"name":"面试","_id":"cktiszmib0004azqphxek4xhe"},{"name":"网络编程","_id":"cktiszmie0009azqp0z242w4x"},{"name":"Java","_id":"cktiszmih000fazqp782mbhmj"}],"Data":[],"Page":[{"title":"categories","date":"2021-08-26T05:10:29.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-08-26 13:10:29\ntype: \"categories\"\n---\n","updated":"2021-08-26T05:10:48.040Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cktiszmi40000azqp66lgd6oc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2021-08-26T05:10:33.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-08-26 13:10:33\ntype: \"tags\"\n---\n","updated":"2021-08-26T05:11:27.711Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cktiszmi90002azqpb0l1701h","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"DNS协议相关问题整理","date":"2021-08-27T12:47:35.000Z","_content":"\n# DNS协议\n\n域名解析协议DNS (Domain Name System)将域名和 IP 地址相互映射，方便人使用便于记忆的域名而不是 IP 地址。\n\n将域名映射成 IP 地址称为**正向解析**，将 IP 地址映射成域名称为**反向解析**\n\n\n\n## DNS使用到的协议和端口\n\nDNS同时占用UDP和TCP的53号端口；DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； \n\nDNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区域中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区域传送（zone transfer）。 \n\n\n\n**区域传送**时使用TCP：\n\n1.   辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 \n2.   TCP是一种可靠的连接，保证了数据的准确性。 \n\n**域名解析**时使用UDP： \n\n客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。\n\n\n\n## DNS服务器分类\n\n1. 根域名服务器\n2. 顶级域名服务器\n3. 权限域名服务器\n4. 本地域名服务器\n\n\n\n## DNS记录类型\n\n笔者从阿里云截图得到的：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827225505585.png\" align=\"middle\" alt=\"DNS记录类型\" style=\"zoom:50%;\" />\n\n\n\n## DNS协议解析方式\n\n1. **递归查询**：主机向本地域名服务器器的查询\n\n如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报⽂(代替主机继续查询)。\n最终的查询结果有两种，要么找到了 IP 地址，要么返回错误。\n\n2. **迭代查询**：本地域名服务器器向根域名服务器器的查询\n\n当根域名服务器收到本地域名服务器发出的迭代查询请求报⽂时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个DNS服务器进⾏查询，然后让本地服务器进行后续的查询。\n\n根域名服务器器常是把⾃己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下⼀步应当向哪⼀个权限域名服务器进⾏查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。\n\n\n\n## DNS解析过程\n\n1）首先搜索**浏览器的 DNS 缓存**，缓存中维护一张域名与 IP 地址的对应表；\n\n2）若没有命中，则继续搜索**操作系统的 DNS 缓存**；\n\n3）若仍然没有命中，则操作系统将域名发送至**本地域名服务器**，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是**递归查询**）；\n\n4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行**迭代查询**（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：\n\n-   首先本地域名服务器向**根域名服务器**发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案\n-   本地域名服务器拿到这个**顶级域名服务器**的地址后，就向其发起请求，获取**权限域名服务器**的地址\n-   本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址\n\n4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来\n\n5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来\n\n6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来\n\n![DNS解析过程](https://gitee.com/dzzhyk/MarkdownPics/raw/master/1460000039039286.png)\n\n\n\n## DNS域名缓存\n\n为了提高DNS查询效率，并减少因特网上的DNS查询保存数量，在DNS域名服务器中使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。\n\n计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。\n\n1. **浏览器缓存**：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS\n2. **操作系统缓存**：操作系统的缓存其实是用户自己配置的 hosts 文件。\n\n\n\n## DNS协议故障原因\n\n- DNS服务器自身出现问题\n- 域名受到DNS攻击\n- DNS解析配置错误，如：域名解析目标IP设置错误\n- 客户机或者服务器本地的hosts文件配置不当\n\n\n\n## 常用的DNS协议工具\n\n### nslookup\n\nnslookup全称是\"query Internet name server interactively\"，主要用来查询DNS。\n\nmac下自带了这个工具：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827223648429.png\" alt=\"nslookup工具\" style=\"zoom:50%;\" />\n\n#### 直接查询域名ip\n\n```shell\n$ nslookup\n> google.com\nServer:\t\t192.168.1.1\nAddress:\t192.168.1.1#53\n\nNon-authoritative answer:\nName:\tgoogle.com\nAddress: 46.82.174.69\n```\n\n\n\n#### 连接指定DNS服务器查询域名ip\n\n```shell\n$ nslookup\n# 连接到8.8.8.8域名服务器\n> server 8.8.8.8\nDefault server: 8.8.8.8\nAddress: 8.8.8.8#53\n\n> google.com\nServer:\t\t8.8.8.8\nAddress:\t8.8.8.8#53\n\nName:\tgoogle.com\nAddress: 59.24.3.174\n```\n\n\n\n#### 查看DNS配置信息\n\n```shell\n$ nslookup\n> set all\nDefault server: 192.168.1.1\nAddress: 192.168.1.1#53\nDefault server: 192.168.0.1\nAddress: 192.168.0.1#53\n\nSet options:\n  novc\t\t\tnodebug\t\tnod2\n  search\t\trecurse\n  timeout = 0\t\tretry = 3\tport = 53\tndots = 1\n  querytype = A     class = IN\n  srchlist =\n```\n\n\n\nman nslookup找到的可用的set字段：\n\n**IN**\nthe Internet class\n\n**CH**\nthe Chaos class\n\n**HS**\nthe Hesiod class\n\n**ANY**\nwildcard\n\nThe class specifies the protocol group of the information.\n\n(Default = IN; abbreviation = cl)\n\n**[no]debug**\nTurn on or off the display of the full response packet and any intermediate response packets when searching.\n\n(Default = nodebug; abbreviation = [no]deb)\n\n**[no]d2**\nTurn debugging mode on or off. This displays more about what nslookup is doing.\n\n(Default = nod2)\n\n**domain=name**\nSets the search list to name.\n\n**[no]search**\nIf the lookup request contains at least one period but doesn't end with a trailing period, append the domain names in the domain\nsearch list to the request until an answer is received.\n\n(Default = search)\n\n**port=value**\nChange the default TCP/UDP name server port to value.\n\n(Default = 53; abbreviation = po)\n\n**querytype=value**\n\n**type=value**\nChange the type of the information query.\n\n(Default = A; abbreviations = q, ty)\n\n**[no]recurse**\nTell the name server to query other servers if it does not have the information.\n\n(Default = recurse; abbreviation = [no]rec)\n\n**ndots=number**\nSet the number of dots (label separators) in a domain that will disable searching. Absolute names always stop searching.\n\n**retry=number**\nSet the number of retries to number.\n\n**timeout=number**\nChange the initial timeout interval for waiting for a reply to number seconds.\n\n**[no]vc**\nAlways use a virtual circuit when sending requests to the server.\n\n(Default = novc)\n\n**[no]fail**\nTry the next nameserver if a nameserver responds with SERVFAIL or a referral (nofail) or terminate query (fail) on such a\nresponse.\n\n(Default = nofail)\n\n\n\n### dig\n\ndig工具是用于查询DNS记录的工具，功能比nslookup更加强大，mac下自带了这个工具：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827225040112.png\" alt=\"dig工具\" style=\"zoom:50%;\" />\n\n\n\ndig有意思的玩法：\n\n1.   查看某个域名的DNS解析过程\n\n     ```shell\n     $ dig yankaizhang.com +trace\n     \n     ; <<>> DiG 9.10.6 <<>> yankaizhang.com +trace\n     \n     # 先找到本地域名服务器\n     ;; global options: +cmd\n     .\t\t\t3153\tIN\tNS\tm.root-servers.net.\n     .\t\t\t3153\tIN\tNS\th.root-servers.net.\n     .\t\t\t3153\tIN\tNS\ta.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tb.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tk.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tl.root-servers.net.\n     .\t\t\t3153\tIN\tNS\ti.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tf.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tj.root-servers.net.\n     .\t\t\t3153\tIN\tNS\te.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tc.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tg.root-servers.net.\n     .\t\t\t3153\tIN\tNS\td.root-servers.net.\n     ;; Received 239 bytes from 192.168.1.1#53(192.168.1.1) in 36 ms\n     \n     # 本地域名服务器请求根域名服务器（递归查询）\n     com.\t\t\t172800\tIN\tNS\ta.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tb.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tc.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\td.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\te.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tf.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tg.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\th.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\ti.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tj.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tk.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tl.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tm.gtld-servers.net.\n     com.\t\t\t86400\tIN\tDS\t30909 8 2 E2D3C916F6DEEAC73294E8268FB5885044A833FC5459588F4A9184CF C41A5766\n     com.\t\t\t86400\tIN\tRRSIG\tDS 8 1 86400 20210909050000 20210827040000 26838 . ZLTCRLor3hezbp3CvYQbJCE+4XLPCvLOPlWx+cXru6A0snY2Dkv44JX8 hMpgiueL+Jp1rem/CqAZbLfacGe3cpJJpEkxK5Xob8BKRj4bQE+wH6Et gLy97rFKvCmpf80q29GEgxD5XwRFZoMSqnoNRGMUjPe8yTBoCiGPo+RF UBm0oQ0L2YmNeBEy0KSe+EI4ySUw3BLPSRAu2R/CkpISY2JFmnuG6jSE uM7T9Y5tgFYS7Kvba1NiMsBIiLy3KrijjwczSVCWl+9IKCqaQpCmVqES npK7x9Y0uzlTgNwo8IC1nKzKqvBz7S1UibvTQNxaKK/+Kd8R2lixbO8Y 4ErY0Q==\n     ;; Received 1175 bytes from 193.0.14.129#53(k.root-servers.net) in 47 ms\n     \n     # 根域名服务器通知本地域名服务器去yankaizhang.com.顶级域名服务器（迭代查询）\n     yankaizhang.com.\t172800\tIN\tNS\tdns2.hichina.com.\n     yankaizhang.com.\t172800\tIN\tNS\tdns1.hichina.com.\n     CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN NSEC3 1 1 0 - CK0Q1GIN43N1ARRC9OSM6QPQR81H5M9A  NS SOA RRSIG DNSKEY NSEC3PARAM\n     CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN RRSIG NSEC3 8 2 86400 20210901042504 20210825031504 39343 com. UjMhvFuOAHV8bbjokUqcBsgJe3Bf2xtTLT2JLkt5wXb40qu6XWzZArOl jTO3BwtnAj7D/KQIqNsBRq0P/Djh8GGgSUhMFCbcel9G6CVESLYq6/E1 SKhGl72pxNtYDHEB5RYnBxsg55rh+gZWZMlhS5h+EjTkz692t8U8lB2C OmIyJpCUsldl7ciWmxMRHwennzbemMT5rhfDSe/SRT4WsQ==\n     RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN NSEC3 1 1 0 - RTC22ASFHJHTLN9NCAREUK0D41R9BA1B  NS DS RRSIG\n     RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN RRSIG NSEC3 8 2 86400 20210831051456 20210824040456 39343 com. lmTGKCex0R26RXHbTQbyUcWejz0KIeJtpYhHNs2lyGWV8rY3E9vf+moL Kwqk3Fkk5YU8DEiMLCzkyWxGeqmnlxZVtGqmxDLnkrt83frflR2piT9k uWnJXlocN6XNvrlsEk+eGyzFGRPRMMdnu2JlWx6RYVS1b0PqmJJTLOPL EHqUYaZshDNhE2Bo9JMPtZMDRQoI+/GlTc+4htFDFxT9Iw==\n     ;; Received 951 bytes from 192.41.162.30#53(l.gtld-servers.net) in 281 ms\n     \n     # 查询结束，得到记录值（这里是CNAME）\n     yankaizhang.com.\t600\tIN\tCNAME\tyankaizhang.com.cdn.dnsv1.com.\n     ;; Received 87 bytes from 106.11.211.64#53(dns2.hichina.com) in 27 ms\n     ```\n\n     \n\n2.   查找一个域名的授权DNS服务器\n\n     ```shell\n     $ dig  yankaizhang.com +nssearch\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.24 in 26 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.63 in 27 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.64 in 27 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.23 in 28 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.13 in 31 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.53 in 31 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.54 in 31 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.23 in 31 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.14 in 31 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.14 in 37 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.13 in 37 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.24 in 37 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.123 in 47 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.114 in 48 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.124 in 49 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.113 in 62 ms\n     ```\n\n3.   查看域名的正向解析和反向解析\n\n     ```shell\n     $ dig yankaizhang.com\n     $ dig -x yankaizhang.com\n     ```\n\n\n\n### host\n\nhost工具也是mac自带的一个DNS查询工具，其功能和输入输出和dig差不多，参数操作方式有所不同\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827231223945.png\" alt=\"host工具\" style=\"zoom:50%;\" />\n\n个人使用：\n\n```shell\n$ host -a yankaizhang.com\n\nTrying \"yankaizhang.com\"\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 64983\n;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0\n\n;; QUESTION SECTION:\n;yankaizhang.com.\t\tIN\tANY\n\n;; ANSWER SECTION:\nyankaizhang.com.\t600\tIN\tCNAME\tyankaizhang.com.cdn.dnsv1.com.\nyankaizhang.com.\t3600\tIN\tNS\tdns1.hichina.com.\nyankaizhang.com.\t3600\tIN\tNS\tdns2.hichina.com.\n\nReceived 119 bytes from 192.168.1.1#53 in 207 ms\n```\n\n\n\n\n## 参考\n[https://segmentfault.com/a/1190000039039275](https://segmentfault.com/a/1190000039039275)\n\n[https://www.cnblogs.com/549294286/p/5172435.html](https://www.cnblogs.com/549294286/p/5172435.html)\n\n[https://cloud.tencent.com/developer/article/1083201](https://cloud.tencent.com/developer/article/1083201)\n\n[https://www.cnblogs.com/machangwei-8/p/10353216.html](https://www.cnblogs.com/machangwei-8/p/10353216.html)\n","source":"_posts/DNS协议相关问题整理.md","raw":"---\ntitle: DNS协议相关问题整理\ndate: 2021-08-27 20:47:35\ncategories:\n- 面试\ntags:\n- 面试\n- 计算机网络\n- DNS协议\n---\n\n# DNS协议\n\n域名解析协议DNS (Domain Name System)将域名和 IP 地址相互映射，方便人使用便于记忆的域名而不是 IP 地址。\n\n将域名映射成 IP 地址称为**正向解析**，将 IP 地址映射成域名称为**反向解析**\n\n\n\n## DNS使用到的协议和端口\n\nDNS同时占用UDP和TCP的53号端口；DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； \n\nDNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区域中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区域传送（zone transfer）。 \n\n\n\n**区域传送**时使用TCP：\n\n1.   辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 \n2.   TCP是一种可靠的连接，保证了数据的准确性。 \n\n**域名解析**时使用UDP： \n\n客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。\n\n\n\n## DNS服务器分类\n\n1. 根域名服务器\n2. 顶级域名服务器\n3. 权限域名服务器\n4. 本地域名服务器\n\n\n\n## DNS记录类型\n\n笔者从阿里云截图得到的：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827225505585.png\" align=\"middle\" alt=\"DNS记录类型\" style=\"zoom:50%;\" />\n\n\n\n## DNS协议解析方式\n\n1. **递归查询**：主机向本地域名服务器器的查询\n\n如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报⽂(代替主机继续查询)。\n最终的查询结果有两种，要么找到了 IP 地址，要么返回错误。\n\n2. **迭代查询**：本地域名服务器器向根域名服务器器的查询\n\n当根域名服务器收到本地域名服务器发出的迭代查询请求报⽂时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个DNS服务器进⾏查询，然后让本地服务器进行后续的查询。\n\n根域名服务器器常是把⾃己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下⼀步应当向哪⼀个权限域名服务器进⾏查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。\n\n\n\n## DNS解析过程\n\n1）首先搜索**浏览器的 DNS 缓存**，缓存中维护一张域名与 IP 地址的对应表；\n\n2）若没有命中，则继续搜索**操作系统的 DNS 缓存**；\n\n3）若仍然没有命中，则操作系统将域名发送至**本地域名服务器**，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是**递归查询**）；\n\n4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行**迭代查询**（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：\n\n-   首先本地域名服务器向**根域名服务器**发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案\n-   本地域名服务器拿到这个**顶级域名服务器**的地址后，就向其发起请求，获取**权限域名服务器**的地址\n-   本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址\n\n4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来\n\n5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来\n\n6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来\n\n![DNS解析过程](https://gitee.com/dzzhyk/MarkdownPics/raw/master/1460000039039286.png)\n\n\n\n## DNS域名缓存\n\n为了提高DNS查询效率，并减少因特网上的DNS查询保存数量，在DNS域名服务器中使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。\n\n计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。\n\n1. **浏览器缓存**：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS\n2. **操作系统缓存**：操作系统的缓存其实是用户自己配置的 hosts 文件。\n\n\n\n## DNS协议故障原因\n\n- DNS服务器自身出现问题\n- 域名受到DNS攻击\n- DNS解析配置错误，如：域名解析目标IP设置错误\n- 客户机或者服务器本地的hosts文件配置不当\n\n\n\n## 常用的DNS协议工具\n\n### nslookup\n\nnslookup全称是\"query Internet name server interactively\"，主要用来查询DNS。\n\nmac下自带了这个工具：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827223648429.png\" alt=\"nslookup工具\" style=\"zoom:50%;\" />\n\n#### 直接查询域名ip\n\n```shell\n$ nslookup\n> google.com\nServer:\t\t192.168.1.1\nAddress:\t192.168.1.1#53\n\nNon-authoritative answer:\nName:\tgoogle.com\nAddress: 46.82.174.69\n```\n\n\n\n#### 连接指定DNS服务器查询域名ip\n\n```shell\n$ nslookup\n# 连接到8.8.8.8域名服务器\n> server 8.8.8.8\nDefault server: 8.8.8.8\nAddress: 8.8.8.8#53\n\n> google.com\nServer:\t\t8.8.8.8\nAddress:\t8.8.8.8#53\n\nName:\tgoogle.com\nAddress: 59.24.3.174\n```\n\n\n\n#### 查看DNS配置信息\n\n```shell\n$ nslookup\n> set all\nDefault server: 192.168.1.1\nAddress: 192.168.1.1#53\nDefault server: 192.168.0.1\nAddress: 192.168.0.1#53\n\nSet options:\n  novc\t\t\tnodebug\t\tnod2\n  search\t\trecurse\n  timeout = 0\t\tretry = 3\tport = 53\tndots = 1\n  querytype = A     class = IN\n  srchlist =\n```\n\n\n\nman nslookup找到的可用的set字段：\n\n**IN**\nthe Internet class\n\n**CH**\nthe Chaos class\n\n**HS**\nthe Hesiod class\n\n**ANY**\nwildcard\n\nThe class specifies the protocol group of the information.\n\n(Default = IN; abbreviation = cl)\n\n**[no]debug**\nTurn on or off the display of the full response packet and any intermediate response packets when searching.\n\n(Default = nodebug; abbreviation = [no]deb)\n\n**[no]d2**\nTurn debugging mode on or off. This displays more about what nslookup is doing.\n\n(Default = nod2)\n\n**domain=name**\nSets the search list to name.\n\n**[no]search**\nIf the lookup request contains at least one period but doesn't end with a trailing period, append the domain names in the domain\nsearch list to the request until an answer is received.\n\n(Default = search)\n\n**port=value**\nChange the default TCP/UDP name server port to value.\n\n(Default = 53; abbreviation = po)\n\n**querytype=value**\n\n**type=value**\nChange the type of the information query.\n\n(Default = A; abbreviations = q, ty)\n\n**[no]recurse**\nTell the name server to query other servers if it does not have the information.\n\n(Default = recurse; abbreviation = [no]rec)\n\n**ndots=number**\nSet the number of dots (label separators) in a domain that will disable searching. Absolute names always stop searching.\n\n**retry=number**\nSet the number of retries to number.\n\n**timeout=number**\nChange the initial timeout interval for waiting for a reply to number seconds.\n\n**[no]vc**\nAlways use a virtual circuit when sending requests to the server.\n\n(Default = novc)\n\n**[no]fail**\nTry the next nameserver if a nameserver responds with SERVFAIL or a referral (nofail) or terminate query (fail) on such a\nresponse.\n\n(Default = nofail)\n\n\n\n### dig\n\ndig工具是用于查询DNS记录的工具，功能比nslookup更加强大，mac下自带了这个工具：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827225040112.png\" alt=\"dig工具\" style=\"zoom:50%;\" />\n\n\n\ndig有意思的玩法：\n\n1.   查看某个域名的DNS解析过程\n\n     ```shell\n     $ dig yankaizhang.com +trace\n     \n     ; <<>> DiG 9.10.6 <<>> yankaizhang.com +trace\n     \n     # 先找到本地域名服务器\n     ;; global options: +cmd\n     .\t\t\t3153\tIN\tNS\tm.root-servers.net.\n     .\t\t\t3153\tIN\tNS\th.root-servers.net.\n     .\t\t\t3153\tIN\tNS\ta.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tb.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tk.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tl.root-servers.net.\n     .\t\t\t3153\tIN\tNS\ti.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tf.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tj.root-servers.net.\n     .\t\t\t3153\tIN\tNS\te.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tc.root-servers.net.\n     .\t\t\t3153\tIN\tNS\tg.root-servers.net.\n     .\t\t\t3153\tIN\tNS\td.root-servers.net.\n     ;; Received 239 bytes from 192.168.1.1#53(192.168.1.1) in 36 ms\n     \n     # 本地域名服务器请求根域名服务器（递归查询）\n     com.\t\t\t172800\tIN\tNS\ta.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tb.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tc.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\td.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\te.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tf.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tg.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\th.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\ti.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tj.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tk.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tl.gtld-servers.net.\n     com.\t\t\t172800\tIN\tNS\tm.gtld-servers.net.\n     com.\t\t\t86400\tIN\tDS\t30909 8 2 E2D3C916F6DEEAC73294E8268FB5885044A833FC5459588F4A9184CF C41A5766\n     com.\t\t\t86400\tIN\tRRSIG\tDS 8 1 86400 20210909050000 20210827040000 26838 . ZLTCRLor3hezbp3CvYQbJCE+4XLPCvLOPlWx+cXru6A0snY2Dkv44JX8 hMpgiueL+Jp1rem/CqAZbLfacGe3cpJJpEkxK5Xob8BKRj4bQE+wH6Et gLy97rFKvCmpf80q29GEgxD5XwRFZoMSqnoNRGMUjPe8yTBoCiGPo+RF UBm0oQ0L2YmNeBEy0KSe+EI4ySUw3BLPSRAu2R/CkpISY2JFmnuG6jSE uM7T9Y5tgFYS7Kvba1NiMsBIiLy3KrijjwczSVCWl+9IKCqaQpCmVqES npK7x9Y0uzlTgNwo8IC1nKzKqvBz7S1UibvTQNxaKK/+Kd8R2lixbO8Y 4ErY0Q==\n     ;; Received 1175 bytes from 193.0.14.129#53(k.root-servers.net) in 47 ms\n     \n     # 根域名服务器通知本地域名服务器去yankaizhang.com.顶级域名服务器（迭代查询）\n     yankaizhang.com.\t172800\tIN\tNS\tdns2.hichina.com.\n     yankaizhang.com.\t172800\tIN\tNS\tdns1.hichina.com.\n     CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN NSEC3 1 1 0 - CK0Q1GIN43N1ARRC9OSM6QPQR81H5M9A  NS SOA RRSIG DNSKEY NSEC3PARAM\n     CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN RRSIG NSEC3 8 2 86400 20210901042504 20210825031504 39343 com. UjMhvFuOAHV8bbjokUqcBsgJe3Bf2xtTLT2JLkt5wXb40qu6XWzZArOl jTO3BwtnAj7D/KQIqNsBRq0P/Djh8GGgSUhMFCbcel9G6CVESLYq6/E1 SKhGl72pxNtYDHEB5RYnBxsg55rh+gZWZMlhS5h+EjTkz692t8U8lB2C OmIyJpCUsldl7ciWmxMRHwennzbemMT5rhfDSe/SRT4WsQ==\n     RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN NSEC3 1 1 0 - RTC22ASFHJHTLN9NCAREUK0D41R9BA1B  NS DS RRSIG\n     RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN RRSIG NSEC3 8 2 86400 20210831051456 20210824040456 39343 com. lmTGKCex0R26RXHbTQbyUcWejz0KIeJtpYhHNs2lyGWV8rY3E9vf+moL Kwqk3Fkk5YU8DEiMLCzkyWxGeqmnlxZVtGqmxDLnkrt83frflR2piT9k uWnJXlocN6XNvrlsEk+eGyzFGRPRMMdnu2JlWx6RYVS1b0PqmJJTLOPL EHqUYaZshDNhE2Bo9JMPtZMDRQoI+/GlTc+4htFDFxT9Iw==\n     ;; Received 951 bytes from 192.41.162.30#53(l.gtld-servers.net) in 281 ms\n     \n     # 查询结束，得到记录值（这里是CNAME）\n     yankaizhang.com.\t600\tIN\tCNAME\tyankaizhang.com.cdn.dnsv1.com.\n     ;; Received 87 bytes from 106.11.211.64#53(dns2.hichina.com) in 27 ms\n     ```\n\n     \n\n2.   查找一个域名的授权DNS服务器\n\n     ```shell\n     $ dig  yankaizhang.com +nssearch\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.24 in 26 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.63 in 27 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.64 in 27 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.23 in 28 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.13 in 31 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.53 in 31 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.54 in 31 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.23 in 31 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.14 in 31 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.14 in 37 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.13 in 37 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.24 in 37 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.123 in 47 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.114 in 48 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.124 in 49 ms.\n     SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.113 in 62 ms\n     ```\n\n3.   查看域名的正向解析和反向解析\n\n     ```shell\n     $ dig yankaizhang.com\n     $ dig -x yankaizhang.com\n     ```\n\n\n\n### host\n\nhost工具也是mac自带的一个DNS查询工具，其功能和输入输出和dig差不多，参数操作方式有所不同\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827231223945.png\" alt=\"host工具\" style=\"zoom:50%;\" />\n\n个人使用：\n\n```shell\n$ host -a yankaizhang.com\n\nTrying \"yankaizhang.com\"\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 64983\n;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0\n\n;; QUESTION SECTION:\n;yankaizhang.com.\t\tIN\tANY\n\n;; ANSWER SECTION:\nyankaizhang.com.\t600\tIN\tCNAME\tyankaizhang.com.cdn.dnsv1.com.\nyankaizhang.com.\t3600\tIN\tNS\tdns1.hichina.com.\nyankaizhang.com.\t3600\tIN\tNS\tdns2.hichina.com.\n\nReceived 119 bytes from 192.168.1.1#53 in 207 ms\n```\n\n\n\n\n## 参考\n[https://segmentfault.com/a/1190000039039275](https://segmentfault.com/a/1190000039039275)\n\n[https://www.cnblogs.com/549294286/p/5172435.html](https://www.cnblogs.com/549294286/p/5172435.html)\n\n[https://cloud.tencent.com/developer/article/1083201](https://cloud.tencent.com/developer/article/1083201)\n\n[https://www.cnblogs.com/machangwei-8/p/10353216.html](https://www.cnblogs.com/machangwei-8/p/10353216.html)\n","slug":"DNS协议相关问题整理","published":1,"updated":"2021-08-27T15:42:39.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktiszmi60001azqph1o6ci47","content":"<h1 id=\"DNS协议\"><a href=\"#DNS协议\" class=\"headerlink\" title=\"DNS协议\"></a>DNS协议</h1><p>域名解析协议DNS (Domain Name System)将域名和 IP 地址相互映射，方便人使用便于记忆的域名而不是 IP 地址。</p>\n<p>将域名映射成 IP 地址称为<strong>正向解析</strong>，将 IP 地址映射成域名称为<strong>反向解析</strong></p>\n<h2 id=\"DNS使用到的协议和端口\"><a href=\"#DNS使用到的协议和端口\" class=\"headerlink\" title=\"DNS使用到的协议和端口\"></a>DNS使用到的协议和端口</h2><p>DNS同时占用UDP和TCP的53号端口；DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； </p>\n<p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区域中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区域传送（zone transfer）。 </p>\n<p><strong>区域传送</strong>时使用TCP：</p>\n<ol>\n<li>  辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 </li>\n<li>  TCP是一种可靠的连接，保证了数据的准确性。 </li>\n</ol>\n<p><strong>域名解析</strong>时使用UDP： </p>\n<p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p>\n<h2 id=\"DNS服务器分类\"><a href=\"#DNS服务器分类\" class=\"headerlink\" title=\"DNS服务器分类\"></a>DNS服务器分类</h2><ol>\n<li>根域名服务器</li>\n<li>顶级域名服务器</li>\n<li>权限域名服务器</li>\n<li>本地域名服务器</li>\n</ol>\n<h2 id=\"DNS记录类型\"><a href=\"#DNS记录类型\" class=\"headerlink\" title=\"DNS记录类型\"></a>DNS记录类型</h2><p>笔者从阿里云截图得到的：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827225505585.png\" align=\"middle\" alt=\"DNS记录类型\" style=\"zoom:50%;\" />\n\n\n\n<h2 id=\"DNS协议解析方式\"><a href=\"#DNS协议解析方式\" class=\"headerlink\" title=\"DNS协议解析方式\"></a>DNS协议解析方式</h2><ol>\n<li><strong>递归查询</strong>：主机向本地域名服务器器的查询</li>\n</ol>\n<p>如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报⽂(代替主机继续查询)。<br>最终的查询结果有两种，要么找到了 IP 地址，要么返回错误。</p>\n<ol start=\"2\">\n<li><strong>迭代查询</strong>：本地域名服务器器向根域名服务器器的查询</li>\n</ol>\n<p>当根域名服务器收到本地域名服务器发出的迭代查询请求报⽂时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个DNS服务器进⾏查询，然后让本地服务器进行后续的查询。</p>\n<p>根域名服务器器常是把⾃己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下⼀步应当向哪⼀个权限域名服务器进⾏查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。</p>\n<h2 id=\"DNS解析过程\"><a href=\"#DNS解析过程\" class=\"headerlink\" title=\"DNS解析过程\"></a>DNS解析过程</h2><p>1）首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护一张域名与 IP 地址的对应表；</p>\n<p>2）若没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>；</p>\n<p>3）若仍然没有命中，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是<strong>递归查询</strong>）；</p>\n<p>4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong>（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</p>\n<ul>\n<li>  首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li>\n<li>  本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址</li>\n<li>  本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>\n</ul>\n<p>4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p>\n<p>5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p>\n<p>6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</p>\n<p><img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/1460000039039286.png\" alt=\"DNS解析过程\"></p>\n<h2 id=\"DNS域名缓存\"><a href=\"#DNS域名缓存\" class=\"headerlink\" title=\"DNS域名缓存\"></a>DNS域名缓存</h2><p>为了提高DNS查询效率，并减少因特网上的DNS查询保存数量，在DNS域名服务器中使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p>\n<p>计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。</p>\n<ol>\n<li><strong>浏览器缓存</strong>：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS</li>\n<li><strong>操作系统缓存</strong>：操作系统的缓存其实是用户自己配置的 hosts 文件。</li>\n</ol>\n<h2 id=\"DNS协议故障原因\"><a href=\"#DNS协议故障原因\" class=\"headerlink\" title=\"DNS协议故障原因\"></a>DNS协议故障原因</h2><ul>\n<li>DNS服务器自身出现问题</li>\n<li>域名受到DNS攻击</li>\n<li>DNS解析配置错误，如：域名解析目标IP设置错误</li>\n<li>客户机或者服务器本地的hosts文件配置不当</li>\n</ul>\n<h2 id=\"常用的DNS协议工具\"><a href=\"#常用的DNS协议工具\" class=\"headerlink\" title=\"常用的DNS协议工具\"></a>常用的DNS协议工具</h2><h3 id=\"nslookup\"><a href=\"#nslookup\" class=\"headerlink\" title=\"nslookup\"></a>nslookup</h3><p>nslookup全称是”query Internet name server interactively”，主要用来查询DNS。</p>\n<p>mac下自带了这个工具：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827223648429.png\" alt=\"nslookup工具\" style=\"zoom:50%;\" />\n\n<h4 id=\"直接查询域名ip\"><a href=\"#直接查询域名ip\" class=\"headerlink\" title=\"直接查询域名ip\"></a>直接查询域名ip</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nslookup</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> google.com</span></span><br><span class=\"line\">Server:\t\t192.168.1.1</span><br><span class=\"line\">Address:\t192.168.1.1#53</span><br><span class=\"line\"></span><br><span class=\"line\">Non-authoritative answer:</span><br><span class=\"line\">Name:\tgoogle.com</span><br><span class=\"line\">Address: 46.82.174.69</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"连接指定DNS服务器查询域名ip\"><a href=\"#连接指定DNS服务器查询域名ip\" class=\"headerlink\" title=\"连接指定DNS服务器查询域名ip\"></a>连接指定DNS服务器查询域名ip</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nslookup</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 连接到8.8.8.8域名服务器</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> server 8.8.8.8</span></span><br><span class=\"line\">Default server: 8.8.8.8</span><br><span class=\"line\">Address: 8.8.8.8#53</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> google.com</span></span><br><span class=\"line\">Server:\t\t8.8.8.8</span><br><span class=\"line\">Address:\t8.8.8.8#53</span><br><span class=\"line\"></span><br><span class=\"line\">Name:\tgoogle.com</span><br><span class=\"line\">Address: 59.24.3.174</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"查看DNS配置信息\"><a href=\"#查看DNS配置信息\" class=\"headerlink\" title=\"查看DNS配置信息\"></a>查看DNS配置信息</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nslookup</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">set</span> all</span></span><br><span class=\"line\">Default server: 192.168.1.1</span><br><span class=\"line\">Address: 192.168.1.1#53</span><br><span class=\"line\">Default server: 192.168.0.1</span><br><span class=\"line\">Address: 192.168.0.1#53</span><br><span class=\"line\"></span><br><span class=\"line\">Set options:</span><br><span class=\"line\">  novc\t\t\tnodebug\t\tnod2</span><br><span class=\"line\">  search\t\trecurse</span><br><span class=\"line\">  timeout = 0\t\tretry = 3\tport = 53\tndots = 1</span><br><span class=\"line\">  querytype = A     class = IN</span><br><span class=\"line\">  srchlist =</span><br></pre></td></tr></table></figure>\n\n\n\n<p>man nslookup找到的可用的set字段：</p>\n<p><strong>IN</strong><br>the Internet class</p>\n<p><strong>CH</strong><br>the Chaos class</p>\n<p><strong>HS</strong><br>the Hesiod class</p>\n<p><strong>ANY</strong><br>wildcard</p>\n<p>The class specifies the protocol group of the information.</p>\n<p>(Default = IN; abbreviation = cl)</p>\n<p><strong>[no]debug</strong><br>Turn on or off the display of the full response packet and any intermediate response packets when searching.</p>\n<p>(Default = nodebug; abbreviation = [no]deb)</p>\n<p><strong>[no]d2</strong><br>Turn debugging mode on or off. This displays more about what nslookup is doing.</p>\n<p>(Default = nod2)</p>\n<p><strong>domain=name</strong><br>Sets the search list to name.</p>\n<p><strong>[no]search</strong><br>If the lookup request contains at least one period but doesn’t end with a trailing period, append the domain names in the domain<br>search list to the request until an answer is received.</p>\n<p>(Default = search)</p>\n<p><strong>port=value</strong><br>Change the default TCP/UDP name server port to value.</p>\n<p>(Default = 53; abbreviation = po)</p>\n<p><strong>querytype=value</strong></p>\n<p><strong>type=value</strong><br>Change the type of the information query.</p>\n<p>(Default = A; abbreviations = q, ty)</p>\n<p><strong>[no]recurse</strong><br>Tell the name server to query other servers if it does not have the information.</p>\n<p>(Default = recurse; abbreviation = [no]rec)</p>\n<p><strong>ndots=number</strong><br>Set the number of dots (label separators) in a domain that will disable searching. Absolute names always stop searching.</p>\n<p><strong>retry=number</strong><br>Set the number of retries to number.</p>\n<p><strong>timeout=number</strong><br>Change the initial timeout interval for waiting for a reply to number seconds.</p>\n<p><strong>[no]vc</strong><br>Always use a virtual circuit when sending requests to the server.</p>\n<p>(Default = novc)</p>\n<p><strong>[no]fail</strong><br>Try the next nameserver if a nameserver responds with SERVFAIL or a referral (nofail) or terminate query (fail) on such a<br>response.</p>\n<p>(Default = nofail)</p>\n<h3 id=\"dig\"><a href=\"#dig\" class=\"headerlink\" title=\"dig\"></a>dig</h3><p>dig工具是用于查询DNS记录的工具，功能比nslookup更加强大，mac下自带了这个工具：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827225040112.png\" alt=\"dig工具\" style=\"zoom:50%;\" />\n\n\n\n<p>dig有意思的玩法：</p>\n<ol>\n<li><p>查看某个域名的DNS解析过程</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dig yankaizhang.com +trace</span></span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; yankaizhang.com +trace</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先找到本地域名服务器</span></span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tm.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\th.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\ta.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tb.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tk.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tl.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\ti.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tf.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tj.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\te.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tc.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tg.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\td.root-servers.net.</span><br><span class=\"line\">;; Received 239 bytes from 192.168.1.1#53(192.168.1.1) in 36 ms</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 本地域名服务器请求根域名服务器（递归查询）</span></span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\ta.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tb.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tc.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\td.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\te.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tf.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tg.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\th.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\ti.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tj.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tk.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tl.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tm.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t86400\tIN\tDS\t30909 8 2 E2D3C916F6DEEAC73294E8268FB5885044A833FC5459588F4A9184CF C41A5766</span><br><span class=\"line\">com.\t\t\t86400\tIN\tRRSIG\tDS 8 1 86400 20210909050000 20210827040000 26838 . ZLTCRLor3hezbp3CvYQbJCE+4XLPCvLOPlWx+cXru6A0snY2Dkv44JX8 hMpgiueL+Jp1rem/CqAZbLfacGe3cpJJpEkxK5Xob8BKRj4bQE+wH6Et gLy97rFKvCmpf80q29GEgxD5XwRFZoMSqnoNRGMUjPe8yTBoCiGPo+RF UBm0oQ0L2YmNeBEy0KSe+EI4ySUw3BLPSRAu2R/CkpISY2JFmnuG6jSE uM7T9Y5tgFYS7Kvba1NiMsBIiLy3KrijjwczSVCWl+9IKCqaQpCmVqES npK7x9Y0uzlTgNwo8IC1nKzKqvBz7S1UibvTQNxaKK/+Kd8R2lixbO8Y 4ErY0Q==</span><br><span class=\"line\">;; Received 1175 bytes from 193.0.14.129#53(k.root-servers.net) in 47 ms</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 根域名服务器通知本地域名服务器去yankaizhang.com.顶级域名服务器（迭代查询）</span></span><br><span class=\"line\">yankaizhang.com.\t172800\tIN\tNS\tdns2.hichina.com.</span><br><span class=\"line\">yankaizhang.com.\t172800\tIN\tNS\tdns1.hichina.com.</span><br><span class=\"line\">CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN NSEC3 1 1 0 - CK0Q1GIN43N1ARRC9OSM6QPQR81H5M9A  NS SOA RRSIG DNSKEY NSEC3PARAM</span><br><span class=\"line\">CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN RRSIG NSEC3 8 2 86400 20210901042504 20210825031504 39343 com. UjMhvFuOAHV8bbjokUqcBsgJe3Bf2xtTLT2JLkt5wXb40qu6XWzZArOl jTO3BwtnAj7D/KQIqNsBRq0P/Djh8GGgSUhMFCbcel9G6CVESLYq6/E1 SKhGl72pxNtYDHEB5RYnBxsg55rh+gZWZMlhS5h+EjTkz692t8U8lB2C OmIyJpCUsldl7ciWmxMRHwennzbemMT5rhfDSe/SRT4WsQ==</span><br><span class=\"line\">RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN NSEC3 1 1 0 - RTC22ASFHJHTLN9NCAREUK0D41R9BA1B  NS DS RRSIG</span><br><span class=\"line\">RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN RRSIG NSEC3 8 2 86400 20210831051456 20210824040456 39343 com. lmTGKCex0R26RXHbTQbyUcWejz0KIeJtpYhHNs2lyGWV8rY3E9vf+moL Kwqk3Fkk5YU8DEiMLCzkyWxGeqmnlxZVtGqmxDLnkrt83frflR2piT9k uWnJXlocN6XNvrlsEk+eGyzFGRPRMMdnu2JlWx6RYVS1b0PqmJJTLOPL EHqUYaZshDNhE2Bo9JMPtZMDRQoI+/GlTc+4htFDFxT9Iw==</span><br><span class=\"line\">;; Received 951 bytes from 192.41.162.30#53(l.gtld-servers.net) in 281 ms</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询结束，得到记录值（这里是CNAME）</span></span><br><span class=\"line\">yankaizhang.com.\t600\tIN\tCNAME\tyankaizhang.com.cdn.dnsv1.com.</span><br><span class=\"line\">;; Received 87 bytes from 106.11.211.64#53(dns2.hichina.com) in 27 ms</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>查找一个域名的授权DNS服务器</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dig  yankaizhang.com +nssearch</span></span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.24 in 26 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.63 in 27 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.64 in 27 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.23 in 28 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.13 in 31 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.53 in 31 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.54 in 31 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.23 in 31 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.14 in 31 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.14 in 37 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.13 in 37 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.24 in 37 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.123 in 47 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.114 in 48 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.124 in 49 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.113 in 62 ms</span><br></pre></td></tr></table></figure></li>\n<li><p>查看域名的正向解析和反向解析</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dig yankaizhang.com</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dig -x yankaizhang.com</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h3><p>host工具也是mac自带的一个DNS查询工具，其功能和输入输出和dig差不多，参数操作方式有所不同</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827231223945.png\" alt=\"host工具\" style=\"zoom:50%;\" />\n\n<p>个人使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> host -a yankaizhang.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">Trying &quot;yankaizhang.com&quot;</span><br><span class=\"line\">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64983</span><br><span class=\"line\">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class=\"line\"></span><br><span class=\"line\">;; QUESTION SECTION:</span><br><span class=\"line\">;yankaizhang.com.\t\tIN\tANY</span><br><span class=\"line\"></span><br><span class=\"line\">;; ANSWER SECTION:</span><br><span class=\"line\">yankaizhang.com.\t600\tIN\tCNAME\tyankaizhang.com.cdn.dnsv1.com.</span><br><span class=\"line\">yankaizhang.com.\t3600\tIN\tNS\tdns1.hichina.com.</span><br><span class=\"line\">yankaizhang.com.\t3600\tIN\tNS\tdns2.hichina.com.</span><br><span class=\"line\"></span><br><span class=\"line\">Received 119 bytes from 192.168.1.1#53 in 207 ms</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://segmentfault.com/a/1190000039039275\">https://segmentfault.com/a/1190000039039275</a></p>\n<p><a href=\"https://www.cnblogs.com/549294286/p/5172435.html\">https://www.cnblogs.com/549294286/p/5172435.html</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1083201\">https://cloud.tencent.com/developer/article/1083201</a></p>\n<p><a href=\"https://www.cnblogs.com/machangwei-8/p/10353216.html\">https://www.cnblogs.com/machangwei-8/p/10353216.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DNS协议\"><a href=\"#DNS协议\" class=\"headerlink\" title=\"DNS协议\"></a>DNS协议</h1><p>域名解析协议DNS (Domain Name System)将域名和 IP 地址相互映射，方便人使用便于记忆的域名而不是 IP 地址。</p>\n<p>将域名映射成 IP 地址称为<strong>正向解析</strong>，将 IP 地址映射成域名称为<strong>反向解析</strong></p>\n<h2 id=\"DNS使用到的协议和端口\"><a href=\"#DNS使用到的协议和端口\" class=\"headerlink\" title=\"DNS使用到的协议和端口\"></a>DNS使用到的协议和端口</h2><p>DNS同时占用UDP和TCP的53号端口；DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； </p>\n<p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区域中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区域传送（zone transfer）。 </p>\n<p><strong>区域传送</strong>时使用TCP：</p>\n<ol>\n<li>  辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 </li>\n<li>  TCP是一种可靠的连接，保证了数据的准确性。 </li>\n</ol>\n<p><strong>域名解析</strong>时使用UDP： </p>\n<p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p>\n<h2 id=\"DNS服务器分类\"><a href=\"#DNS服务器分类\" class=\"headerlink\" title=\"DNS服务器分类\"></a>DNS服务器分类</h2><ol>\n<li>根域名服务器</li>\n<li>顶级域名服务器</li>\n<li>权限域名服务器</li>\n<li>本地域名服务器</li>\n</ol>\n<h2 id=\"DNS记录类型\"><a href=\"#DNS记录类型\" class=\"headerlink\" title=\"DNS记录类型\"></a>DNS记录类型</h2><p>笔者从阿里云截图得到的：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827225505585.png\" align=\"middle\" alt=\"DNS记录类型\" style=\"zoom:50%;\" />\n\n\n\n<h2 id=\"DNS协议解析方式\"><a href=\"#DNS协议解析方式\" class=\"headerlink\" title=\"DNS协议解析方式\"></a>DNS协议解析方式</h2><ol>\n<li><strong>递归查询</strong>：主机向本地域名服务器器的查询</li>\n</ol>\n<p>如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报⽂(代替主机继续查询)。<br>最终的查询结果有两种，要么找到了 IP 地址，要么返回错误。</p>\n<ol start=\"2\">\n<li><strong>迭代查询</strong>：本地域名服务器器向根域名服务器器的查询</li>\n</ol>\n<p>当根域名服务器收到本地域名服务器发出的迭代查询请求报⽂时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个DNS服务器进⾏查询，然后让本地服务器进行后续的查询。</p>\n<p>根域名服务器器常是把⾃己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下⼀步应当向哪⼀个权限域名服务器进⾏查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。</p>\n<h2 id=\"DNS解析过程\"><a href=\"#DNS解析过程\" class=\"headerlink\" title=\"DNS解析过程\"></a>DNS解析过程</h2><p>1）首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护一张域名与 IP 地址的对应表；</p>\n<p>2）若没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>；</p>\n<p>3）若仍然没有命中，则操作系统将域名发送至<strong>本地域名服务器</strong>，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是<strong>递归查询</strong>）；</p>\n<p>4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行<strong>迭代查询</strong>（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：</p>\n<ul>\n<li>  首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案</li>\n<li>  本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址</li>\n<li>  本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>\n</ul>\n<p>4）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p>\n<p>5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p>\n<p>6）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</p>\n<p><img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/1460000039039286.png\" alt=\"DNS解析过程\"></p>\n<h2 id=\"DNS域名缓存\"><a href=\"#DNS域名缓存\" class=\"headerlink\" title=\"DNS域名缓存\"></a>DNS域名缓存</h2><p>为了提高DNS查询效率，并减少因特网上的DNS查询保存数量，在DNS域名服务器中使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p>\n<p>计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存。</p>\n<ol>\n<li><strong>浏览器缓存</strong>：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的 DNS 缓存时间，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS</li>\n<li><strong>操作系统缓存</strong>：操作系统的缓存其实是用户自己配置的 hosts 文件。</li>\n</ol>\n<h2 id=\"DNS协议故障原因\"><a href=\"#DNS协议故障原因\" class=\"headerlink\" title=\"DNS协议故障原因\"></a>DNS协议故障原因</h2><ul>\n<li>DNS服务器自身出现问题</li>\n<li>域名受到DNS攻击</li>\n<li>DNS解析配置错误，如：域名解析目标IP设置错误</li>\n<li>客户机或者服务器本地的hosts文件配置不当</li>\n</ul>\n<h2 id=\"常用的DNS协议工具\"><a href=\"#常用的DNS协议工具\" class=\"headerlink\" title=\"常用的DNS协议工具\"></a>常用的DNS协议工具</h2><h3 id=\"nslookup\"><a href=\"#nslookup\" class=\"headerlink\" title=\"nslookup\"></a>nslookup</h3><p>nslookup全称是”query Internet name server interactively”，主要用来查询DNS。</p>\n<p>mac下自带了这个工具：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827223648429.png\" alt=\"nslookup工具\" style=\"zoom:50%;\" />\n\n<h4 id=\"直接查询域名ip\"><a href=\"#直接查询域名ip\" class=\"headerlink\" title=\"直接查询域名ip\"></a>直接查询域名ip</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nslookup</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> google.com</span></span><br><span class=\"line\">Server:\t\t192.168.1.1</span><br><span class=\"line\">Address:\t192.168.1.1#53</span><br><span class=\"line\"></span><br><span class=\"line\">Non-authoritative answer:</span><br><span class=\"line\">Name:\tgoogle.com</span><br><span class=\"line\">Address: 46.82.174.69</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"连接指定DNS服务器查询域名ip\"><a href=\"#连接指定DNS服务器查询域名ip\" class=\"headerlink\" title=\"连接指定DNS服务器查询域名ip\"></a>连接指定DNS服务器查询域名ip</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nslookup</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 连接到8.8.8.8域名服务器</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> server 8.8.8.8</span></span><br><span class=\"line\">Default server: 8.8.8.8</span><br><span class=\"line\">Address: 8.8.8.8#53</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> google.com</span></span><br><span class=\"line\">Server:\t\t8.8.8.8</span><br><span class=\"line\">Address:\t8.8.8.8#53</span><br><span class=\"line\"></span><br><span class=\"line\">Name:\tgoogle.com</span><br><span class=\"line\">Address: 59.24.3.174</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"查看DNS配置信息\"><a href=\"#查看DNS配置信息\" class=\"headerlink\" title=\"查看DNS配置信息\"></a>查看DNS配置信息</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> nslookup</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">set</span> all</span></span><br><span class=\"line\">Default server: 192.168.1.1</span><br><span class=\"line\">Address: 192.168.1.1#53</span><br><span class=\"line\">Default server: 192.168.0.1</span><br><span class=\"line\">Address: 192.168.0.1#53</span><br><span class=\"line\"></span><br><span class=\"line\">Set options:</span><br><span class=\"line\">  novc\t\t\tnodebug\t\tnod2</span><br><span class=\"line\">  search\t\trecurse</span><br><span class=\"line\">  timeout = 0\t\tretry = 3\tport = 53\tndots = 1</span><br><span class=\"line\">  querytype = A     class = IN</span><br><span class=\"line\">  srchlist =</span><br></pre></td></tr></table></figure>\n\n\n\n<p>man nslookup找到的可用的set字段：</p>\n<p><strong>IN</strong><br>the Internet class</p>\n<p><strong>CH</strong><br>the Chaos class</p>\n<p><strong>HS</strong><br>the Hesiod class</p>\n<p><strong>ANY</strong><br>wildcard</p>\n<p>The class specifies the protocol group of the information.</p>\n<p>(Default = IN; abbreviation = cl)</p>\n<p><strong>[no]debug</strong><br>Turn on or off the display of the full response packet and any intermediate response packets when searching.</p>\n<p>(Default = nodebug; abbreviation = [no]deb)</p>\n<p><strong>[no]d2</strong><br>Turn debugging mode on or off. This displays more about what nslookup is doing.</p>\n<p>(Default = nod2)</p>\n<p><strong>domain=name</strong><br>Sets the search list to name.</p>\n<p><strong>[no]search</strong><br>If the lookup request contains at least one period but doesn’t end with a trailing period, append the domain names in the domain<br>search list to the request until an answer is received.</p>\n<p>(Default = search)</p>\n<p><strong>port=value</strong><br>Change the default TCP/UDP name server port to value.</p>\n<p>(Default = 53; abbreviation = po)</p>\n<p><strong>querytype=value</strong></p>\n<p><strong>type=value</strong><br>Change the type of the information query.</p>\n<p>(Default = A; abbreviations = q, ty)</p>\n<p><strong>[no]recurse</strong><br>Tell the name server to query other servers if it does not have the information.</p>\n<p>(Default = recurse; abbreviation = [no]rec)</p>\n<p><strong>ndots=number</strong><br>Set the number of dots (label separators) in a domain that will disable searching. Absolute names always stop searching.</p>\n<p><strong>retry=number</strong><br>Set the number of retries to number.</p>\n<p><strong>timeout=number</strong><br>Change the initial timeout interval for waiting for a reply to number seconds.</p>\n<p><strong>[no]vc</strong><br>Always use a virtual circuit when sending requests to the server.</p>\n<p>(Default = novc)</p>\n<p><strong>[no]fail</strong><br>Try the next nameserver if a nameserver responds with SERVFAIL or a referral (nofail) or terminate query (fail) on such a<br>response.</p>\n<p>(Default = nofail)</p>\n<h3 id=\"dig\"><a href=\"#dig\" class=\"headerlink\" title=\"dig\"></a>dig</h3><p>dig工具是用于查询DNS记录的工具，功能比nslookup更加强大，mac下自带了这个工具：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827225040112.png\" alt=\"dig工具\" style=\"zoom:50%;\" />\n\n\n\n<p>dig有意思的玩法：</p>\n<ol>\n<li><p>查看某个域名的DNS解析过程</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dig yankaizhang.com +trace</span></span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; yankaizhang.com +trace</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先找到本地域名服务器</span></span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tm.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\th.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\ta.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tb.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tk.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tl.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\ti.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tf.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tj.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\te.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tc.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\tg.root-servers.net.</span><br><span class=\"line\">.\t\t\t3153\tIN\tNS\td.root-servers.net.</span><br><span class=\"line\">;; Received 239 bytes from 192.168.1.1#53(192.168.1.1) in 36 ms</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 本地域名服务器请求根域名服务器（递归查询）</span></span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\ta.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tb.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tc.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\td.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\te.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tf.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tg.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\th.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\ti.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tj.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tk.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tl.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t172800\tIN\tNS\tm.gtld-servers.net.</span><br><span class=\"line\">com.\t\t\t86400\tIN\tDS\t30909 8 2 E2D3C916F6DEEAC73294E8268FB5885044A833FC5459588F4A9184CF C41A5766</span><br><span class=\"line\">com.\t\t\t86400\tIN\tRRSIG\tDS 8 1 86400 20210909050000 20210827040000 26838 . ZLTCRLor3hezbp3CvYQbJCE+4XLPCvLOPlWx+cXru6A0snY2Dkv44JX8 hMpgiueL+Jp1rem/CqAZbLfacGe3cpJJpEkxK5Xob8BKRj4bQE+wH6Et gLy97rFKvCmpf80q29GEgxD5XwRFZoMSqnoNRGMUjPe8yTBoCiGPo+RF UBm0oQ0L2YmNeBEy0KSe+EI4ySUw3BLPSRAu2R/CkpISY2JFmnuG6jSE uM7T9Y5tgFYS7Kvba1NiMsBIiLy3KrijjwczSVCWl+9IKCqaQpCmVqES npK7x9Y0uzlTgNwo8IC1nKzKqvBz7S1UibvTQNxaKK/+Kd8R2lixbO8Y 4ErY0Q==</span><br><span class=\"line\">;; Received 1175 bytes from 193.0.14.129#53(k.root-servers.net) in 47 ms</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 根域名服务器通知本地域名服务器去yankaizhang.com.顶级域名服务器（迭代查询）</span></span><br><span class=\"line\">yankaizhang.com.\t172800\tIN\tNS\tdns2.hichina.com.</span><br><span class=\"line\">yankaizhang.com.\t172800\tIN\tNS\tdns1.hichina.com.</span><br><span class=\"line\">CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN NSEC3 1 1 0 - CK0Q1GIN43N1ARRC9OSM6QPQR81H5M9A  NS SOA RRSIG DNSKEY NSEC3PARAM</span><br><span class=\"line\">CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 86400 IN RRSIG NSEC3 8 2 86400 20210901042504 20210825031504 39343 com. UjMhvFuOAHV8bbjokUqcBsgJe3Bf2xtTLT2JLkt5wXb40qu6XWzZArOl jTO3BwtnAj7D/KQIqNsBRq0P/Djh8GGgSUhMFCbcel9G6CVESLYq6/E1 SKhGl72pxNtYDHEB5RYnBxsg55rh+gZWZMlhS5h+EjTkz692t8U8lB2C OmIyJpCUsldl7ciWmxMRHwennzbemMT5rhfDSe/SRT4WsQ==</span><br><span class=\"line\">RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN NSEC3 1 1 0 - RTC22ASFHJHTLN9NCAREUK0D41R9BA1B  NS DS RRSIG</span><br><span class=\"line\">RTC0V9MOFGVV5RQ2BV3FMVPS9972PM35.com. 86400 IN RRSIG NSEC3 8 2 86400 20210831051456 20210824040456 39343 com. lmTGKCex0R26RXHbTQbyUcWejz0KIeJtpYhHNs2lyGWV8rY3E9vf+moL Kwqk3Fkk5YU8DEiMLCzkyWxGeqmnlxZVtGqmxDLnkrt83frflR2piT9k uWnJXlocN6XNvrlsEk+eGyzFGRPRMMdnu2JlWx6RYVS1b0PqmJJTLOPL EHqUYaZshDNhE2Bo9JMPtZMDRQoI+/GlTc+4htFDFxT9Iw==</span><br><span class=\"line\">;; Received 951 bytes from 192.41.162.30#53(l.gtld-servers.net) in 281 ms</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 查询结束，得到记录值（这里是CNAME）</span></span><br><span class=\"line\">yankaizhang.com.\t600\tIN\tCNAME\tyankaizhang.com.cdn.dnsv1.com.</span><br><span class=\"line\">;; Received 87 bytes from 106.11.211.64#53(dns2.hichina.com) in 27 ms</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>查找一个域名的授权DNS服务器</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dig  yankaizhang.com +nssearch</span></span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.24 in 26 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.63 in 27 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.64 in 27 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.23 in 28 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.13 in 31 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.53 in 31 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.211.54 in 31 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.23 in 31 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.81.14 in 31 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.14 in 37 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.13 in 37 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 140.205.41.24 in 37 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.123 in 47 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.114 in 48 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.124 in 49 ms.</span><br><span class=\"line\">SOA dns1.hichina.com. hostmaster.hichina.com. 2020071211 3600 1200 86400 360 from server 106.11.141.113 in 62 ms</span><br></pre></td></tr></table></figure></li>\n<li><p>查看域名的正向解析和反向解析</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dig yankaizhang.com</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> dig -x yankaizhang.com</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"host\"><a href=\"#host\" class=\"headerlink\" title=\"host\"></a>host</h3><p>host工具也是mac自带的一个DNS查询工具，其功能和输入输出和dig差不多，参数操作方式有所不同</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210827231223945.png\" alt=\"host工具\" style=\"zoom:50%;\" />\n\n<p>个人使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> host -a yankaizhang.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">Trying &quot;yankaizhang.com&quot;</span><br><span class=\"line\">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64983</span><br><span class=\"line\">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class=\"line\"></span><br><span class=\"line\">;; QUESTION SECTION:</span><br><span class=\"line\">;yankaizhang.com.\t\tIN\tANY</span><br><span class=\"line\"></span><br><span class=\"line\">;; ANSWER SECTION:</span><br><span class=\"line\">yankaizhang.com.\t600\tIN\tCNAME\tyankaizhang.com.cdn.dnsv1.com.</span><br><span class=\"line\">yankaizhang.com.\t3600\tIN\tNS\tdns1.hichina.com.</span><br><span class=\"line\">yankaizhang.com.\t3600\tIN\tNS\tdns2.hichina.com.</span><br><span class=\"line\"></span><br><span class=\"line\">Received 119 bytes from 192.168.1.1#53 in 207 ms</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://segmentfault.com/a/1190000039039275\">https://segmentfault.com/a/1190000039039275</a></p>\n<p><a href=\"https://www.cnblogs.com/549294286/p/5172435.html\">https://www.cnblogs.com/549294286/p/5172435.html</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1083201\">https://cloud.tencent.com/developer/article/1083201</a></p>\n<p><a href=\"https://www.cnblogs.com/machangwei-8/p/10353216.html\">https://www.cnblogs.com/machangwei-8/p/10353216.html</a></p>\n"},{"title":"unix网络编程-1-简单时间服务器","date":"2021-09-06T09:48:09.000Z","_content":"\n根据书上内容，编写一个简单的获取时间的客户端、服务器如下：\n\n## time client\n\n```c\n#include \"commons.h\"\n\n/**\n * time check client\n */\nint main(int argc, char const *argv[]) {\n    // fd socket描述符\n    int fd;\n    // 目标服务器socket包装体\n    struct sockaddr_in svraddr;\n\n    if (argc < 2) {\n        perror(\"usage: client <ip>\\n\");\n    }\n\n    fd = common_socket(AF_INET, SOCK_STREAM, 0);\n\n    // 初始化目标服务器信息\n    memset(&svraddr, 0, sizeof(svraddr));\n    svraddr.sin_family = AF_INET;\n    svraddr.sin_port = htons(13); // 时间服务器，端口13\n\n    // 将ip地址串转换为in_addr(整数)，然后赋值给svraddr\n    if (inet_pton(AF_INET, argv[1], &svraddr.sin_addr) <= 0) {\n        perror(\"inet_pton error\\n\");\n    }\n\n    // 尝试连接服务器\n    common_connect(fd, (SA *)&svraddr, sizeof(svraddr));\n\n    // 读取服务器发送的信息，写入buf中并且打印\n    int len;\n    char recvbuf[MAXLINE + 1];\n    while ((len = common_read(fd, recvbuf, MAXLINE)) > 0) {\n        recvbuf[len] = '\\0';\n        printf(\"%s\", recvbuf);\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n## time server\n\n```c\n#include \"commons.h\"\n\n#define LISTEN_NUMBER 1024\n\nint main(int argc, char const *argv[]) {\n    // 监听socket描述符，连接socket描述符\n    int listenfd, connfd;\n    struct sockaddr_in svraddr;\n    char wrtbuf[MAXLINE];\n    time_t ticks;\n\n    listenfd = common_socket(AF_INET, SOCK_STREAM, 0);\n\n    // 初始化服务器信息\n    memset(&svraddr, 0, sizeof(svraddr));\n    svraddr.sin_family = AF_INET;\n    svraddr.sin_port = htons(13);\n    svraddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    // 绑定监听socket和服务器socket信息\n    common_bind(listenfd, (SA *)&svraddr, sizeof(svraddr));\n\n    // 最多同时监听1024个连接\n    common_listen(listenfd, LISTEN_NUMBER);\n\n    // 接收客户端连接socket\n    while (1) {\n        connfd = accept(listenfd, NULL, NULL);\n        ticks = time(NULL);\n        snprintf(wrtbuf, sizeof(wrtbuf), \"%.24s\\r\\n\", ctime(&ticks));\n        common_write(connfd, wrtbuf, strlen(wrtbuf));\n        common_close(connfd);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n```\n\n## commons.h 公共头文件\n\n```c\n/**\n * 公共头文件\n */\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <netinet/in.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define MAXLINE 1024\n\ntypedef struct sockaddr SA;\n\n// 新建socket\nint common_socket(int family, int sock_type, int protocol) {\n    int fd;\n    if ((fd = (socket(family, sock_type, protocol))) < 0) {\n        perror(\"common_socket error\\n\");\n        exit(EXIT_FAILURE);\n    }\n    return fd;\n}\n\n// 连接socket\nvoid common_connect(int sockfd, const SA *svraddr, socklen_t socklen) {\n    if (connect(sockfd, svraddr, socklen) < 0) {\n        perror(\"common_connect error\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// 绑定socket\nvoid common_bind(int listenfd, const SA *svraddr, socklen_t socklen) {\n    if (bind(listenfd, svraddr, socklen) < 0) {\n        perror(\"common_bind error\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// 监听socket\nvoid common_listen(int listenfd, int conn_number) {\n    if (listen(listenfd, conn_number) < 0) {\n        perror(\"common_listen error\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// 读取socket\nint common_read(int sockfd, void *recvbuf, size_t recvlen) {\n    int len;\n    if ((len = read(sockfd, recvbuf, recvlen)) < 0) {\n        perror(\"common_read error\\n\");\n        exit(EXIT_FAILURE);\n    }\n    return len;\n}\n\n// 写入socket\nvoid common_write(int connfd, const void *buf, size_t nbytes) {\n    if (write(connfd, buf, nbytes) < 0) {\n        perror(\"common_write error\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// 关闭socket\nvoid common_close(int connfd) {\n    if (close(connfd) < 0) {\n        perror(\"common_close error\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n```\n\n## 运行效果\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210906175210048.png\" alt=\"运行截图\" style=\"zoom:50%;\" />\n","source":"_posts/UNIX网络编程-1-简单时间服务器.md","raw":"---\ntitle: unix网络编程-1-简单时间服务器\ndate: 2021-09-06 17:48:09\ncategories:\n    - 网络编程\ntags:\n    - Linux\n    - 网络编程\n    - socket\n---\n\n根据书上内容，编写一个简单的获取时间的客户端、服务器如下：\n\n## time client\n\n```c\n#include \"commons.h\"\n\n/**\n * time check client\n */\nint main(int argc, char const *argv[]) {\n    // fd socket描述符\n    int fd;\n    // 目标服务器socket包装体\n    struct sockaddr_in svraddr;\n\n    if (argc < 2) {\n        perror(\"usage: client <ip>\\n\");\n    }\n\n    fd = common_socket(AF_INET, SOCK_STREAM, 0);\n\n    // 初始化目标服务器信息\n    memset(&svraddr, 0, sizeof(svraddr));\n    svraddr.sin_family = AF_INET;\n    svraddr.sin_port = htons(13); // 时间服务器，端口13\n\n    // 将ip地址串转换为in_addr(整数)，然后赋值给svraddr\n    if (inet_pton(AF_INET, argv[1], &svraddr.sin_addr) <= 0) {\n        perror(\"inet_pton error\\n\");\n    }\n\n    // 尝试连接服务器\n    common_connect(fd, (SA *)&svraddr, sizeof(svraddr));\n\n    // 读取服务器发送的信息，写入buf中并且打印\n    int len;\n    char recvbuf[MAXLINE + 1];\n    while ((len = common_read(fd, recvbuf, MAXLINE)) > 0) {\n        recvbuf[len] = '\\0';\n        printf(\"%s\", recvbuf);\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n## time server\n\n```c\n#include \"commons.h\"\n\n#define LISTEN_NUMBER 1024\n\nint main(int argc, char const *argv[]) {\n    // 监听socket描述符，连接socket描述符\n    int listenfd, connfd;\n    struct sockaddr_in svraddr;\n    char wrtbuf[MAXLINE];\n    time_t ticks;\n\n    listenfd = common_socket(AF_INET, SOCK_STREAM, 0);\n\n    // 初始化服务器信息\n    memset(&svraddr, 0, sizeof(svraddr));\n    svraddr.sin_family = AF_INET;\n    svraddr.sin_port = htons(13);\n    svraddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    // 绑定监听socket和服务器socket信息\n    common_bind(listenfd, (SA *)&svraddr, sizeof(svraddr));\n\n    // 最多同时监听1024个连接\n    common_listen(listenfd, LISTEN_NUMBER);\n\n    // 接收客户端连接socket\n    while (1) {\n        connfd = accept(listenfd, NULL, NULL);\n        ticks = time(NULL);\n        snprintf(wrtbuf, sizeof(wrtbuf), \"%.24s\\r\\n\", ctime(&ticks));\n        common_write(connfd, wrtbuf, strlen(wrtbuf));\n        common_close(connfd);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n```\n\n## commons.h 公共头文件\n\n```c\n/**\n * 公共头文件\n */\n#include <arpa/inet.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <netinet/in.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define MAXLINE 1024\n\ntypedef struct sockaddr SA;\n\n// 新建socket\nint common_socket(int family, int sock_type, int protocol) {\n    int fd;\n    if ((fd = (socket(family, sock_type, protocol))) < 0) {\n        perror(\"common_socket error\\n\");\n        exit(EXIT_FAILURE);\n    }\n    return fd;\n}\n\n// 连接socket\nvoid common_connect(int sockfd, const SA *svraddr, socklen_t socklen) {\n    if (connect(sockfd, svraddr, socklen) < 0) {\n        perror(\"common_connect error\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// 绑定socket\nvoid common_bind(int listenfd, const SA *svraddr, socklen_t socklen) {\n    if (bind(listenfd, svraddr, socklen) < 0) {\n        perror(\"common_bind error\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// 监听socket\nvoid common_listen(int listenfd, int conn_number) {\n    if (listen(listenfd, conn_number) < 0) {\n        perror(\"common_listen error\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// 读取socket\nint common_read(int sockfd, void *recvbuf, size_t recvlen) {\n    int len;\n    if ((len = read(sockfd, recvbuf, recvlen)) < 0) {\n        perror(\"common_read error\\n\");\n        exit(EXIT_FAILURE);\n    }\n    return len;\n}\n\n// 写入socket\nvoid common_write(int connfd, const void *buf, size_t nbytes) {\n    if (write(connfd, buf, nbytes) < 0) {\n        perror(\"common_write error\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// 关闭socket\nvoid common_close(int connfd) {\n    if (close(connfd) < 0) {\n        perror(\"common_close error\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n```\n\n## 运行效果\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210906175210048.png\" alt=\"运行截图\" style=\"zoom:50%;\" />\n","slug":"UNIX网络编程-1-简单时间服务器","published":1,"updated":"2021-09-06T09:54:36.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktiszmi90003azqpgnsjdyh4","content":"<p>根据书上内容，编写一个简单的获取时间的客户端、服务器如下：</p>\n<h2 id=\"time-client\"><a href=\"#time-client\" class=\"headerlink\" title=\"time client\"></a>time client</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;commons.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * time check client</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// fd socket描述符</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">    <span class=\"comment\">// 目标服务器socket包装体</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">svraddr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;usage: client &lt;ip&gt;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fd = common_socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化目标服务器信息</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;svraddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(svraddr));</span><br><span class=\"line\">    svraddr.sin_family = AF_INET;</span><br><span class=\"line\">    svraddr.sin_port = htons(<span class=\"number\">13</span>); <span class=\"comment\">// 时间服务器，端口13</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将ip地址串转换为in_addr(整数)，然后赋值给svraddr</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inet_pton(AF_INET, argv[<span class=\"number\">1</span>], &amp;svraddr.sin_addr) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;inet_pton error\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试连接服务器</span></span><br><span class=\"line\">    common_connect(fd, (SA *)&amp;svraddr, <span class=\"keyword\">sizeof</span>(svraddr));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 读取服务器发送的信息，写入buf中并且打印</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> recvbuf[MAXLINE + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((len = common_read(fd, recvbuf, MAXLINE)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        recvbuf[len] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>, recvbuf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"time-server\"><a href=\"#time-server\" class=\"headerlink\" title=\"time server\"></a>time server</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;commons.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LISTEN_NUMBER 1024</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 监听socket描述符，连接socket描述符</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listenfd, connfd;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">svraddr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> wrtbuf[MAXLINE];</span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> ticks;</span><br><span class=\"line\"></span><br><span class=\"line\">    listenfd = common_socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化服务器信息</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;svraddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(svraddr));</span><br><span class=\"line\">    svraddr.sin_family = AF_INET;</span><br><span class=\"line\">    svraddr.sin_port = htons(<span class=\"number\">13</span>);</span><br><span class=\"line\">    svraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绑定监听socket和服务器socket信息</span></span><br><span class=\"line\">    common_bind(listenfd, (SA *)&amp;svraddr, <span class=\"keyword\">sizeof</span>(svraddr));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 最多同时监听1024个连接</span></span><br><span class=\"line\">    common_listen(listenfd, LISTEN_NUMBER);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 接收客户端连接socket</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        connfd = accept(listenfd, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        ticks = time(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(wrtbuf, <span class=\"keyword\">sizeof</span>(wrtbuf), <span class=\"string\">&quot;%.24s\\r\\n&quot;</span>, ctime(&amp;ticks));</span><br><span class=\"line\">        common_write(connfd, wrtbuf, <span class=\"built_in\">strlen</span>(wrtbuf));</span><br><span class=\"line\">        common_close(connfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"commons-h-公共头文件\"><a href=\"#commons-h-公共头文件\" class=\"headerlink\" title=\"commons.h 公共头文件\"></a>commons.h 公共头文件</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 公共头文件</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLINE 1024</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span> <span class=\"title\">SA</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">common_socket</span><span class=\"params\">(<span class=\"keyword\">int</span> family, <span class=\"keyword\">int</span> sock_type, <span class=\"keyword\">int</span> protocol)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((fd = (socket(family, sock_type, protocol))) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_socket error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">common_connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> SA *svraddr, <span class=\"keyword\">socklen_t</span> socklen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect(sockfd, svraddr, socklen) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_connect error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">common_bind</span><span class=\"params\">(<span class=\"keyword\">int</span> listenfd, <span class=\"keyword\">const</span> SA *svraddr, <span class=\"keyword\">socklen_t</span> socklen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bind(listenfd, svraddr, socklen) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_bind error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">common_listen</span><span class=\"params\">(<span class=\"keyword\">int</span> listenfd, <span class=\"keyword\">int</span> conn_number)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listen(listenfd, conn_number) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_listen error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">common_read</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *recvbuf, <span class=\"keyword\">size_t</span> recvlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((len = read(sockfd, recvbuf, recvlen)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_read error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写入socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">common_write</span><span class=\"params\">(<span class=\"keyword\">int</span> connfd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> nbytes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (write(connfd, buf, nbytes) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_write error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">common_close</span><span class=\"params\">(<span class=\"keyword\">int</span> connfd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (close(connfd) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_close error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行效果\"><a href=\"#运行效果\" class=\"headerlink\" title=\"运行效果\"></a>运行效果</h2><img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210906175210048.png\" alt=\"运行截图\" style=\"zoom:50%;\" />\n","site":{"data":{}},"excerpt":"","more":"<p>根据书上内容，编写一个简单的获取时间的客户端、服务器如下：</p>\n<h2 id=\"time-client\"><a href=\"#time-client\" class=\"headerlink\" title=\"time client\"></a>time client</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;commons.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * time check client</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// fd socket描述符</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">    <span class=\"comment\">// 目标服务器socket包装体</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">svraddr</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;usage: client &lt;ip&gt;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fd = common_socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化目标服务器信息</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;svraddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(svraddr));</span><br><span class=\"line\">    svraddr.sin_family = AF_INET;</span><br><span class=\"line\">    svraddr.sin_port = htons(<span class=\"number\">13</span>); <span class=\"comment\">// 时间服务器，端口13</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将ip地址串转换为in_addr(整数)，然后赋值给svraddr</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inet_pton(AF_INET, argv[<span class=\"number\">1</span>], &amp;svraddr.sin_addr) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;inet_pton error\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试连接服务器</span></span><br><span class=\"line\">    common_connect(fd, (SA *)&amp;svraddr, <span class=\"keyword\">sizeof</span>(svraddr));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 读取服务器发送的信息，写入buf中并且打印</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> recvbuf[MAXLINE + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((len = common_read(fd, recvbuf, MAXLINE)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        recvbuf[len] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>, recvbuf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"time-server\"><a href=\"#time-server\" class=\"headerlink\" title=\"time server\"></a>time server</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;commons.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LISTEN_NUMBER 1024</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 监听socket描述符，连接socket描述符</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listenfd, connfd;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">svraddr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> wrtbuf[MAXLINE];</span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> ticks;</span><br><span class=\"line\"></span><br><span class=\"line\">    listenfd = common_socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化服务器信息</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;svraddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(svraddr));</span><br><span class=\"line\">    svraddr.sin_family = AF_INET;</span><br><span class=\"line\">    svraddr.sin_port = htons(<span class=\"number\">13</span>);</span><br><span class=\"line\">    svraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绑定监听socket和服务器socket信息</span></span><br><span class=\"line\">    common_bind(listenfd, (SA *)&amp;svraddr, <span class=\"keyword\">sizeof</span>(svraddr));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 最多同时监听1024个连接</span></span><br><span class=\"line\">    common_listen(listenfd, LISTEN_NUMBER);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 接收客户端连接socket</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        connfd = accept(listenfd, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        ticks = time(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">snprintf</span>(wrtbuf, <span class=\"keyword\">sizeof</span>(wrtbuf), <span class=\"string\">&quot;%.24s\\r\\n&quot;</span>, ctime(&amp;ticks));</span><br><span class=\"line\">        common_write(connfd, wrtbuf, <span class=\"built_in\">strlen</span>(wrtbuf));</span><br><span class=\"line\">        common_close(connfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"commons-h-公共头文件\"><a href=\"#commons-h-公共头文件\" class=\"headerlink\" title=\"commons.h 公共头文件\"></a>commons.h 公共头文件</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 公共头文件</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLINE 1024</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span> <span class=\"title\">SA</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新建socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">common_socket</span><span class=\"params\">(<span class=\"keyword\">int</span> family, <span class=\"keyword\">int</span> sock_type, <span class=\"keyword\">int</span> protocol)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((fd = (socket(family, sock_type, protocol))) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_socket error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">common_connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> SA *svraddr, <span class=\"keyword\">socklen_t</span> socklen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connect(sockfd, svraddr, socklen) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_connect error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">common_bind</span><span class=\"params\">(<span class=\"keyword\">int</span> listenfd, <span class=\"keyword\">const</span> SA *svraddr, <span class=\"keyword\">socklen_t</span> socklen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bind(listenfd, svraddr, socklen) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_bind error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">common_listen</span><span class=\"params\">(<span class=\"keyword\">int</span> listenfd, <span class=\"keyword\">int</span> conn_number)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listen(listenfd, conn_number) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_listen error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">common_read</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *recvbuf, <span class=\"keyword\">size_t</span> recvlen)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((len = read(sockfd, recvbuf, recvlen)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_read error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写入socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">common_write</span><span class=\"params\">(<span class=\"keyword\">int</span> connfd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> nbytes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (write(connfd, buf, nbytes) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_write error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">common_close</span><span class=\"params\">(<span class=\"keyword\">int</span> connfd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (close(connfd) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">&quot;common_close error\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运行效果\"><a href=\"#运行效果\" class=\"headerlink\" title=\"运行效果\"></a>运行效果</h2><img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210906175210048.png\" alt=\"运行截图\" style=\"zoom:50%;\" />\n"},{"title":"unix网络编程-2-实现一个pthread_pool","date":"2021-09-09T09:52:59.000Z","_content":"\n这次使用C语言，设计一个基于pthread的线程池吧。\n\n想要设计线程池的原因有三个：\n\n1.   想要重新锻炼下C语言的编码能力\n2.   面试经常出现一些线程池的内容，笔者比较反感这些八股文，所以就简单实现一个线程池好了\n3.   线程池所谓服务端必不可少的组件，后面继续学习unix网络编程的时候会用到\n\n在开始之前按照惯例介绍一下环境：\n\n-   macOS 10.15\n-   gcc工具链（clang）\n-   gdb调试（brew install gdb）\n\n\n\n## 开始设计线程池结构\n\n笔者参考了Java提供的ThreadPoolExecutor类，也就是线程池类，当然也顺便研究了一下源码，发现略有点复杂，我们这次就实现一个Fixed_Pool，也就是核心线程就等于工作线程数好了。\n\n给出线程池pthread_pool的设计图如下：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909182922612.png\" alt=\"pthread_pool设计\" style=\"zoom:50%;\" />\n\n单看图的话还是比较简单的，因为这次写一个固定核心线程数的线程池，比如上图，核心线程数为2，等待队列长度为4，某一时刻，这个线程池能负载的最大任务数为6个（2个正在执行，4个等待执行）\n\n如果等待队列已满，此时再尝试提交任务的话就会返回-1，代表提交失败。\n\n\n\n## 定义核心结构体\n\n从上面的设计图中看到，需要设计的结构有两个：pthread_pool类型和task任务类型\n\n于是给出下面的设计：\n\n```c\n/**\n * pthread_pool\n * 实现一个基于pthread的Fixed线程池，创建初期就初始化n个线程，n个核心线程全部活跃\n * 线程池真正可以负载的任务数量t = 线程数量w + 等待队列长度n\n * 例如：一个3核心线程，队列长度为2的线程池，其负载能力最大为5\n */\n\ntypedef enum _pthread_pool_state {\n    RUNNING,   // 运行\n    TERMINATED // 结束\n} pthread_pool_state;\n\ntypedef struct _pthread_pool_task_t {\n    void *(*func)(void *); // 任务函数\n    void *args;            // 函数参数\n} pthread_pool_task_t;\n\nstruct pthread_pool_t {\n    pthread_mutex_t mutex; // 内部锁\n    pthread_cond_t cond;   // 同步条件\n\n    pthread_t *threads; // 线程数组\n    int thread_count;   // 核心线程数量\n\n    pthread_pool_task_t *task_queue; // 任务队列\n    int task_head;                   // 头部指针\n    int task_tail;                   // 尾部指针\n    int task_queue_size;             // 最大任务队列长度\n    int task_count;                  // 当前任务数量\n    pthread_pool_state pool_state;   // 线程池状态\n};\n\n#define SPP struct pthread_pool_t\n```\n\n笔者这里额外加了一个state枚举类型来表示线程池当前的执行状态，当然执行状态很简单只有两种：运行中和终止\n\n\n\n## 设计线程池的关键函数\n\n对于一个线程池，不难想到有几个核心方法需要设计并且实现：创建、提交任务、核心线程工作函数、关闭、释放资源\n\n下面给出笔者设计的这5个函数的定义：\n\n```c\nvoid *pthread_pool_worker(void *);\nvoid pthread_pool_release(SPP *);\nint pthread_pool_submit(SPP *, void *(*)(void *), void *);\nvoid pthread_pool_shutdown(SPP *);\nSPP *pthread_pool_create(int, int);\n```\n\n\n\n### pthread_pool_create函数实现\n\n创建一个线程池，即定义一个结构体对象，然后分配相应的内存，同时初始化其中的一些参数即可。\n\n因为是核心线程全部运行，所以创建的时候就初始化核心线程数量的工作线程数组\n\n```c\n// 新建一个线程池\nSPP *pthread_pool_create(int thread_count, int queue_size) {\n    assert(thread_count > 0 && queue_size > 0);\n\n    SPP *tmp = (SPP *)malloc(sizeof(SPP));\n\n    if (pthread_mutex_init(&tmp->mutex, NULL) != 0) return NULL;\n    if (pthread_cond_init(&tmp->cond, NULL) != 0) return NULL;\n\n    pthread_attr_t tmp_attr;\n    if (pthread_attr_init(&tmp_attr) != 0) return NULL;\n\n    tmp->thread_count = thread_count;\n    tmp->threads = (pthread_t *)malloc(thread_count * sizeof(pthread_t));\n    tmp->task_queue_size = queue_size;\n    tmp->task_queue = (pthread_pool_task_t *)malloc(queue_size * sizeof(pthread_pool_task_t));\n    tmp->task_head = 0;\n    tmp->task_tail = 0;\n    tmp->task_count = 0;\n    tmp->pool_state = RUNNING;\n\n    // 设置线程退出时自动回收资源\n    pthread_attr_setdetachstate(&tmp_attr, PTHREAD_CREATE_DETACHED);\n\n    int flag = 1;\n    for (int i = 0; i < tmp->thread_count; ++i) {\n        // printf(\"创建%d号线程\\n\", i);\n        int ret = pthread_create(&(tmp->threads[i]), &tmp_attr, pthread_pool_worker, tmp);\n        if (ret != 0) {\n            flag = 0;\n            break;\n        }\n    }\n    if (!flag) {\n        pthread_pool_shutdown(tmp);\n        return NULL;\n    }\n\n    return tmp;\n}\n```\n\n\n\n### pthread_pool_worker函数实现\n\nworker函数是线程池每个内置工作线程不断运行的一个方法，在这个方法里线程不断检查任务队列是否有任务需要完成，否则就阻塞等待被唤醒；如何唤醒呢？当提交任务的时候会通过condition唤醒阻塞的线程检查任务队列执行。\n\n-   当确认存在任务需要完成的时候，线程会获取这个任务并且将任务队列头指针后移一位，然后执行这个任务\n\n-   如果线程池需要关闭，那么worker函数会break退出，同时回收工作线程资源\n\n```c\n// 线程池内置线程处理函数\nvoid *pthread_pool_worker(void *args) {\n    SPP *pool = (SPP *)args;\n    pthread_pool_task_t task;\n\n    while (1) {\n        pthread_mutex_lock(&(pool->mutex));\n        // 尝试循环获取任务，没有任务就阻塞等待\n        while (pool->task_count == 0 && pool->pool_state == RUNNING) {\n            pthread_cond_wait(&(pool->cond), &(pool->mutex));\n        }\n\n        if (pool->pool_state != RUNNING) break;\n        task.func = pool->task_queue[pool->task_head].func;\n        task.args = pool->task_queue[pool->task_head].args;\n\n        pool->task_head++;\n        if (pool->task_head == pool->task_queue_size) pool->task_head = 0;\n        pool->task_count--;\n        pthread_mutex_unlock(&(pool->mutex));\n\t\n        // 执行任务\n        task.func(task.args);\n    }\n\n    pthread_mutex_unlock(&(pool->mutex));\n    pthread_exit(NULL);\n    return NULL;\n}\n```\n\n\n\n### pthread_pool_submit函数实现\n\n向线程池中提交一个任务，然后尝试唤醒阻塞等待的工作线程，移动tail指针\n\n```c\n\n// 提交一个任务\nint pthread_pool_submit(SPP *pool, void *(*func)(void *), void *args) {\n    if (!pool || !func) return -1;\n    pthread_mutex_lock(&(pool->mutex));\n\n    int flag = -1;\n    do {\n        // 判断下一个tail位置\n        int pos = pool->task_tail + 1;\n        pos = ((pos == pool->task_queue_size) ? 0 : pos);\n\n        if (pool->task_queue_size == pool->task_count) break;\n        if (pool->pool_state != RUNNING) break;\n\n        pool->task_queue[pool->task_tail].func = func;\n        pool->task_queue[pool->task_tail].args = args;\n\n        pool->task_tail = pos;\n        pool->task_count++;\n        pthread_cond_signal(&(pool->cond));\n        flag = 0;\n    } while (0);\n    pthread_mutex_unlock(&(pool->mutex));\n    return flag;\n}\n```\n\n\n\n### 剩余函数实现\n\n关闭和回收线程池资源，C语言的动态内存操作需要小心一点\n\n```c\n// 关闭线程池\nvoid pthread_pool_shutdown(SPP *pool) {\n    pthread_mutex_lock(&(pool->mutex));\n\n    while (pool->pool_state == RUNNING) {\n        pool->pool_state = TERMINATED;\n    }\n\n    // 唤醒所有可能等待的核心线程\n    pthread_cond_signal(&(pool->cond));\n\n    // 尝试取消所有正在运行的线程\n    for (int i = 0; i < pool->thread_count; i++) {\n        printf(\"尝试取消线程%d...\\n\", i);\n        pthread_cancel(pool->threads[i]);\n    }\n\n    pthread_mutex_unlock(&(pool->mutex));\n    pthread_pool_release(pool);\n}\n\n// 释放线程池资源\nvoid pthread_pool_release(SPP *pool) {\n    if (pool->threads) free(pool->threads);\n    if (pool->task_queue) free(pool->task_queue);\n    pthread_mutex_destroy(&(pool->mutex));\n    pthread_cond_destroy(&(pool->cond));\n    free(pool);\n}\n```\n\n关闭线程池的方法这里是非阻塞的，调用了之后不一定会结束所有正在工作的线程。\n\n关闭线程池的时候尝试取消正在运行的线程，如果运行线程内部是个死循环并且没有监听取消事件，会造成程序无法结束。\n\n\n\n## 验证线程池功能\n\n简单写一个程序验证线程池的功能\n\n首先给出上面线程池必须依赖的头文件内容：\n\n```c\n#ifndef _COMMONS_H_\n#define _COMMONS_H_\n\n#include <arpa/inet.h>\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <memory.h>\n#include <netinet/in.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/msg.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#endif\n```\n\n然后简单写一个main.c来测试线程池的功能：\n\n```c\n#include \"pool.h\"\n#include \"time.h\"\n\nvoid *task(void *args) {\n    time_t t = time(NULL);\n    printf(\"[Thread-%d]: %s\", pthread_self(), ctime(&t));\n    sleep(1);\n    return NULL;\n}\n\nint main(int argc, char const *argv[]) {\n    // 新建一个线程池\n    SPP *pool = pthread_pool_create(3, 50);\n\n    int cnt = 0;\n    for (int i = 1; i <= 100; i++) {\n        int ret = pthread_pool_submit(pool, task, NULL);\n        if (ret != 0) {\n            printf(\"%d 号任务提交失败...\\n\", i);\n        } else {\n            printf(\"%d 号任务提交成功!!!\\n\", i);\n            cnt++;\n        }\n    }\n    printf(\"成功提交任务数量：%d\\n\", cnt);\n\n    // 主线程阻塞不退出\n    pthread_exit(NULL);\n\n    // 尝试关闭线程池\n    pthread_pool_shutdown(pool);\n    return 0;\n}\n```\n\n这里创建了一个核心数量为3，等待队列大小为50的线程池，所以可以得到同一时刻可以提交的最大任务数量是53个任务，其余的任务会提交失败。\n\n因为核心数量是3，所以同一时刻运行会有3个不同线程执行任务，并且打出当前时间，这里直接给出一部分的输出吧：\n\n```shell\n$ cc -g pool.c main.c -lpthread\n$ ./a.out\n```\n\n输出如下：\n\n```shell\n1 号任务提交成功!!!\n2 号任务提交成功!!!\n3 号任务提交成功!!!\n4 号任务提交成功!!!\n5 号任务提交成功!!!\n6 号任务提交成功!!!\n7 号任务提交成功!!!\n8 号任务提交成功!!!\n9 号任务提交成功!!!\n10 号任务提交成功!!!\n11 号任务提交成功!!!\n12 号任务提交成功!!!\n13 号任务提交成功!!!\n14 号任务提交成功!!!\n15 号任务提交成功!!!\n16 号任务提交成功!!!\n17 号任务提交成功!!!\n18 号任务提交成功!!!\n19 号任务提交成功!!!\n20 号任务提交成功!!!\n21 号任务提交成功!!!\n22 号任务提交成功!!!\n23 号任务提交成功!!!\n24 号任务提交成功!!!\n25 号任务提交成功!!!\n26 号任务提交成功!!!\n27 号任务提交成功!!!\n28 号任务提交成功!!!\n29 号任务提交成功!!!\n30 号任务提交成功!!!\n31 号任务提交成功!!!\n32 号任务提交成功!!!\n33 号任务提交成功!!!\n34 号任务提交成功!!!\n35 号任务提交成功!!!\n36 号任务提交成功!!!\n37 号任务提交成功!!!\n38 号任务提交成功!!!\n39 号任务提交成功!!!\n40 号任务提交成功!!!\n41 号任务提交成功!!!\n42 号任务提交成功!!!\n43 号任务提交成功!!!\n44 号任务提交成功!!!\n45 号任务提交成功!!!\n46 号任务提交成功!!!\n47 号任务提交成功!!!\n48 号任务提交成功!!!\n49 号任务提交成功!!!\n50 号任务提交成功!!!\n51 号任务提交成功!!!\n52 号任务提交成功!!!\n53 号任务提交成功!!!\n54 号任务提交失败...\n55 号任务提交失败...\n56 号任务提交失败...\n57 号任务提交失败...\n58 号任务提交失败...\n59 号任务提交失败...\n60 号任务提交失败...\n61 号任务提交失败...\n62 号任务提交失败...\n63 号任务提交失败...\n64 号任务提交失败...\n65 号任务提交失败...\n66 号任务提交失败...\n67 号任务提交失败...\n68 号任务提交失败...\n69 号任务提交失败...\n70 号任务提交失败...\n71 号任务提交失败...\n72 号任务提交失败...\n73 号任务提交失败...\n74 号任务提交失败...\n75 号任务提交失败...\n76 号任务提交失败...\n77 号任务提交失败...\n78 号任务提交失败...\n79 号任务提交失败...\n80 号任务提交失败...\n81 号任务提交失败...\n82 号任务提交失败...\n83 号任务提交失败...\n84 号任务提交失败...\n85 号任务提交失败...\n86 号任务提交失败...\n87 号任务提交失败...\n88 号任务提交失败...\n89 号任务提交失败...\n90 号任务提交失败...\n91 号任务提交失败...\n92 号任务提交失败...\n93 号任务提交失败...\n94 号任务提交失败...\n95 号任务提交失败...\n96 号任务提交失败...\n97 号任务提交失败...\n98 号任务提交失败...\n99 号任务提交失败...\n100 号任务提交失败...\n成功提交任务数量：53\n[Thread-27713536]: Thu Sep  9 18:40:49 2021\n[Thread-28250112]: Thu Sep  9 18:40:49 2021\n[Thread-28786688]: Thu Sep  9 18:40:49 2021\n[Thread-28786688]: Thu Sep  9 18:40:50 2021\n[Thread-28250112]: Thu Sep  9 18:40:50 2021\n[Thread-27713536]: Thu Sep  9 18:40:50 2021\n[Thread-28786688]: Thu Sep  9 18:40:51 2021\n[Thread-28250112]: Thu Sep  9 18:40:51 2021\n[Thread-27713536]: Thu Sep  9 18:40:51 2021\n[Thread-28786688]: Thu Sep  9 18:40:52 2021\n[Thread-28250112]: Thu Sep  9 18:40:52 2021\n[Thread-27713536]: Thu Sep  9 18:40:52 2021\n[Thread-28786688]: Thu Sep  9 18:40:53 2021\n[Thread-28250112]: Thu Sep  9 18:40:53 2021\n[Thread-27713536]: Thu Sep  9 18:40:53 2021\n[Thread-28250112]: Thu Sep  9 18:40:54 2021\n[Thread-27713536]: Thu Sep  9 18:40:54 2021\n[Thread-28786688]: Thu Sep  9 18:40:54 2021\n[Thread-28250112]: Thu Sep  9 18:40:55 2021\n[Thread-27713536]: Thu Sep  9 18:40:55 2021\n[Thread-28786688]: Thu Sep  9 18:40:55 2021\n[Thread-28250112]: Thu Sep  9 18:40:56 2021\n[Thread-27713536]: Thu Sep  9 18:40:56 2021\n[Thread-28786688]: Thu Sep  9 18:40:56 2021\n[Thread-28786688]: Thu Sep  9 18:40:57 2021\n[Thread-28250112]: Thu Sep  9 18:40:57 2021\n[Thread-27713536]: Thu Sep  9 18:40:57 2021\n[Thread-28786688]: Thu Sep  9 18:40:58 2021\n[Thread-28250112]: Thu Sep  9 18:40:58 2021\n[Thread-27713536]: Thu Sep  9 18:40:58 2021\n[Thread-28786688]: Thu Sep  9 18:41:00 2021\n[Thread-28250112]: Thu Sep  9 18:41:00 2021\n[Thread-27713536]: Thu Sep  9 18:41:00 2021\n[Thread-28786688]: Thu Sep  9 18:41:01 2021\n[Thread-28250112]: Thu Sep  9 18:41:01 2021\n[Thread-27713536]: Thu Sep  9 18:41:01 2021\n[Thread-27713536]: Thu Sep  9 18:41:02 2021\n[Thread-28250112]: Thu Sep  9 18:41:02 2021\n[Thread-28786688]: Thu Sep  9 18:41:02 2021\n[Thread-27713536]: Thu Sep  9 18:41:03 2021\n[Thread-28786688]: Thu Sep  9 18:41:03 2021\n[Thread-28250112]: Thu Sep  9 18:41:03 2021\n[Thread-28250112]: Thu Sep  9 18:41:04 2021\n[Thread-27713536]: Thu Sep  9 18:41:04 2021\n[Thread-28786688]: Thu Sep  9 18:41:04 2021\n[Thread-28250112]: Thu Sep  9 18:41:05 2021\n[Thread-28786688]: Thu Sep  9 18:41:05 2021\n[Thread-27713536]: Thu Sep  9 18:41:05 2021\n[Thread-28250112]: Thu Sep  9 18:41:06 2021\n[Thread-27713536]: Thu Sep  9 18:41:06 2021\n[Thread-28786688]: Thu Sep  9 18:41:06 2021\n[Thread-28786688]: Thu Sep  9 18:41:07 2021\n[Thread-28250112]: Thu Sep  9 18:41:07 2021\n\n$ ^C\n```\n\n\n\n## 其他内容\n\nvscode配置的调试debug只能调试单文件，这次调试就是用的gdb来调试的\n\n编译的时候加入-g参数生成debug信息，然后gdb a.out就可以调试程序了\n\n对于多线程的调试，gdb也是很方便的，具体参考：https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909184526181.png\" alt=\"使用gdb调试\" style=\"zoom:50%;\" />\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909184608119.png\" alt=\"gdb显示所有线程\" style=\"zoom:50%;\" />\n","source":"_posts/unix网络编程-2-实现一个pthread-pool.md","raw":"---\ntitle: unix网络编程-2-实现一个pthread_pool\ndate: 2021-09-09 17:52:59\ncategories:\n- 网络编程\ntags:\n- 网络编程\n- 线程池\n- Linux\n- pthread\n---\n\n这次使用C语言，设计一个基于pthread的线程池吧。\n\n想要设计线程池的原因有三个：\n\n1.   想要重新锻炼下C语言的编码能力\n2.   面试经常出现一些线程池的内容，笔者比较反感这些八股文，所以就简单实现一个线程池好了\n3.   线程池所谓服务端必不可少的组件，后面继续学习unix网络编程的时候会用到\n\n在开始之前按照惯例介绍一下环境：\n\n-   macOS 10.15\n-   gcc工具链（clang）\n-   gdb调试（brew install gdb）\n\n\n\n## 开始设计线程池结构\n\n笔者参考了Java提供的ThreadPoolExecutor类，也就是线程池类，当然也顺便研究了一下源码，发现略有点复杂，我们这次就实现一个Fixed_Pool，也就是核心线程就等于工作线程数好了。\n\n给出线程池pthread_pool的设计图如下：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909182922612.png\" alt=\"pthread_pool设计\" style=\"zoom:50%;\" />\n\n单看图的话还是比较简单的，因为这次写一个固定核心线程数的线程池，比如上图，核心线程数为2，等待队列长度为4，某一时刻，这个线程池能负载的最大任务数为6个（2个正在执行，4个等待执行）\n\n如果等待队列已满，此时再尝试提交任务的话就会返回-1，代表提交失败。\n\n\n\n## 定义核心结构体\n\n从上面的设计图中看到，需要设计的结构有两个：pthread_pool类型和task任务类型\n\n于是给出下面的设计：\n\n```c\n/**\n * pthread_pool\n * 实现一个基于pthread的Fixed线程池，创建初期就初始化n个线程，n个核心线程全部活跃\n * 线程池真正可以负载的任务数量t = 线程数量w + 等待队列长度n\n * 例如：一个3核心线程，队列长度为2的线程池，其负载能力最大为5\n */\n\ntypedef enum _pthread_pool_state {\n    RUNNING,   // 运行\n    TERMINATED // 结束\n} pthread_pool_state;\n\ntypedef struct _pthread_pool_task_t {\n    void *(*func)(void *); // 任务函数\n    void *args;            // 函数参数\n} pthread_pool_task_t;\n\nstruct pthread_pool_t {\n    pthread_mutex_t mutex; // 内部锁\n    pthread_cond_t cond;   // 同步条件\n\n    pthread_t *threads; // 线程数组\n    int thread_count;   // 核心线程数量\n\n    pthread_pool_task_t *task_queue; // 任务队列\n    int task_head;                   // 头部指针\n    int task_tail;                   // 尾部指针\n    int task_queue_size;             // 最大任务队列长度\n    int task_count;                  // 当前任务数量\n    pthread_pool_state pool_state;   // 线程池状态\n};\n\n#define SPP struct pthread_pool_t\n```\n\n笔者这里额外加了一个state枚举类型来表示线程池当前的执行状态，当然执行状态很简单只有两种：运行中和终止\n\n\n\n## 设计线程池的关键函数\n\n对于一个线程池，不难想到有几个核心方法需要设计并且实现：创建、提交任务、核心线程工作函数、关闭、释放资源\n\n下面给出笔者设计的这5个函数的定义：\n\n```c\nvoid *pthread_pool_worker(void *);\nvoid pthread_pool_release(SPP *);\nint pthread_pool_submit(SPP *, void *(*)(void *), void *);\nvoid pthread_pool_shutdown(SPP *);\nSPP *pthread_pool_create(int, int);\n```\n\n\n\n### pthread_pool_create函数实现\n\n创建一个线程池，即定义一个结构体对象，然后分配相应的内存，同时初始化其中的一些参数即可。\n\n因为是核心线程全部运行，所以创建的时候就初始化核心线程数量的工作线程数组\n\n```c\n// 新建一个线程池\nSPP *pthread_pool_create(int thread_count, int queue_size) {\n    assert(thread_count > 0 && queue_size > 0);\n\n    SPP *tmp = (SPP *)malloc(sizeof(SPP));\n\n    if (pthread_mutex_init(&tmp->mutex, NULL) != 0) return NULL;\n    if (pthread_cond_init(&tmp->cond, NULL) != 0) return NULL;\n\n    pthread_attr_t tmp_attr;\n    if (pthread_attr_init(&tmp_attr) != 0) return NULL;\n\n    tmp->thread_count = thread_count;\n    tmp->threads = (pthread_t *)malloc(thread_count * sizeof(pthread_t));\n    tmp->task_queue_size = queue_size;\n    tmp->task_queue = (pthread_pool_task_t *)malloc(queue_size * sizeof(pthread_pool_task_t));\n    tmp->task_head = 0;\n    tmp->task_tail = 0;\n    tmp->task_count = 0;\n    tmp->pool_state = RUNNING;\n\n    // 设置线程退出时自动回收资源\n    pthread_attr_setdetachstate(&tmp_attr, PTHREAD_CREATE_DETACHED);\n\n    int flag = 1;\n    for (int i = 0; i < tmp->thread_count; ++i) {\n        // printf(\"创建%d号线程\\n\", i);\n        int ret = pthread_create(&(tmp->threads[i]), &tmp_attr, pthread_pool_worker, tmp);\n        if (ret != 0) {\n            flag = 0;\n            break;\n        }\n    }\n    if (!flag) {\n        pthread_pool_shutdown(tmp);\n        return NULL;\n    }\n\n    return tmp;\n}\n```\n\n\n\n### pthread_pool_worker函数实现\n\nworker函数是线程池每个内置工作线程不断运行的一个方法，在这个方法里线程不断检查任务队列是否有任务需要完成，否则就阻塞等待被唤醒；如何唤醒呢？当提交任务的时候会通过condition唤醒阻塞的线程检查任务队列执行。\n\n-   当确认存在任务需要完成的时候，线程会获取这个任务并且将任务队列头指针后移一位，然后执行这个任务\n\n-   如果线程池需要关闭，那么worker函数会break退出，同时回收工作线程资源\n\n```c\n// 线程池内置线程处理函数\nvoid *pthread_pool_worker(void *args) {\n    SPP *pool = (SPP *)args;\n    pthread_pool_task_t task;\n\n    while (1) {\n        pthread_mutex_lock(&(pool->mutex));\n        // 尝试循环获取任务，没有任务就阻塞等待\n        while (pool->task_count == 0 && pool->pool_state == RUNNING) {\n            pthread_cond_wait(&(pool->cond), &(pool->mutex));\n        }\n\n        if (pool->pool_state != RUNNING) break;\n        task.func = pool->task_queue[pool->task_head].func;\n        task.args = pool->task_queue[pool->task_head].args;\n\n        pool->task_head++;\n        if (pool->task_head == pool->task_queue_size) pool->task_head = 0;\n        pool->task_count--;\n        pthread_mutex_unlock(&(pool->mutex));\n\t\n        // 执行任务\n        task.func(task.args);\n    }\n\n    pthread_mutex_unlock(&(pool->mutex));\n    pthread_exit(NULL);\n    return NULL;\n}\n```\n\n\n\n### pthread_pool_submit函数实现\n\n向线程池中提交一个任务，然后尝试唤醒阻塞等待的工作线程，移动tail指针\n\n```c\n\n// 提交一个任务\nint pthread_pool_submit(SPP *pool, void *(*func)(void *), void *args) {\n    if (!pool || !func) return -1;\n    pthread_mutex_lock(&(pool->mutex));\n\n    int flag = -1;\n    do {\n        // 判断下一个tail位置\n        int pos = pool->task_tail + 1;\n        pos = ((pos == pool->task_queue_size) ? 0 : pos);\n\n        if (pool->task_queue_size == pool->task_count) break;\n        if (pool->pool_state != RUNNING) break;\n\n        pool->task_queue[pool->task_tail].func = func;\n        pool->task_queue[pool->task_tail].args = args;\n\n        pool->task_tail = pos;\n        pool->task_count++;\n        pthread_cond_signal(&(pool->cond));\n        flag = 0;\n    } while (0);\n    pthread_mutex_unlock(&(pool->mutex));\n    return flag;\n}\n```\n\n\n\n### 剩余函数实现\n\n关闭和回收线程池资源，C语言的动态内存操作需要小心一点\n\n```c\n// 关闭线程池\nvoid pthread_pool_shutdown(SPP *pool) {\n    pthread_mutex_lock(&(pool->mutex));\n\n    while (pool->pool_state == RUNNING) {\n        pool->pool_state = TERMINATED;\n    }\n\n    // 唤醒所有可能等待的核心线程\n    pthread_cond_signal(&(pool->cond));\n\n    // 尝试取消所有正在运行的线程\n    for (int i = 0; i < pool->thread_count; i++) {\n        printf(\"尝试取消线程%d...\\n\", i);\n        pthread_cancel(pool->threads[i]);\n    }\n\n    pthread_mutex_unlock(&(pool->mutex));\n    pthread_pool_release(pool);\n}\n\n// 释放线程池资源\nvoid pthread_pool_release(SPP *pool) {\n    if (pool->threads) free(pool->threads);\n    if (pool->task_queue) free(pool->task_queue);\n    pthread_mutex_destroy(&(pool->mutex));\n    pthread_cond_destroy(&(pool->cond));\n    free(pool);\n}\n```\n\n关闭线程池的方法这里是非阻塞的，调用了之后不一定会结束所有正在工作的线程。\n\n关闭线程池的时候尝试取消正在运行的线程，如果运行线程内部是个死循环并且没有监听取消事件，会造成程序无法结束。\n\n\n\n## 验证线程池功能\n\n简单写一个程序验证线程池的功能\n\n首先给出上面线程池必须依赖的头文件内容：\n\n```c\n#ifndef _COMMONS_H_\n#define _COMMONS_H_\n\n#include <arpa/inet.h>\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <memory.h>\n#include <netinet/in.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/msg.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#endif\n```\n\n然后简单写一个main.c来测试线程池的功能：\n\n```c\n#include \"pool.h\"\n#include \"time.h\"\n\nvoid *task(void *args) {\n    time_t t = time(NULL);\n    printf(\"[Thread-%d]: %s\", pthread_self(), ctime(&t));\n    sleep(1);\n    return NULL;\n}\n\nint main(int argc, char const *argv[]) {\n    // 新建一个线程池\n    SPP *pool = pthread_pool_create(3, 50);\n\n    int cnt = 0;\n    for (int i = 1; i <= 100; i++) {\n        int ret = pthread_pool_submit(pool, task, NULL);\n        if (ret != 0) {\n            printf(\"%d 号任务提交失败...\\n\", i);\n        } else {\n            printf(\"%d 号任务提交成功!!!\\n\", i);\n            cnt++;\n        }\n    }\n    printf(\"成功提交任务数量：%d\\n\", cnt);\n\n    // 主线程阻塞不退出\n    pthread_exit(NULL);\n\n    // 尝试关闭线程池\n    pthread_pool_shutdown(pool);\n    return 0;\n}\n```\n\n这里创建了一个核心数量为3，等待队列大小为50的线程池，所以可以得到同一时刻可以提交的最大任务数量是53个任务，其余的任务会提交失败。\n\n因为核心数量是3，所以同一时刻运行会有3个不同线程执行任务，并且打出当前时间，这里直接给出一部分的输出吧：\n\n```shell\n$ cc -g pool.c main.c -lpthread\n$ ./a.out\n```\n\n输出如下：\n\n```shell\n1 号任务提交成功!!!\n2 号任务提交成功!!!\n3 号任务提交成功!!!\n4 号任务提交成功!!!\n5 号任务提交成功!!!\n6 号任务提交成功!!!\n7 号任务提交成功!!!\n8 号任务提交成功!!!\n9 号任务提交成功!!!\n10 号任务提交成功!!!\n11 号任务提交成功!!!\n12 号任务提交成功!!!\n13 号任务提交成功!!!\n14 号任务提交成功!!!\n15 号任务提交成功!!!\n16 号任务提交成功!!!\n17 号任务提交成功!!!\n18 号任务提交成功!!!\n19 号任务提交成功!!!\n20 号任务提交成功!!!\n21 号任务提交成功!!!\n22 号任务提交成功!!!\n23 号任务提交成功!!!\n24 号任务提交成功!!!\n25 号任务提交成功!!!\n26 号任务提交成功!!!\n27 号任务提交成功!!!\n28 号任务提交成功!!!\n29 号任务提交成功!!!\n30 号任务提交成功!!!\n31 号任务提交成功!!!\n32 号任务提交成功!!!\n33 号任务提交成功!!!\n34 号任务提交成功!!!\n35 号任务提交成功!!!\n36 号任务提交成功!!!\n37 号任务提交成功!!!\n38 号任务提交成功!!!\n39 号任务提交成功!!!\n40 号任务提交成功!!!\n41 号任务提交成功!!!\n42 号任务提交成功!!!\n43 号任务提交成功!!!\n44 号任务提交成功!!!\n45 号任务提交成功!!!\n46 号任务提交成功!!!\n47 号任务提交成功!!!\n48 号任务提交成功!!!\n49 号任务提交成功!!!\n50 号任务提交成功!!!\n51 号任务提交成功!!!\n52 号任务提交成功!!!\n53 号任务提交成功!!!\n54 号任务提交失败...\n55 号任务提交失败...\n56 号任务提交失败...\n57 号任务提交失败...\n58 号任务提交失败...\n59 号任务提交失败...\n60 号任务提交失败...\n61 号任务提交失败...\n62 号任务提交失败...\n63 号任务提交失败...\n64 号任务提交失败...\n65 号任务提交失败...\n66 号任务提交失败...\n67 号任务提交失败...\n68 号任务提交失败...\n69 号任务提交失败...\n70 号任务提交失败...\n71 号任务提交失败...\n72 号任务提交失败...\n73 号任务提交失败...\n74 号任务提交失败...\n75 号任务提交失败...\n76 号任务提交失败...\n77 号任务提交失败...\n78 号任务提交失败...\n79 号任务提交失败...\n80 号任务提交失败...\n81 号任务提交失败...\n82 号任务提交失败...\n83 号任务提交失败...\n84 号任务提交失败...\n85 号任务提交失败...\n86 号任务提交失败...\n87 号任务提交失败...\n88 号任务提交失败...\n89 号任务提交失败...\n90 号任务提交失败...\n91 号任务提交失败...\n92 号任务提交失败...\n93 号任务提交失败...\n94 号任务提交失败...\n95 号任务提交失败...\n96 号任务提交失败...\n97 号任务提交失败...\n98 号任务提交失败...\n99 号任务提交失败...\n100 号任务提交失败...\n成功提交任务数量：53\n[Thread-27713536]: Thu Sep  9 18:40:49 2021\n[Thread-28250112]: Thu Sep  9 18:40:49 2021\n[Thread-28786688]: Thu Sep  9 18:40:49 2021\n[Thread-28786688]: Thu Sep  9 18:40:50 2021\n[Thread-28250112]: Thu Sep  9 18:40:50 2021\n[Thread-27713536]: Thu Sep  9 18:40:50 2021\n[Thread-28786688]: Thu Sep  9 18:40:51 2021\n[Thread-28250112]: Thu Sep  9 18:40:51 2021\n[Thread-27713536]: Thu Sep  9 18:40:51 2021\n[Thread-28786688]: Thu Sep  9 18:40:52 2021\n[Thread-28250112]: Thu Sep  9 18:40:52 2021\n[Thread-27713536]: Thu Sep  9 18:40:52 2021\n[Thread-28786688]: Thu Sep  9 18:40:53 2021\n[Thread-28250112]: Thu Sep  9 18:40:53 2021\n[Thread-27713536]: Thu Sep  9 18:40:53 2021\n[Thread-28250112]: Thu Sep  9 18:40:54 2021\n[Thread-27713536]: Thu Sep  9 18:40:54 2021\n[Thread-28786688]: Thu Sep  9 18:40:54 2021\n[Thread-28250112]: Thu Sep  9 18:40:55 2021\n[Thread-27713536]: Thu Sep  9 18:40:55 2021\n[Thread-28786688]: Thu Sep  9 18:40:55 2021\n[Thread-28250112]: Thu Sep  9 18:40:56 2021\n[Thread-27713536]: Thu Sep  9 18:40:56 2021\n[Thread-28786688]: Thu Sep  9 18:40:56 2021\n[Thread-28786688]: Thu Sep  9 18:40:57 2021\n[Thread-28250112]: Thu Sep  9 18:40:57 2021\n[Thread-27713536]: Thu Sep  9 18:40:57 2021\n[Thread-28786688]: Thu Sep  9 18:40:58 2021\n[Thread-28250112]: Thu Sep  9 18:40:58 2021\n[Thread-27713536]: Thu Sep  9 18:40:58 2021\n[Thread-28786688]: Thu Sep  9 18:41:00 2021\n[Thread-28250112]: Thu Sep  9 18:41:00 2021\n[Thread-27713536]: Thu Sep  9 18:41:00 2021\n[Thread-28786688]: Thu Sep  9 18:41:01 2021\n[Thread-28250112]: Thu Sep  9 18:41:01 2021\n[Thread-27713536]: Thu Sep  9 18:41:01 2021\n[Thread-27713536]: Thu Sep  9 18:41:02 2021\n[Thread-28250112]: Thu Sep  9 18:41:02 2021\n[Thread-28786688]: Thu Sep  9 18:41:02 2021\n[Thread-27713536]: Thu Sep  9 18:41:03 2021\n[Thread-28786688]: Thu Sep  9 18:41:03 2021\n[Thread-28250112]: Thu Sep  9 18:41:03 2021\n[Thread-28250112]: Thu Sep  9 18:41:04 2021\n[Thread-27713536]: Thu Sep  9 18:41:04 2021\n[Thread-28786688]: Thu Sep  9 18:41:04 2021\n[Thread-28250112]: Thu Sep  9 18:41:05 2021\n[Thread-28786688]: Thu Sep  9 18:41:05 2021\n[Thread-27713536]: Thu Sep  9 18:41:05 2021\n[Thread-28250112]: Thu Sep  9 18:41:06 2021\n[Thread-27713536]: Thu Sep  9 18:41:06 2021\n[Thread-28786688]: Thu Sep  9 18:41:06 2021\n[Thread-28786688]: Thu Sep  9 18:41:07 2021\n[Thread-28250112]: Thu Sep  9 18:41:07 2021\n\n$ ^C\n```\n\n\n\n## 其他内容\n\nvscode配置的调试debug只能调试单文件，这次调试就是用的gdb来调试的\n\n编译的时候加入-g参数生成debug信息，然后gdb a.out就可以调试程序了\n\n对于多线程的调试，gdb也是很方便的，具体参考：https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909184526181.png\" alt=\"使用gdb调试\" style=\"zoom:50%;\" />\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909184608119.png\" alt=\"gdb显示所有线程\" style=\"zoom:50%;\" />\n","slug":"unix网络编程-2-实现一个pthread-pool","published":1,"updated":"2021-09-09T10:57:20.329Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktiszmic0006azqpcyzagld4","content":"<p>这次使用C语言，设计一个基于pthread的线程池吧。</p>\n<p>想要设计线程池的原因有三个：</p>\n<ol>\n<li>  想要重新锻炼下C语言的编码能力</li>\n<li>  面试经常出现一些线程池的内容，笔者比较反感这些八股文，所以就简单实现一个线程池好了</li>\n<li>  线程池所谓服务端必不可少的组件，后面继续学习unix网络编程的时候会用到</li>\n</ol>\n<p>在开始之前按照惯例介绍一下环境：</p>\n<ul>\n<li>  macOS 10.15</li>\n<li>  gcc工具链（clang）</li>\n<li>  gdb调试（brew install gdb）</li>\n</ul>\n<h2 id=\"开始设计线程池结构\"><a href=\"#开始设计线程池结构\" class=\"headerlink\" title=\"开始设计线程池结构\"></a>开始设计线程池结构</h2><p>笔者参考了Java提供的ThreadPoolExecutor类，也就是线程池类，当然也顺便研究了一下源码，发现略有点复杂，我们这次就实现一个Fixed_Pool，也就是核心线程就等于工作线程数好了。</p>\n<p>给出线程池pthread_pool的设计图如下：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909182922612.png\" alt=\"pthread_pool设计\" style=\"zoom:50%;\" />\n\n<p>单看图的话还是比较简单的，因为这次写一个固定核心线程数的线程池，比如上图，核心线程数为2，等待队列长度为4，某一时刻，这个线程池能负载的最大任务数为6个（2个正在执行，4个等待执行）</p>\n<p>如果等待队列已满，此时再尝试提交任务的话就会返回-1，代表提交失败。</p>\n<h2 id=\"定义核心结构体\"><a href=\"#定义核心结构体\" class=\"headerlink\" title=\"定义核心结构体\"></a>定义核心结构体</h2><p>从上面的设计图中看到，需要设计的结构有两个：pthread_pool类型和task任务类型</p>\n<p>于是给出下面的设计：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * pthread_pool</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现一个基于pthread的Fixed线程池，创建初期就初始化n个线程，n个核心线程全部活跃</span></span><br><span class=\"line\"><span class=\"comment\"> * 线程池真正可以负载的任务数量t = 线程数量w + 等待队列长度n</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如：一个3核心线程，队列长度为2的线程池，其负载能力最大为5</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> _<span class=\"title\">pthread_pool_state</span> &#123;</span></span><br><span class=\"line\">    RUNNING,   <span class=\"comment\">// 运行</span></span><br><span class=\"line\">    TERMINATED <span class=\"comment\">// 结束</span></span><br><span class=\"line\">&#125; pthread_pool_state;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">pthread_pool_task_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*func)(<span class=\"keyword\">void</span> *); <span class=\"comment\">// 任务函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *args;            <span class=\"comment\">// 函数参数</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">pthread_pool_task_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pthread_pool_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> mutex; <span class=\"comment\">// 内部锁</span></span><br><span class=\"line\">    <span class=\"keyword\">pthread_cond_t</span> cond;   <span class=\"comment\">// 同步条件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> *threads; <span class=\"comment\">// 线程数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> thread_count;   <span class=\"comment\">// 核心线程数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pthread_pool_task_t</span> *task_queue; <span class=\"comment\">// 任务队列</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> task_head;                   <span class=\"comment\">// 头部指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> task_tail;                   <span class=\"comment\">// 尾部指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> task_queue_size;             <span class=\"comment\">// 最大任务队列长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> task_count;                  <span class=\"comment\">// 当前任务数量</span></span><br><span class=\"line\">    pthread_pool_state pool_state;   <span class=\"comment\">// 线程池状态</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SPP struct pthread_pool_t</span></span><br></pre></td></tr></table></figure>\n\n<p>笔者这里额外加了一个state枚举类型来表示线程池当前的执行状态，当然执行状态很简单只有两种：运行中和终止</p>\n<h2 id=\"设计线程池的关键函数\"><a href=\"#设计线程池的关键函数\" class=\"headerlink\" title=\"设计线程池的关键函数\"></a>设计线程池的关键函数</h2><p>对于一个线程池，不难想到有几个核心方法需要设计并且实现：创建、提交任务、核心线程工作函数、关闭、释放资源</p>\n<p>下面给出笔者设计的这5个函数的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">pthread_pool_worker</span><span class=\"params\">(<span class=\"keyword\">void</span> *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_pool_release</span><span class=\"params\">(SPP *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_pool_submit</span><span class=\"params\">(SPP *, <span class=\"keyword\">void</span> *(*)(<span class=\"keyword\">void</span> *), <span class=\"keyword\">void</span> *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_pool_shutdown</span><span class=\"params\">(SPP *)</span></span>;</span><br><span class=\"line\"><span class=\"function\">SPP *<span class=\"title\">pthread_pool_create</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"pthread-pool-create函数实现\"><a href=\"#pthread-pool-create函数实现\" class=\"headerlink\" title=\"pthread_pool_create函数实现\"></a>pthread_pool_create函数实现</h3><p>创建一个线程池，即定义一个结构体对象，然后分配相应的内存，同时初始化其中的一些参数即可。</p>\n<p>因为是核心线程全部运行，所以创建的时候就初始化核心线程数量的工作线程数组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建一个线程池</span></span><br><span class=\"line\"><span class=\"function\">SPP *<span class=\"title\">pthread_pool_create</span><span class=\"params\">(<span class=\"keyword\">int</span> thread_count, <span class=\"keyword\">int</span> queue_size)</span> </span>&#123;</span><br><span class=\"line\">    assert(thread_count &gt; <span class=\"number\">0</span> &amp;&amp; queue_size &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    SPP *tmp = (SPP *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(SPP));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pthread_mutex_init(&amp;tmp-&gt;mutex, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pthread_cond_init(&amp;tmp-&gt;cond, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pthread_attr_t</span> tmp_attr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pthread_attr_init(&amp;tmp_attr) != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp-&gt;thread_count = thread_count;</span><br><span class=\"line\">    tmp-&gt;threads = (<span class=\"keyword\">pthread_t</span> *)<span class=\"built_in\">malloc</span>(thread_count * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">pthread_t</span>));</span><br><span class=\"line\">    tmp-&gt;task_queue_size = queue_size;</span><br><span class=\"line\">    tmp-&gt;task_queue = (<span class=\"keyword\">pthread_pool_task_t</span> *)<span class=\"built_in\">malloc</span>(queue_size * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">pthread_pool_task_t</span>));</span><br><span class=\"line\">    tmp-&gt;task_head = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;task_tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;task_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;pool_state = RUNNING;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置线程退出时自动回收资源</span></span><br><span class=\"line\">    pthread_attr_setdetachstate(&amp;tmp_attr, PTHREAD_CREATE_DETACHED);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tmp-&gt;thread_count; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// printf(&quot;创建%d号线程\\n&quot;, i);</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = pthread_create(&amp;(tmp-&gt;threads[i]), &amp;tmp_attr, pthread_pool_worker, tmp);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">        pthread_pool_shutdown(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"pthread-pool-worker函数实现\"><a href=\"#pthread-pool-worker函数实现\" class=\"headerlink\" title=\"pthread_pool_worker函数实现\"></a>pthread_pool_worker函数实现</h3><p>worker函数是线程池每个内置工作线程不断运行的一个方法，在这个方法里线程不断检查任务队列是否有任务需要完成，否则就阻塞等待被唤醒；如何唤醒呢？当提交任务的时候会通过condition唤醒阻塞的线程检查任务队列执行。</p>\n<ul>\n<li><p>  当确认存在任务需要完成的时候，线程会获取这个任务并且将任务队列头指针后移一位，然后执行这个任务</p>\n</li>\n<li><p>  如果线程池需要关闭，那么worker函数会break退出，同时回收工作线程资源</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程池内置线程处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">pthread_pool_worker</span><span class=\"params\">(<span class=\"keyword\">void</span> *args)</span> </span>&#123;</span><br><span class=\"line\">    SPP *pool = (SPP *)args;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_pool_task_t</span> task;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">        <span class=\"comment\">// 尝试循环获取任务，没有任务就阻塞等待</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pool-&gt;task_count == <span class=\"number\">0</span> &amp;&amp; pool-&gt;pool_state == RUNNING) &#123;</span><br><span class=\"line\">            pthread_cond_wait(&amp;(pool-&gt;cond), &amp;(pool-&gt;mutex));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pool-&gt;pool_state != RUNNING) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        task.func = pool-&gt;task_queue[pool-&gt;task_head].func;</span><br><span class=\"line\">        task.args = pool-&gt;task_queue[pool-&gt;task_head].args;</span><br><span class=\"line\"></span><br><span class=\"line\">        pool-&gt;task_head++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pool-&gt;task_head == pool-&gt;task_queue_size) pool-&gt;task_head = <span class=\"number\">0</span>;</span><br><span class=\"line\">        pool-&gt;task_count--;</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"comment\">// 执行任务</span></span><br><span class=\"line\">        task.func(task.args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"pthread-pool-submit函数实现\"><a href=\"#pthread-pool-submit函数实现\" class=\"headerlink\" title=\"pthread_pool_submit函数实现\"></a>pthread_pool_submit函数实现</h3><p>向线程池中提交一个任务，然后尝试唤醒阻塞等待的工作线程，移动tail指针</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提交一个任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_pool_submit</span><span class=\"params\">(SPP *pool, <span class=\"keyword\">void</span> *(*func)(<span class=\"keyword\">void</span> *), <span class=\"keyword\">void</span> *args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pool || !func) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断下一个tail位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = pool-&gt;task_tail + <span class=\"number\">1</span>;</span><br><span class=\"line\">        pos = ((pos == pool-&gt;task_queue_size) ? <span class=\"number\">0</span> : pos);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pool-&gt;task_queue_size == pool-&gt;task_count) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pool-&gt;pool_state != RUNNING) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        pool-&gt;task_queue[pool-&gt;task_tail].func = func;</span><br><span class=\"line\">        pool-&gt;task_queue[pool-&gt;task_tail].args = args;</span><br><span class=\"line\"></span><br><span class=\"line\">        pool-&gt;task_tail = pos;</span><br><span class=\"line\">        pool-&gt;task_count++;</span><br><span class=\"line\">        pthread_cond_signal(&amp;(pool-&gt;cond));</span><br><span class=\"line\">        flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>);</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"剩余函数实现\"><a href=\"#剩余函数实现\" class=\"headerlink\" title=\"剩余函数实现\"></a>剩余函数实现</h3><p>关闭和回收线程池资源，C语言的动态内存操作需要小心一点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_pool_shutdown</span><span class=\"params\">(SPP *pool)</span> </span>&#123;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pool-&gt;pool_state == RUNNING) &#123;</span><br><span class=\"line\">        pool-&gt;pool_state = TERMINATED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 唤醒所有可能等待的核心线程</span></span><br><span class=\"line\">    pthread_cond_signal(&amp;(pool-&gt;cond));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试取消所有正在运行的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pool-&gt;thread_count; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;尝试取消线程%d...\\n&quot;</span>, i);</span><br><span class=\"line\">        pthread_cancel(pool-&gt;threads[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">    pthread_pool_release(pool);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放线程池资源</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_pool_release</span><span class=\"params\">(SPP *pool)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pool-&gt;threads) <span class=\"built_in\">free</span>(pool-&gt;threads);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pool-&gt;task_queue) <span class=\"built_in\">free</span>(pool-&gt;task_queue);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">    pthread_cond_destroy(&amp;(pool-&gt;cond));</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(pool);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关闭线程池的方法这里是非阻塞的，调用了之后不一定会结束所有正在工作的线程。</p>\n<p>关闭线程池的时候尝试取消正在运行的线程，如果运行线程内部是个死循环并且没有监听取消事件，会造成程序无法结束。</p>\n<h2 id=\"验证线程池功能\"><a href=\"#验证线程池功能\" class=\"headerlink\" title=\"验证线程池功能\"></a>验证线程池功能</h2><p>简单写一个程序验证线程池的功能</p>\n<p>首先给出上面线程池必须依赖的头文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _COMMONS_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _COMMONS_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/msg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>然后简单写一个main.c来测试线程池的功能：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;pool.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;time.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">task</span><span class=\"params\">(<span class=\"keyword\">void</span> *args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> t = time(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[Thread-%d]: %s&quot;</span>, pthread_self(), ctime(&amp;t));</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新建一个线程池</span></span><br><span class=\"line\">    SPP *pool = pthread_pool_create(<span class=\"number\">3</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = pthread_pool_submit(pool, task, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d 号任务提交失败...\\n&quot;</span>, i);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d 号任务提交成功!!!\\n&quot;</span>, i);</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;成功提交任务数量：%d\\n&quot;</span>, cnt);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 主线程阻塞不退出</span></span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试关闭线程池</span></span><br><span class=\"line\">    pthread_pool_shutdown(pool);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里创建了一个核心数量为3，等待队列大小为50的线程池，所以可以得到同一时刻可以提交的最大任务数量是53个任务，其余的任务会提交失败。</p>\n<p>因为核心数量是3，所以同一时刻运行会有3个不同线程执行任务，并且打出当前时间，这里直接给出一部分的输出吧：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cc -g pool.c main.c -lpthread</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./a.out</span></span><br></pre></td></tr></table></figure>\n\n<p>输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 号任务提交成功!!!</span><br><span class=\"line\">2 号任务提交成功!!!</span><br><span class=\"line\">3 号任务提交成功!!!</span><br><span class=\"line\">4 号任务提交成功!!!</span><br><span class=\"line\">5 号任务提交成功!!!</span><br><span class=\"line\">6 号任务提交成功!!!</span><br><span class=\"line\">7 号任务提交成功!!!</span><br><span class=\"line\">8 号任务提交成功!!!</span><br><span class=\"line\">9 号任务提交成功!!!</span><br><span class=\"line\">10 号任务提交成功!!!</span><br><span class=\"line\">11 号任务提交成功!!!</span><br><span class=\"line\">12 号任务提交成功!!!</span><br><span class=\"line\">13 号任务提交成功!!!</span><br><span class=\"line\">14 号任务提交成功!!!</span><br><span class=\"line\">15 号任务提交成功!!!</span><br><span class=\"line\">16 号任务提交成功!!!</span><br><span class=\"line\">17 号任务提交成功!!!</span><br><span class=\"line\">18 号任务提交成功!!!</span><br><span class=\"line\">19 号任务提交成功!!!</span><br><span class=\"line\">20 号任务提交成功!!!</span><br><span class=\"line\">21 号任务提交成功!!!</span><br><span class=\"line\">22 号任务提交成功!!!</span><br><span class=\"line\">23 号任务提交成功!!!</span><br><span class=\"line\">24 号任务提交成功!!!</span><br><span class=\"line\">25 号任务提交成功!!!</span><br><span class=\"line\">26 号任务提交成功!!!</span><br><span class=\"line\">27 号任务提交成功!!!</span><br><span class=\"line\">28 号任务提交成功!!!</span><br><span class=\"line\">29 号任务提交成功!!!</span><br><span class=\"line\">30 号任务提交成功!!!</span><br><span class=\"line\">31 号任务提交成功!!!</span><br><span class=\"line\">32 号任务提交成功!!!</span><br><span class=\"line\">33 号任务提交成功!!!</span><br><span class=\"line\">34 号任务提交成功!!!</span><br><span class=\"line\">35 号任务提交成功!!!</span><br><span class=\"line\">36 号任务提交成功!!!</span><br><span class=\"line\">37 号任务提交成功!!!</span><br><span class=\"line\">38 号任务提交成功!!!</span><br><span class=\"line\">39 号任务提交成功!!!</span><br><span class=\"line\">40 号任务提交成功!!!</span><br><span class=\"line\">41 号任务提交成功!!!</span><br><span class=\"line\">42 号任务提交成功!!!</span><br><span class=\"line\">43 号任务提交成功!!!</span><br><span class=\"line\">44 号任务提交成功!!!</span><br><span class=\"line\">45 号任务提交成功!!!</span><br><span class=\"line\">46 号任务提交成功!!!</span><br><span class=\"line\">47 号任务提交成功!!!</span><br><span class=\"line\">48 号任务提交成功!!!</span><br><span class=\"line\">49 号任务提交成功!!!</span><br><span class=\"line\">50 号任务提交成功!!!</span><br><span class=\"line\">51 号任务提交成功!!!</span><br><span class=\"line\">52 号任务提交成功!!!</span><br><span class=\"line\">53 号任务提交成功!!!</span><br><span class=\"line\">54 号任务提交失败...</span><br><span class=\"line\">55 号任务提交失败...</span><br><span class=\"line\">56 号任务提交失败...</span><br><span class=\"line\">57 号任务提交失败...</span><br><span class=\"line\">58 号任务提交失败...</span><br><span class=\"line\">59 号任务提交失败...</span><br><span class=\"line\">60 号任务提交失败...</span><br><span class=\"line\">61 号任务提交失败...</span><br><span class=\"line\">62 号任务提交失败...</span><br><span class=\"line\">63 号任务提交失败...</span><br><span class=\"line\">64 号任务提交失败...</span><br><span class=\"line\">65 号任务提交失败...</span><br><span class=\"line\">66 号任务提交失败...</span><br><span class=\"line\">67 号任务提交失败...</span><br><span class=\"line\">68 号任务提交失败...</span><br><span class=\"line\">69 号任务提交失败...</span><br><span class=\"line\">70 号任务提交失败...</span><br><span class=\"line\">71 号任务提交失败...</span><br><span class=\"line\">72 号任务提交失败...</span><br><span class=\"line\">73 号任务提交失败...</span><br><span class=\"line\">74 号任务提交失败...</span><br><span class=\"line\">75 号任务提交失败...</span><br><span class=\"line\">76 号任务提交失败...</span><br><span class=\"line\">77 号任务提交失败...</span><br><span class=\"line\">78 号任务提交失败...</span><br><span class=\"line\">79 号任务提交失败...</span><br><span class=\"line\">80 号任务提交失败...</span><br><span class=\"line\">81 号任务提交失败...</span><br><span class=\"line\">82 号任务提交失败...</span><br><span class=\"line\">83 号任务提交失败...</span><br><span class=\"line\">84 号任务提交失败...</span><br><span class=\"line\">85 号任务提交失败...</span><br><span class=\"line\">86 号任务提交失败...</span><br><span class=\"line\">87 号任务提交失败...</span><br><span class=\"line\">88 号任务提交失败...</span><br><span class=\"line\">89 号任务提交失败...</span><br><span class=\"line\">90 号任务提交失败...</span><br><span class=\"line\">91 号任务提交失败...</span><br><span class=\"line\">92 号任务提交失败...</span><br><span class=\"line\">93 号任务提交失败...</span><br><span class=\"line\">94 号任务提交失败...</span><br><span class=\"line\">95 号任务提交失败...</span><br><span class=\"line\">96 号任务提交失败...</span><br><span class=\"line\">97 号任务提交失败...</span><br><span class=\"line\">98 号任务提交失败...</span><br><span class=\"line\">99 号任务提交失败...</span><br><span class=\"line\">100 号任务提交失败...</span><br><span class=\"line\">成功提交任务数量：53</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:49 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:49 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:49 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:50 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:50 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:50 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:51 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:51 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:51 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:52 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:52 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:52 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:53 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:53 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:53 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:54 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:54 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:54 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:55 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:55 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:55 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:56 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:56 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:56 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:57 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:57 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:57 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:58 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:58 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:58 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:00 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:00 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:00 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:01 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:01 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:01 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:02 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:02 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:02 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:03 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:03 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:03 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:04 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:04 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:04 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:05 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:05 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:05 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:06 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:06 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:06 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:07 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:07 2021</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ^C</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"其他内容\"><a href=\"#其他内容\" class=\"headerlink\" title=\"其他内容\"></a>其他内容</h2><p>vscode配置的调试debug只能调试单文件，这次调试就是用的gdb来调试的</p>\n<p>编译的时候加入-g参数生成debug信息，然后gdb a.out就可以调试程序了</p>\n<p>对于多线程的调试，gdb也是很方便的，具体参考：<a href=\"https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html\">https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html</a></p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909184526181.png\" alt=\"使用gdb调试\" style=\"zoom:50%;\" />\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909184608119.png\" alt=\"gdb显示所有线程\" style=\"zoom:50%;\" />\n","site":{"data":{}},"excerpt":"","more":"<p>这次使用C语言，设计一个基于pthread的线程池吧。</p>\n<p>想要设计线程池的原因有三个：</p>\n<ol>\n<li>  想要重新锻炼下C语言的编码能力</li>\n<li>  面试经常出现一些线程池的内容，笔者比较反感这些八股文，所以就简单实现一个线程池好了</li>\n<li>  线程池所谓服务端必不可少的组件，后面继续学习unix网络编程的时候会用到</li>\n</ol>\n<p>在开始之前按照惯例介绍一下环境：</p>\n<ul>\n<li>  macOS 10.15</li>\n<li>  gcc工具链（clang）</li>\n<li>  gdb调试（brew install gdb）</li>\n</ul>\n<h2 id=\"开始设计线程池结构\"><a href=\"#开始设计线程池结构\" class=\"headerlink\" title=\"开始设计线程池结构\"></a>开始设计线程池结构</h2><p>笔者参考了Java提供的ThreadPoolExecutor类，也就是线程池类，当然也顺便研究了一下源码，发现略有点复杂，我们这次就实现一个Fixed_Pool，也就是核心线程就等于工作线程数好了。</p>\n<p>给出线程池pthread_pool的设计图如下：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909182922612.png\" alt=\"pthread_pool设计\" style=\"zoom:50%;\" />\n\n<p>单看图的话还是比较简单的，因为这次写一个固定核心线程数的线程池，比如上图，核心线程数为2，等待队列长度为4，某一时刻，这个线程池能负载的最大任务数为6个（2个正在执行，4个等待执行）</p>\n<p>如果等待队列已满，此时再尝试提交任务的话就会返回-1，代表提交失败。</p>\n<h2 id=\"定义核心结构体\"><a href=\"#定义核心结构体\" class=\"headerlink\" title=\"定义核心结构体\"></a>定义核心结构体</h2><p>从上面的设计图中看到，需要设计的结构有两个：pthread_pool类型和task任务类型</p>\n<p>于是给出下面的设计：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * pthread_pool</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现一个基于pthread的Fixed线程池，创建初期就初始化n个线程，n个核心线程全部活跃</span></span><br><span class=\"line\"><span class=\"comment\"> * 线程池真正可以负载的任务数量t = 线程数量w + 等待队列长度n</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如：一个3核心线程，队列长度为2的线程池，其负载能力最大为5</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">enum</span> _<span class=\"title\">pthread_pool_state</span> &#123;</span></span><br><span class=\"line\">    RUNNING,   <span class=\"comment\">// 运行</span></span><br><span class=\"line\">    TERMINATED <span class=\"comment\">// 结束</span></span><br><span class=\"line\">&#125; pthread_pool_state;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">pthread_pool_task_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *(*func)(<span class=\"keyword\">void</span> *); <span class=\"comment\">// 任务函数</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *args;            <span class=\"comment\">// 函数参数</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">pthread_pool_task_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pthread_pool_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> mutex; <span class=\"comment\">// 内部锁</span></span><br><span class=\"line\">    <span class=\"keyword\">pthread_cond_t</span> cond;   <span class=\"comment\">// 同步条件</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> *threads; <span class=\"comment\">// 线程数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> thread_count;   <span class=\"comment\">// 核心线程数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pthread_pool_task_t</span> *task_queue; <span class=\"comment\">// 任务队列</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> task_head;                   <span class=\"comment\">// 头部指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> task_tail;                   <span class=\"comment\">// 尾部指针</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> task_queue_size;             <span class=\"comment\">// 最大任务队列长度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> task_count;                  <span class=\"comment\">// 当前任务数量</span></span><br><span class=\"line\">    pthread_pool_state pool_state;   <span class=\"comment\">// 线程池状态</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SPP struct pthread_pool_t</span></span><br></pre></td></tr></table></figure>\n\n<p>笔者这里额外加了一个state枚举类型来表示线程池当前的执行状态，当然执行状态很简单只有两种：运行中和终止</p>\n<h2 id=\"设计线程池的关键函数\"><a href=\"#设计线程池的关键函数\" class=\"headerlink\" title=\"设计线程池的关键函数\"></a>设计线程池的关键函数</h2><p>对于一个线程池，不难想到有几个核心方法需要设计并且实现：创建、提交任务、核心线程工作函数、关闭、释放资源</p>\n<p>下面给出笔者设计的这5个函数的定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">pthread_pool_worker</span><span class=\"params\">(<span class=\"keyword\">void</span> *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_pool_release</span><span class=\"params\">(SPP *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_pool_submit</span><span class=\"params\">(SPP *, <span class=\"keyword\">void</span> *(*)(<span class=\"keyword\">void</span> *), <span class=\"keyword\">void</span> *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_pool_shutdown</span><span class=\"params\">(SPP *)</span></span>;</span><br><span class=\"line\"><span class=\"function\">SPP *<span class=\"title\">pthread_pool_create</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"pthread-pool-create函数实现\"><a href=\"#pthread-pool-create函数实现\" class=\"headerlink\" title=\"pthread_pool_create函数实现\"></a>pthread_pool_create函数实现</h3><p>创建一个线程池，即定义一个结构体对象，然后分配相应的内存，同时初始化其中的一些参数即可。</p>\n<p>因为是核心线程全部运行，所以创建的时候就初始化核心线程数量的工作线程数组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建一个线程池</span></span><br><span class=\"line\"><span class=\"function\">SPP *<span class=\"title\">pthread_pool_create</span><span class=\"params\">(<span class=\"keyword\">int</span> thread_count, <span class=\"keyword\">int</span> queue_size)</span> </span>&#123;</span><br><span class=\"line\">    assert(thread_count &gt; <span class=\"number\">0</span> &amp;&amp; queue_size &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    SPP *tmp = (SPP *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(SPP));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pthread_mutex_init(&amp;tmp-&gt;mutex, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pthread_cond_init(&amp;tmp-&gt;cond, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pthread_attr_t</span> tmp_attr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pthread_attr_init(&amp;tmp_attr) != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp-&gt;thread_count = thread_count;</span><br><span class=\"line\">    tmp-&gt;threads = (<span class=\"keyword\">pthread_t</span> *)<span class=\"built_in\">malloc</span>(thread_count * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">pthread_t</span>));</span><br><span class=\"line\">    tmp-&gt;task_queue_size = queue_size;</span><br><span class=\"line\">    tmp-&gt;task_queue = (<span class=\"keyword\">pthread_pool_task_t</span> *)<span class=\"built_in\">malloc</span>(queue_size * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">pthread_pool_task_t</span>));</span><br><span class=\"line\">    tmp-&gt;task_head = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;task_tail = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;task_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;pool_state = RUNNING;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置线程退出时自动回收资源</span></span><br><span class=\"line\">    pthread_attr_setdetachstate(&amp;tmp_attr, PTHREAD_CREATE_DETACHED);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tmp-&gt;thread_count; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// printf(&quot;创建%d号线程\\n&quot;, i);</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = pthread_create(&amp;(tmp-&gt;threads[i]), &amp;tmp_attr, pthread_pool_worker, tmp);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">        pthread_pool_shutdown(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"pthread-pool-worker函数实现\"><a href=\"#pthread-pool-worker函数实现\" class=\"headerlink\" title=\"pthread_pool_worker函数实现\"></a>pthread_pool_worker函数实现</h3><p>worker函数是线程池每个内置工作线程不断运行的一个方法，在这个方法里线程不断检查任务队列是否有任务需要完成，否则就阻塞等待被唤醒；如何唤醒呢？当提交任务的时候会通过condition唤醒阻塞的线程检查任务队列执行。</p>\n<ul>\n<li><p>  当确认存在任务需要完成的时候，线程会获取这个任务并且将任务队列头指针后移一位，然后执行这个任务</p>\n</li>\n<li><p>  如果线程池需要关闭，那么worker函数会break退出，同时回收工作线程资源</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程池内置线程处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">pthread_pool_worker</span><span class=\"params\">(<span class=\"keyword\">void</span> *args)</span> </span>&#123;</span><br><span class=\"line\">    SPP *pool = (SPP *)args;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_pool_task_t</span> task;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">        <span class=\"comment\">// 尝试循环获取任务，没有任务就阻塞等待</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pool-&gt;task_count == <span class=\"number\">0</span> &amp;&amp; pool-&gt;pool_state == RUNNING) &#123;</span><br><span class=\"line\">            pthread_cond_wait(&amp;(pool-&gt;cond), &amp;(pool-&gt;mutex));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pool-&gt;pool_state != RUNNING) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        task.func = pool-&gt;task_queue[pool-&gt;task_head].func;</span><br><span class=\"line\">        task.args = pool-&gt;task_queue[pool-&gt;task_head].args;</span><br><span class=\"line\"></span><br><span class=\"line\">        pool-&gt;task_head++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pool-&gt;task_head == pool-&gt;task_queue_size) pool-&gt;task_head = <span class=\"number\">0</span>;</span><br><span class=\"line\">        pool-&gt;task_count--;</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">\t</span><br><span class=\"line\">        <span class=\"comment\">// 执行任务</span></span><br><span class=\"line\">        task.func(task.args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"pthread-pool-submit函数实现\"><a href=\"#pthread-pool-submit函数实现\" class=\"headerlink\" title=\"pthread_pool_submit函数实现\"></a>pthread_pool_submit函数实现</h3><p>向线程池中提交一个任务，然后尝试唤醒阻塞等待的工作线程，移动tail指针</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提交一个任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_pool_submit</span><span class=\"params\">(SPP *pool, <span class=\"keyword\">void</span> *(*func)(<span class=\"keyword\">void</span> *), <span class=\"keyword\">void</span> *args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!pool || !func) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> flag = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断下一个tail位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos = pool-&gt;task_tail + <span class=\"number\">1</span>;</span><br><span class=\"line\">        pos = ((pos == pool-&gt;task_queue_size) ? <span class=\"number\">0</span> : pos);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pool-&gt;task_queue_size == pool-&gt;task_count) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pool-&gt;pool_state != RUNNING) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        pool-&gt;task_queue[pool-&gt;task_tail].func = func;</span><br><span class=\"line\">        pool-&gt;task_queue[pool-&gt;task_tail].args = args;</span><br><span class=\"line\"></span><br><span class=\"line\">        pool-&gt;task_tail = pos;</span><br><span class=\"line\">        pool-&gt;task_count++;</span><br><span class=\"line\">        pthread_cond_signal(&amp;(pool-&gt;cond));</span><br><span class=\"line\">        flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span>);</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"剩余函数实现\"><a href=\"#剩余函数实现\" class=\"headerlink\" title=\"剩余函数实现\"></a>剩余函数实现</h3><p>关闭和回收线程池资源，C语言的动态内存操作需要小心一点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_pool_shutdown</span><span class=\"params\">(SPP *pool)</span> </span>&#123;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pool-&gt;pool_state == RUNNING) &#123;</span><br><span class=\"line\">        pool-&gt;pool_state = TERMINATED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 唤醒所有可能等待的核心线程</span></span><br><span class=\"line\">    pthread_cond_signal(&amp;(pool-&gt;cond));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试取消所有正在运行的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pool-&gt;thread_count; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;尝试取消线程%d...\\n&quot;</span>, i);</span><br><span class=\"line\">        pthread_cancel(pool-&gt;threads[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_mutex_unlock(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">    pthread_pool_release(pool);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放线程池资源</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_pool_release</span><span class=\"params\">(SPP *pool)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pool-&gt;threads) <span class=\"built_in\">free</span>(pool-&gt;threads);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pool-&gt;task_queue) <span class=\"built_in\">free</span>(pool-&gt;task_queue);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;(pool-&gt;mutex));</span><br><span class=\"line\">    pthread_cond_destroy(&amp;(pool-&gt;cond));</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(pool);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关闭线程池的方法这里是非阻塞的，调用了之后不一定会结束所有正在工作的线程。</p>\n<p>关闭线程池的时候尝试取消正在运行的线程，如果运行线程内部是个死循环并且没有监听取消事件，会造成程序无法结束。</p>\n<h2 id=\"验证线程池功能\"><a href=\"#验证线程池功能\" class=\"headerlink\" title=\"验证线程池功能\"></a>验证线程池功能</h2><p>简单写一个程序验证线程池的功能</p>\n<p>首先给出上面线程池必须依赖的头文件内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _COMMONS_H_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _COMMONS_H_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/msg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>然后简单写一个main.c来测试线程池的功能：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;pool.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;time.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">task</span><span class=\"params\">(<span class=\"keyword\">void</span> *args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">time_t</span> t = time(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[Thread-%d]: %s&quot;</span>, pthread_self(), ctime(&amp;t));</span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新建一个线程池</span></span><br><span class=\"line\">    SPP *pool = pthread_pool_create(<span class=\"number\">3</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = pthread_pool_submit(pool, task, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d 号任务提交失败...\\n&quot;</span>, i);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d 号任务提交成功!!!\\n&quot;</span>, i);</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;成功提交任务数量：%d\\n&quot;</span>, cnt);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 主线程阻塞不退出</span></span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 尝试关闭线程池</span></span><br><span class=\"line\">    pthread_pool_shutdown(pool);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里创建了一个核心数量为3，等待队列大小为50的线程池，所以可以得到同一时刻可以提交的最大任务数量是53个任务，其余的任务会提交失败。</p>\n<p>因为核心数量是3，所以同一时刻运行会有3个不同线程执行任务，并且打出当前时间，这里直接给出一部分的输出吧：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cc -g pool.c main.c -lpthread</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ./a.out</span></span><br></pre></td></tr></table></figure>\n\n<p>输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 号任务提交成功!!!</span><br><span class=\"line\">2 号任务提交成功!!!</span><br><span class=\"line\">3 号任务提交成功!!!</span><br><span class=\"line\">4 号任务提交成功!!!</span><br><span class=\"line\">5 号任务提交成功!!!</span><br><span class=\"line\">6 号任务提交成功!!!</span><br><span class=\"line\">7 号任务提交成功!!!</span><br><span class=\"line\">8 号任务提交成功!!!</span><br><span class=\"line\">9 号任务提交成功!!!</span><br><span class=\"line\">10 号任务提交成功!!!</span><br><span class=\"line\">11 号任务提交成功!!!</span><br><span class=\"line\">12 号任务提交成功!!!</span><br><span class=\"line\">13 号任务提交成功!!!</span><br><span class=\"line\">14 号任务提交成功!!!</span><br><span class=\"line\">15 号任务提交成功!!!</span><br><span class=\"line\">16 号任务提交成功!!!</span><br><span class=\"line\">17 号任务提交成功!!!</span><br><span class=\"line\">18 号任务提交成功!!!</span><br><span class=\"line\">19 号任务提交成功!!!</span><br><span class=\"line\">20 号任务提交成功!!!</span><br><span class=\"line\">21 号任务提交成功!!!</span><br><span class=\"line\">22 号任务提交成功!!!</span><br><span class=\"line\">23 号任务提交成功!!!</span><br><span class=\"line\">24 号任务提交成功!!!</span><br><span class=\"line\">25 号任务提交成功!!!</span><br><span class=\"line\">26 号任务提交成功!!!</span><br><span class=\"line\">27 号任务提交成功!!!</span><br><span class=\"line\">28 号任务提交成功!!!</span><br><span class=\"line\">29 号任务提交成功!!!</span><br><span class=\"line\">30 号任务提交成功!!!</span><br><span class=\"line\">31 号任务提交成功!!!</span><br><span class=\"line\">32 号任务提交成功!!!</span><br><span class=\"line\">33 号任务提交成功!!!</span><br><span class=\"line\">34 号任务提交成功!!!</span><br><span class=\"line\">35 号任务提交成功!!!</span><br><span class=\"line\">36 号任务提交成功!!!</span><br><span class=\"line\">37 号任务提交成功!!!</span><br><span class=\"line\">38 号任务提交成功!!!</span><br><span class=\"line\">39 号任务提交成功!!!</span><br><span class=\"line\">40 号任务提交成功!!!</span><br><span class=\"line\">41 号任务提交成功!!!</span><br><span class=\"line\">42 号任务提交成功!!!</span><br><span class=\"line\">43 号任务提交成功!!!</span><br><span class=\"line\">44 号任务提交成功!!!</span><br><span class=\"line\">45 号任务提交成功!!!</span><br><span class=\"line\">46 号任务提交成功!!!</span><br><span class=\"line\">47 号任务提交成功!!!</span><br><span class=\"line\">48 号任务提交成功!!!</span><br><span class=\"line\">49 号任务提交成功!!!</span><br><span class=\"line\">50 号任务提交成功!!!</span><br><span class=\"line\">51 号任务提交成功!!!</span><br><span class=\"line\">52 号任务提交成功!!!</span><br><span class=\"line\">53 号任务提交成功!!!</span><br><span class=\"line\">54 号任务提交失败...</span><br><span class=\"line\">55 号任务提交失败...</span><br><span class=\"line\">56 号任务提交失败...</span><br><span class=\"line\">57 号任务提交失败...</span><br><span class=\"line\">58 号任务提交失败...</span><br><span class=\"line\">59 号任务提交失败...</span><br><span class=\"line\">60 号任务提交失败...</span><br><span class=\"line\">61 号任务提交失败...</span><br><span class=\"line\">62 号任务提交失败...</span><br><span class=\"line\">63 号任务提交失败...</span><br><span class=\"line\">64 号任务提交失败...</span><br><span class=\"line\">65 号任务提交失败...</span><br><span class=\"line\">66 号任务提交失败...</span><br><span class=\"line\">67 号任务提交失败...</span><br><span class=\"line\">68 号任务提交失败...</span><br><span class=\"line\">69 号任务提交失败...</span><br><span class=\"line\">70 号任务提交失败...</span><br><span class=\"line\">71 号任务提交失败...</span><br><span class=\"line\">72 号任务提交失败...</span><br><span class=\"line\">73 号任务提交失败...</span><br><span class=\"line\">74 号任务提交失败...</span><br><span class=\"line\">75 号任务提交失败...</span><br><span class=\"line\">76 号任务提交失败...</span><br><span class=\"line\">77 号任务提交失败...</span><br><span class=\"line\">78 号任务提交失败...</span><br><span class=\"line\">79 号任务提交失败...</span><br><span class=\"line\">80 号任务提交失败...</span><br><span class=\"line\">81 号任务提交失败...</span><br><span class=\"line\">82 号任务提交失败...</span><br><span class=\"line\">83 号任务提交失败...</span><br><span class=\"line\">84 号任务提交失败...</span><br><span class=\"line\">85 号任务提交失败...</span><br><span class=\"line\">86 号任务提交失败...</span><br><span class=\"line\">87 号任务提交失败...</span><br><span class=\"line\">88 号任务提交失败...</span><br><span class=\"line\">89 号任务提交失败...</span><br><span class=\"line\">90 号任务提交失败...</span><br><span class=\"line\">91 号任务提交失败...</span><br><span class=\"line\">92 号任务提交失败...</span><br><span class=\"line\">93 号任务提交失败...</span><br><span class=\"line\">94 号任务提交失败...</span><br><span class=\"line\">95 号任务提交失败...</span><br><span class=\"line\">96 号任务提交失败...</span><br><span class=\"line\">97 号任务提交失败...</span><br><span class=\"line\">98 号任务提交失败...</span><br><span class=\"line\">99 号任务提交失败...</span><br><span class=\"line\">100 号任务提交失败...</span><br><span class=\"line\">成功提交任务数量：53</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:49 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:49 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:49 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:50 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:50 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:50 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:51 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:51 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:51 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:52 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:52 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:52 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:53 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:53 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:53 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:54 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:54 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:54 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:55 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:55 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:55 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:56 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:56 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:56 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:57 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:57 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:57 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:40:58 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:40:58 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:40:58 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:00 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:00 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:00 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:01 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:01 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:01 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:02 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:02 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:02 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:03 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:03 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:03 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:04 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:04 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:04 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:05 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:05 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:05 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:06 2021</span><br><span class=\"line\">[Thread-27713536]: Thu Sep  9 18:41:06 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:06 2021</span><br><span class=\"line\">[Thread-28786688]: Thu Sep  9 18:41:07 2021</span><br><span class=\"line\">[Thread-28250112]: Thu Sep  9 18:41:07 2021</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> ^C</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"其他内容\"><a href=\"#其他内容\" class=\"headerlink\" title=\"其他内容\"></a>其他内容</h2><p>vscode配置的调试debug只能调试单文件，这次调试就是用的gdb来调试的</p>\n<p>编译的时候加入-g参数生成debug信息，然后gdb a.out就可以调试程序了</p>\n<p>对于多线程的调试，gdb也是很方便的，具体参考：<a href=\"https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html\">https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html</a></p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909184526181.png\" alt=\"使用gdb调试\" style=\"zoom:50%;\" />\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210909184608119.png\" alt=\"gdb显示所有线程\" style=\"zoom:50%;\" />\n"},{"title":"双向链表与LRU、LFU的实现","date":"2021-09-13T14:11:06.000Z","_content":"\n可以说LRU、LFU两种缓存淘汰策略是最近面试中常见的问题了，这次笔者就准备采用双向链表来实现一个LRU和LFU。\n\n## 缓存淘汰策略\n\n缓存淘汰策略：一个缓存系统如果缓存大小达到了上限，如果有新的缓存内容存入时，需要淘汰掉一部分旧的缓存内容，这样才有空间存放缓存数据，同时要保证缓存替换的频率尽量低。\n\n-   FIFO淘汰策略：队列式缓存，前出后进\n-   LRU淘汰策略：空间不足会淘汰掉最近最少使用的缓存\n-   LFU淘汰策略：根据缓存请求次数排序，空间不足会淘汰掉请求次数最少的缓存\n\n\n\n## 实现LRU\n\n实现LRU是经典的题目，这里采用哈希表+双向链表来实现LRU，具体的设计图如下：\n\n![LRU缓存（哈希表+双向链表）](https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913223510931.png)\n\n1.   map中存放(key, 节点指针)，指针指向具体的双线链表节点\n2.   维护一个双向链表，其头部是最近最多使用的缓存，尾部是最近最少使用缓存，如果缓存空间不足，淘汰掉尾部\n3.   每次访问、存入新的缓存，将其放置在双向链表头部，表示刚刚使用\n\n### 定义结构体\n\n哈希表借助STL中的map，定义一个LRU结构体和双向链表节点Node\n\n```c++\n/**\n * LRU缓存，\"最近最少使用\"缓存淘汰策略\n */\n\nstruct Node {\n    int k;\n    int v;\n    Node *prev;\n    Node *next;\n};\n\nstruct LRU {\n    int cap;\t// 总容量\n    int len;\t// 当前容量\n    Node *head;\n    Node *tail;\n    map<int, Node *> cache;\n};\n\nLRU *lru_create(int);\nvoid lru_put(LRU *, int, int);\nint lru_get(LRU *, int);\nvoid lru_destroy(LRU *);\nvoid lru_print(LRU *);\n\nNode *lru_remove_node(LRU *, Node *);\nvoid lru_push_first(LRU *, Node *);\nvoid lru_pop_last(LRU *);\n```\n\n**对于LRU，笔者这里核心实现了下面三个方法：**\n\n1.   **lru_remove_node：移除任意一个节点**\n2.   **lru_push_first：向双向链表首部添加节点**\n3.   **lru_pop_last：移除双向链表最后一个节点**\n\n\n\n### 具体实现\n\n```c++\nLRU *lru_create(int size) {\n    LRU *tmp = (LRU *)malloc(sizeof(LRU));\n    tmp->cache = map<int, Node *>();\n    tmp->cap = size;\n    tmp->len = 0;\n    tmp->head = (Node *)malloc(sizeof(Node));\n    tmp->tail = (Node *)malloc(sizeof(Node));\n    tmp->head->next = tmp->tail;\n    tmp->tail->prev = tmp->head;\n    return tmp;\n}\n\nvoid lru_destroy(LRU *lru) {\n    if (!lru) return;\n    Node *tmp = lru->head;\n    while (tmp) {\n        Node *t = tmp;\n        tmp = tmp->next;\n        free(t);\n    }\n}\n\nvoid lru_put(LRU *lru, int key, int val) {\n    if (!lru) return;\n    if (lru->len >= lru->cap) lru_pop_last(lru);\n    if (lru->cache.find(key) != lru->cache.end()) {\n        Node *tmp = lru->cache[key];\n        tmp = lru_remove_node(lru, tmp);\n        tmp->v = val;\n        lru_push_first(lru, tmp);\n    } else {\n        Node *tmp = (Node *)malloc(sizeof(Node));\n        tmp->k = key;\n        tmp->v = val;\n        lru_push_first(lru, tmp);\n    }\n}\n\nint lru_get(LRU *lru, int key) {\n    if (!lru) return -1;\n    if (lru->cache.find(key) != lru->cache.end()) {\n        Node *tmp = lru_remove_node(lru, lru->cache[key]);\n        lru_push_first(lru, tmp);\n        return tmp->v;\n    }\n    return -1;\n}\n\n// 从双向链表中移除一个节点\nNode *lru_remove_node(LRU *lru, Node *node) {\n    Node *tmp = node->next;\n    node->prev->next = tmp;\n    tmp->prev = node->prev;\n    node->next = NULL;\n    node->prev = NULL;\n    lru->len--;\n    lru->cache.erase(node->k);\n    return node;\n}\n\n// 将节点插入到双向链表头部\nvoid lru_push_first(LRU *lru, Node *node) {\n    if (!lru || !node) return;\n    if (lru->len >= lru->cap) lru_pop_last(lru);\n    Node *tmp = lru->head->next;\n    node->next = tmp;\n    tmp->prev = node;\n    lru->head->next = node;\n    node->prev = lru->head;\n    lru->len++;\n    lru->cache[node->k] = node;\n}\n\n// 移除双向链表的尾部节点\nvoid lru_pop_last(LRU *lru) {\n    if (lru->len <= 0) return;\n    Node *tmp = lru->tail->prev;\n    Node *t = tmp->prev;\n    t->next = lru->tail;\n    lru->tail->prev = t;\n    lru->cache.erase(tmp->k);\n    lru->len--;\n    free(tmp);\n}\n\n// 即时打印缓存内容\nvoid lru_print(LRU *lru) {\n    cout << \"----------\\n\";\n    Node *tmp = lru->head->next;\n    while (tmp != lru->tail) {\n        cout << \"(\" << tmp->k << \", \" << tmp->v << \") \";\n        tmp = tmp->next;\n    }\n    cout << \"\\n\";\n}\n```\n\n\n\n### 验证LRU效果\n\n补充main函数：\n\n```c++\nint main() {\n    LRU *lru = lru_create(3);\n\n    lru_put(lru, 1, 1);\n    lru_print(lru);\n\n    lru_put(lru, 2, 2);\n    lru_print(lru);\n\n    cout << lru_get(lru, 3) << endl;\n    lru_print(lru);\n\n    lru_put(lru, 3, 3);\n    lru_print(lru);\n\n    cout << lru_get(lru, 2) << endl;\n    lru_print(lru);\n\n    cout << lru_get(lru, 2) << endl;\n    lru_print(lru);\n\n    lru_put(lru, 4, 4);\n    lru_print(lru);\n\n    cout << lru_get(lru, 1) << endl;\n    lru_print(lru);\n\n    lru_destroy(lru);\n\n    return 0;\n}\n```\n\n验证一下效果，从左到右是双向链表首至尾的内容：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913224007315.png\" alt=\"LRU执行结果\" style=\"zoom: 67%;\" />\n\n\n\n## 实现LFU\n\n对于LFU，虽然比较好理解，但是实现起来笔者还是需要仔细思考一会的，如果是面试场景下问到LRU之后，很容易连坐扯出LFU，所以这里也思考了一下LFU的实现方式，并且给出的具体实现。\n\n![LFU缓存（哈希表+双向链表）](https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913224436981.png)\n\n这里笔者继续采用一种基于双向链表的实现方式，不同的是每个双向链表节点Node里面需要多出cnt属性来记录访问该Node节点的次数。除此之外，双向链表的头部是急需淘汰的元素，反而尾部是使用次数cnt最多，不需要淘汰的元素\n\n对于哈希表，这里依然采用STL中的map来实现。\n\n\n\n### 定义结构体\n\n和LRU的结构体几乎相同，除了节点多出了cnt属性\n\n```c++\n/**\n * LFU缓存，\"最不经常使用\"缓存淘汰策略\n */\n\nstruct Node {\n    int k;\n    int v;\n    int cnt;\t// 访问次数\n    Node *prev;\n    Node *next;\n};\n\nstruct LFU {\n    int cap;\n    int len;\n    Node *head;\n    Node *tail;\n    map<int, Node *> cache;\n};\n\nLFU *lfu_create(int);\nvoid lfu_put(LFU *, int, int);\nint lfu_get(LFU *, int);\nvoid lfu_destroy(LFU *);\nvoid lfu_print(LFU *);\n\nNode *lfu_insert_node(LFU *, Node *);\nNode *lfu_remove_node(LFU *, Node *);\n```\n\n**对于LFU，笔者这里核心实现了下面两个方法：**\n\n1.   **lru_remove_node：移除任意一个节点**\n2.   **lfu_insert_node：将一个节点插入到双向链表中的合适位置（大于node节点cnt数的第一个节点的左边）**\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913225834248.png\" alt=\"LFU双向链表-插入一个节点\" style=\"zoom:50%;\" />\n\n\n\n### 具体实现\n\n```c++\nLFU *lfu_create(int size) {\n    LFU *tmp = (LFU *)malloc(sizeof(LFU));\n    tmp->head = (Node *)malloc(sizeof(Node));\n    tmp->tail = (Node *)malloc(sizeof(Node));\n    tmp->head->cnt = 0;\n    tmp->tail->cnt = 0;\n    tmp->cap = size;\n    tmp->len = 0;\n    tmp->head->next = tmp->tail;\n    tmp->tail->prev = tmp->head;\n    tmp->cache = map<int, Node *>();\n    return tmp;\n}\n\nvoid lfu_destroy(LFU *lfu) {\n    lfu->cache.clear();\n    Node *tmp = lfu->head;\n    while (tmp) {\n        Node *t = tmp;\n        tmp = tmp->next;\n        free(t);\n    }\n}\n\n// 将一个节点插入到双向链表中的合适位置(大于node节点cnt数的第一个节点的左边)\nNode *lfu_insert_node(LFU *lfu, Node *node) {\n    if (lfu->cap <= lfu->len) {\n        Node *t = lfu_remove_node(lfu, lfu->head->next);\n        free(t);\n    }\n    Node *tmp = lfu->head;\n    while (tmp != lfu->tail && tmp->cnt <= node->cnt) tmp = tmp->next;\n\n    tmp->prev->next = node;\n    node->prev = tmp->prev;\n    node->next = tmp;\n    tmp->prev = node;\n\n    lfu->cache[node->k] = node;\n    lfu->len++;\n    return node;\n}\n\n// 将一个节点从原有双向链表上移除，返回这个移除的节点\nNode *lfu_remove_node(LFU *lfu, Node *node) {\n    if (lfu->len <= 0 || !node) return NULL;\n    node->prev->next = node->next;\n    node->next->prev = node->prev;\n    node->prev = NULL;\n    node->next = NULL;\n    lfu->len--;\n    lfu->cache.erase(node->k);\n    return node;\n}\n\nvoid lfu_put(LFU *lfu, int key, int val) {\n    if (!lfu) return;\n    map<int, Node *> mp = lfu->cache;\n    if (mp.find(key) != mp.end()) {\n        Node *tmp = mp[key];\n        tmp = lfu_remove_node(lfu, tmp);\n        tmp->cnt++;\n        tmp->v = val;\n        lfu_insert_node(lfu, tmp);\n    } else {\n        Node *tmp = (Node *)malloc(sizeof(Node));\n        tmp->cnt = 1;\n        tmp->k = key;\n        tmp->v = val;\n        lfu_insert_node(lfu, tmp);\n    }\n}\n\nint lfu_get(LFU *lfu, int key) {\n    if (!lfu) return -1;\n    if (lfu->cache.find(key) != lfu->cache.end()) {\n        Node *tmp = lfu->cache[key];\n        tmp = lfu_remove_node(lfu, tmp);\n        tmp->cnt++;\n        tmp = lfu_insert_node(lfu, tmp);\n        return tmp->v;\n    }\n    return -1;\n}\n\nvoid lfu_print(LFU *lfu) {\n    cout << \"----------\\n\";\n    Node *tmp = lfu->head->next;\n    while (tmp != lfu->tail) {\n        cout << \"(\" << tmp->k << \", \" << tmp->v << \") -> cnt: \" << tmp->cnt << \"\\n\";\n        tmp = tmp->next;\n    }\n}\n```\n\n\n\n\n\n### 验证LFU效果\n\n定义一个main函数同时调用LFU即可：\n\n```c++\nint main() {\n    LFU *lfu = lfu_create(3);\n\n    lfu_put(lfu, 1, 1);\n    lfu_print(lfu);\n\n    lfu_put(lfu, 2, 2);\n    lfu_print(lfu);\n\n    cout << lfu_get(lfu, 3) << endl;\n    lfu_print(lfu);\n\n    lfu_put(lfu, 3, 3);\n    lfu_print(lfu);\n\n    cout << lfu_get(lfu, 2) << endl;\n    lfu_print(lfu);\n\n    cout << lfu_get(lfu, 2) << endl;\n    lfu_print(lfu);\n\n    lfu_put(lfu, 4, 4);\n    lfu_print(lfu);\n\n    cout << lfu_get(lfu, 1) << endl;\n    lfu_print(lfu);\n\n    lfu_destroy(lfu);\n\n    return 0;\n}\n```\n\n可以看到双向链表内部是根据cnt从小到大排列缓存k-v的：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913225229277.png\" alt=\"LFU效果\" style=\"zoom: 67%;\" />\n\n\n\n## LFU的其他实现方式\n\n上面实现LFU使用的是map+双向链表的方法，每次淘汰双向链表头部的元素。\n\n除此之外，还可以使用优先队列priority_queue来代替双向链表，因为优先队列内部维护了一个二叉队，如果按照cnt元素从小到大维护一个优先队列，每次pop队首元素也是可以的。\n","source":"_posts/双向链表与LRU、LFU的实现.md","raw":"---\ntitle: 双向链表与LRU、LFU的实现\ndate: 2021-09-13 22:11:06\ncategories:\n- 面试\ntags:\n- 数据结构\n- 双向链表\n- LRU缓存策略\n- LFU缓存策略\n---\n\n可以说LRU、LFU两种缓存淘汰策略是最近面试中常见的问题了，这次笔者就准备采用双向链表来实现一个LRU和LFU。\n\n## 缓存淘汰策略\n\n缓存淘汰策略：一个缓存系统如果缓存大小达到了上限，如果有新的缓存内容存入时，需要淘汰掉一部分旧的缓存内容，这样才有空间存放缓存数据，同时要保证缓存替换的频率尽量低。\n\n-   FIFO淘汰策略：队列式缓存，前出后进\n-   LRU淘汰策略：空间不足会淘汰掉最近最少使用的缓存\n-   LFU淘汰策略：根据缓存请求次数排序，空间不足会淘汰掉请求次数最少的缓存\n\n\n\n## 实现LRU\n\n实现LRU是经典的题目，这里采用哈希表+双向链表来实现LRU，具体的设计图如下：\n\n![LRU缓存（哈希表+双向链表）](https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913223510931.png)\n\n1.   map中存放(key, 节点指针)，指针指向具体的双线链表节点\n2.   维护一个双向链表，其头部是最近最多使用的缓存，尾部是最近最少使用缓存，如果缓存空间不足，淘汰掉尾部\n3.   每次访问、存入新的缓存，将其放置在双向链表头部，表示刚刚使用\n\n### 定义结构体\n\n哈希表借助STL中的map，定义一个LRU结构体和双向链表节点Node\n\n```c++\n/**\n * LRU缓存，\"最近最少使用\"缓存淘汰策略\n */\n\nstruct Node {\n    int k;\n    int v;\n    Node *prev;\n    Node *next;\n};\n\nstruct LRU {\n    int cap;\t// 总容量\n    int len;\t// 当前容量\n    Node *head;\n    Node *tail;\n    map<int, Node *> cache;\n};\n\nLRU *lru_create(int);\nvoid lru_put(LRU *, int, int);\nint lru_get(LRU *, int);\nvoid lru_destroy(LRU *);\nvoid lru_print(LRU *);\n\nNode *lru_remove_node(LRU *, Node *);\nvoid lru_push_first(LRU *, Node *);\nvoid lru_pop_last(LRU *);\n```\n\n**对于LRU，笔者这里核心实现了下面三个方法：**\n\n1.   **lru_remove_node：移除任意一个节点**\n2.   **lru_push_first：向双向链表首部添加节点**\n3.   **lru_pop_last：移除双向链表最后一个节点**\n\n\n\n### 具体实现\n\n```c++\nLRU *lru_create(int size) {\n    LRU *tmp = (LRU *)malloc(sizeof(LRU));\n    tmp->cache = map<int, Node *>();\n    tmp->cap = size;\n    tmp->len = 0;\n    tmp->head = (Node *)malloc(sizeof(Node));\n    tmp->tail = (Node *)malloc(sizeof(Node));\n    tmp->head->next = tmp->tail;\n    tmp->tail->prev = tmp->head;\n    return tmp;\n}\n\nvoid lru_destroy(LRU *lru) {\n    if (!lru) return;\n    Node *tmp = lru->head;\n    while (tmp) {\n        Node *t = tmp;\n        tmp = tmp->next;\n        free(t);\n    }\n}\n\nvoid lru_put(LRU *lru, int key, int val) {\n    if (!lru) return;\n    if (lru->len >= lru->cap) lru_pop_last(lru);\n    if (lru->cache.find(key) != lru->cache.end()) {\n        Node *tmp = lru->cache[key];\n        tmp = lru_remove_node(lru, tmp);\n        tmp->v = val;\n        lru_push_first(lru, tmp);\n    } else {\n        Node *tmp = (Node *)malloc(sizeof(Node));\n        tmp->k = key;\n        tmp->v = val;\n        lru_push_first(lru, tmp);\n    }\n}\n\nint lru_get(LRU *lru, int key) {\n    if (!lru) return -1;\n    if (lru->cache.find(key) != lru->cache.end()) {\n        Node *tmp = lru_remove_node(lru, lru->cache[key]);\n        lru_push_first(lru, tmp);\n        return tmp->v;\n    }\n    return -1;\n}\n\n// 从双向链表中移除一个节点\nNode *lru_remove_node(LRU *lru, Node *node) {\n    Node *tmp = node->next;\n    node->prev->next = tmp;\n    tmp->prev = node->prev;\n    node->next = NULL;\n    node->prev = NULL;\n    lru->len--;\n    lru->cache.erase(node->k);\n    return node;\n}\n\n// 将节点插入到双向链表头部\nvoid lru_push_first(LRU *lru, Node *node) {\n    if (!lru || !node) return;\n    if (lru->len >= lru->cap) lru_pop_last(lru);\n    Node *tmp = lru->head->next;\n    node->next = tmp;\n    tmp->prev = node;\n    lru->head->next = node;\n    node->prev = lru->head;\n    lru->len++;\n    lru->cache[node->k] = node;\n}\n\n// 移除双向链表的尾部节点\nvoid lru_pop_last(LRU *lru) {\n    if (lru->len <= 0) return;\n    Node *tmp = lru->tail->prev;\n    Node *t = tmp->prev;\n    t->next = lru->tail;\n    lru->tail->prev = t;\n    lru->cache.erase(tmp->k);\n    lru->len--;\n    free(tmp);\n}\n\n// 即时打印缓存内容\nvoid lru_print(LRU *lru) {\n    cout << \"----------\\n\";\n    Node *tmp = lru->head->next;\n    while (tmp != lru->tail) {\n        cout << \"(\" << tmp->k << \", \" << tmp->v << \") \";\n        tmp = tmp->next;\n    }\n    cout << \"\\n\";\n}\n```\n\n\n\n### 验证LRU效果\n\n补充main函数：\n\n```c++\nint main() {\n    LRU *lru = lru_create(3);\n\n    lru_put(lru, 1, 1);\n    lru_print(lru);\n\n    lru_put(lru, 2, 2);\n    lru_print(lru);\n\n    cout << lru_get(lru, 3) << endl;\n    lru_print(lru);\n\n    lru_put(lru, 3, 3);\n    lru_print(lru);\n\n    cout << lru_get(lru, 2) << endl;\n    lru_print(lru);\n\n    cout << lru_get(lru, 2) << endl;\n    lru_print(lru);\n\n    lru_put(lru, 4, 4);\n    lru_print(lru);\n\n    cout << lru_get(lru, 1) << endl;\n    lru_print(lru);\n\n    lru_destroy(lru);\n\n    return 0;\n}\n```\n\n验证一下效果，从左到右是双向链表首至尾的内容：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913224007315.png\" alt=\"LRU执行结果\" style=\"zoom: 67%;\" />\n\n\n\n## 实现LFU\n\n对于LFU，虽然比较好理解，但是实现起来笔者还是需要仔细思考一会的，如果是面试场景下问到LRU之后，很容易连坐扯出LFU，所以这里也思考了一下LFU的实现方式，并且给出的具体实现。\n\n![LFU缓存（哈希表+双向链表）](https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913224436981.png)\n\n这里笔者继续采用一种基于双向链表的实现方式，不同的是每个双向链表节点Node里面需要多出cnt属性来记录访问该Node节点的次数。除此之外，双向链表的头部是急需淘汰的元素，反而尾部是使用次数cnt最多，不需要淘汰的元素\n\n对于哈希表，这里依然采用STL中的map来实现。\n\n\n\n### 定义结构体\n\n和LRU的结构体几乎相同，除了节点多出了cnt属性\n\n```c++\n/**\n * LFU缓存，\"最不经常使用\"缓存淘汰策略\n */\n\nstruct Node {\n    int k;\n    int v;\n    int cnt;\t// 访问次数\n    Node *prev;\n    Node *next;\n};\n\nstruct LFU {\n    int cap;\n    int len;\n    Node *head;\n    Node *tail;\n    map<int, Node *> cache;\n};\n\nLFU *lfu_create(int);\nvoid lfu_put(LFU *, int, int);\nint lfu_get(LFU *, int);\nvoid lfu_destroy(LFU *);\nvoid lfu_print(LFU *);\n\nNode *lfu_insert_node(LFU *, Node *);\nNode *lfu_remove_node(LFU *, Node *);\n```\n\n**对于LFU，笔者这里核心实现了下面两个方法：**\n\n1.   **lru_remove_node：移除任意一个节点**\n2.   **lfu_insert_node：将一个节点插入到双向链表中的合适位置（大于node节点cnt数的第一个节点的左边）**\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913225834248.png\" alt=\"LFU双向链表-插入一个节点\" style=\"zoom:50%;\" />\n\n\n\n### 具体实现\n\n```c++\nLFU *lfu_create(int size) {\n    LFU *tmp = (LFU *)malloc(sizeof(LFU));\n    tmp->head = (Node *)malloc(sizeof(Node));\n    tmp->tail = (Node *)malloc(sizeof(Node));\n    tmp->head->cnt = 0;\n    tmp->tail->cnt = 0;\n    tmp->cap = size;\n    tmp->len = 0;\n    tmp->head->next = tmp->tail;\n    tmp->tail->prev = tmp->head;\n    tmp->cache = map<int, Node *>();\n    return tmp;\n}\n\nvoid lfu_destroy(LFU *lfu) {\n    lfu->cache.clear();\n    Node *tmp = lfu->head;\n    while (tmp) {\n        Node *t = tmp;\n        tmp = tmp->next;\n        free(t);\n    }\n}\n\n// 将一个节点插入到双向链表中的合适位置(大于node节点cnt数的第一个节点的左边)\nNode *lfu_insert_node(LFU *lfu, Node *node) {\n    if (lfu->cap <= lfu->len) {\n        Node *t = lfu_remove_node(lfu, lfu->head->next);\n        free(t);\n    }\n    Node *tmp = lfu->head;\n    while (tmp != lfu->tail && tmp->cnt <= node->cnt) tmp = tmp->next;\n\n    tmp->prev->next = node;\n    node->prev = tmp->prev;\n    node->next = tmp;\n    tmp->prev = node;\n\n    lfu->cache[node->k] = node;\n    lfu->len++;\n    return node;\n}\n\n// 将一个节点从原有双向链表上移除，返回这个移除的节点\nNode *lfu_remove_node(LFU *lfu, Node *node) {\n    if (lfu->len <= 0 || !node) return NULL;\n    node->prev->next = node->next;\n    node->next->prev = node->prev;\n    node->prev = NULL;\n    node->next = NULL;\n    lfu->len--;\n    lfu->cache.erase(node->k);\n    return node;\n}\n\nvoid lfu_put(LFU *lfu, int key, int val) {\n    if (!lfu) return;\n    map<int, Node *> mp = lfu->cache;\n    if (mp.find(key) != mp.end()) {\n        Node *tmp = mp[key];\n        tmp = lfu_remove_node(lfu, tmp);\n        tmp->cnt++;\n        tmp->v = val;\n        lfu_insert_node(lfu, tmp);\n    } else {\n        Node *tmp = (Node *)malloc(sizeof(Node));\n        tmp->cnt = 1;\n        tmp->k = key;\n        tmp->v = val;\n        lfu_insert_node(lfu, tmp);\n    }\n}\n\nint lfu_get(LFU *lfu, int key) {\n    if (!lfu) return -1;\n    if (lfu->cache.find(key) != lfu->cache.end()) {\n        Node *tmp = lfu->cache[key];\n        tmp = lfu_remove_node(lfu, tmp);\n        tmp->cnt++;\n        tmp = lfu_insert_node(lfu, tmp);\n        return tmp->v;\n    }\n    return -1;\n}\n\nvoid lfu_print(LFU *lfu) {\n    cout << \"----------\\n\";\n    Node *tmp = lfu->head->next;\n    while (tmp != lfu->tail) {\n        cout << \"(\" << tmp->k << \", \" << tmp->v << \") -> cnt: \" << tmp->cnt << \"\\n\";\n        tmp = tmp->next;\n    }\n}\n```\n\n\n\n\n\n### 验证LFU效果\n\n定义一个main函数同时调用LFU即可：\n\n```c++\nint main() {\n    LFU *lfu = lfu_create(3);\n\n    lfu_put(lfu, 1, 1);\n    lfu_print(lfu);\n\n    lfu_put(lfu, 2, 2);\n    lfu_print(lfu);\n\n    cout << lfu_get(lfu, 3) << endl;\n    lfu_print(lfu);\n\n    lfu_put(lfu, 3, 3);\n    lfu_print(lfu);\n\n    cout << lfu_get(lfu, 2) << endl;\n    lfu_print(lfu);\n\n    cout << lfu_get(lfu, 2) << endl;\n    lfu_print(lfu);\n\n    lfu_put(lfu, 4, 4);\n    lfu_print(lfu);\n\n    cout << lfu_get(lfu, 1) << endl;\n    lfu_print(lfu);\n\n    lfu_destroy(lfu);\n\n    return 0;\n}\n```\n\n可以看到双向链表内部是根据cnt从小到大排列缓存k-v的：\n\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913225229277.png\" alt=\"LFU效果\" style=\"zoom: 67%;\" />\n\n\n\n## LFU的其他实现方式\n\n上面实现LFU使用的是map+双向链表的方法，每次淘汰双向链表头部的元素。\n\n除此之外，还可以使用优先队列priority_queue来代替双向链表，因为优先队列内部维护了一个二叉队，如果按照cnt元素从小到大维护一个优先队列，每次pop队首元素也是可以的。\n","slug":"双向链表与LRU、LFU的实现","published":1,"updated":"2021-09-13T15:00:25.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktiszmid0007azqp6cjc27os","content":"<p>可以说LRU、LFU两种缓存淘汰策略是最近面试中常见的问题了，这次笔者就准备采用双向链表来实现一个LRU和LFU。</p>\n<h2 id=\"缓存淘汰策略\"><a href=\"#缓存淘汰策略\" class=\"headerlink\" title=\"缓存淘汰策略\"></a>缓存淘汰策略</h2><p>缓存淘汰策略：一个缓存系统如果缓存大小达到了上限，如果有新的缓存内容存入时，需要淘汰掉一部分旧的缓存内容，这样才有空间存放缓存数据，同时要保证缓存替换的频率尽量低。</p>\n<ul>\n<li>  FIFO淘汰策略：队列式缓存，前出后进</li>\n<li>  LRU淘汰策略：空间不足会淘汰掉最近最少使用的缓存</li>\n<li>  LFU淘汰策略：根据缓存请求次数排序，空间不足会淘汰掉请求次数最少的缓存</li>\n</ul>\n<h2 id=\"实现LRU\"><a href=\"#实现LRU\" class=\"headerlink\" title=\"实现LRU\"></a>实现LRU</h2><p>实现LRU是经典的题目，这里采用哈希表+双向链表来实现LRU，具体的设计图如下：</p>\n<p><img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913223510931.png\" alt=\"LRU缓存（哈希表+双向链表）\"></p>\n<ol>\n<li>  map中存放(key, 节点指针)，指针指向具体的双线链表节点</li>\n<li>  维护一个双向链表，其头部是最近最多使用的缓存，尾部是最近最少使用缓存，如果缓存空间不足，淘汰掉尾部</li>\n<li>  每次访问、存入新的缓存，将其放置在双向链表头部，表示刚刚使用</li>\n</ol>\n<h3 id=\"定义结构体\"><a href=\"#定义结构体\" class=\"headerlink\" title=\"定义结构体\"></a>定义结构体</h3><p>哈希表借助STL中的map，定义一个LRU结构体和双向链表节点Node</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * LRU缓存，&quot;最近最少使用&quot;缓存淘汰策略</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    Node *prev;</span><br><span class=\"line\">    Node *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LRU</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cap;\t<span class=\"comment\">// 总容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;\t<span class=\"comment\">// 当前容量</span></span><br><span class=\"line\">    Node *head;</span><br><span class=\"line\">    Node *tail;</span><br><span class=\"line\">    map&lt;<span class=\"keyword\">int</span>, Node *&gt; cache;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LRU *<span class=\"title\">lru_create</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_put</span><span class=\"params\">(LRU *, <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lru_get</span><span class=\"params\">(LRU *, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_destroy</span><span class=\"params\">(LRU *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_print</span><span class=\"params\">(LRU *)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lru_remove_node</span><span class=\"params\">(LRU *, Node *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_push_first</span><span class=\"params\">(LRU *, Node *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_pop_last</span><span class=\"params\">(LRU *)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>对于LRU，笔者这里核心实现了下面三个方法：</strong></p>\n<ol>\n<li>  <strong>lru_remove_node：移除任意一个节点</strong></li>\n<li>  <strong>lru_push_first：向双向链表首部添加节点</strong></li>\n<li>  <strong>lru_pop_last：移除双向链表最后一个节点</strong></li>\n</ol>\n<h3 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LRU *<span class=\"title\">lru_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    LRU *tmp = (LRU *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(LRU));</span><br><span class=\"line\">    tmp-&gt;cache = map&lt;<span class=\"keyword\">int</span>, Node *&gt;();</span><br><span class=\"line\">    tmp-&gt;cap = size;</span><br><span class=\"line\">    tmp-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;head = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">    tmp-&gt;tail = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">    tmp-&gt;head-&gt;next = tmp-&gt;tail;</span><br><span class=\"line\">    tmp-&gt;tail-&gt;prev = tmp-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_destroy</span><span class=\"params\">(LRU *lru)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lru) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Node *tmp = lru-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp) &#123;</span><br><span class=\"line\">        Node *t = tmp;</span><br><span class=\"line\">        tmp = tmp-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_put</span><span class=\"params\">(LRU *lru, <span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lru) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lru-&gt;len &gt;= lru-&gt;cap) <span class=\"built_in\">lru_pop_last</span>(lru);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lru-&gt;cache.<span class=\"built_in\">find</span>(key) != lru-&gt;cache.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">        Node *tmp = lru-&gt;cache[key];</span><br><span class=\"line\">        tmp = <span class=\"built_in\">lru_remove_node</span>(lru, tmp);</span><br><span class=\"line\">        tmp-&gt;v = val;</span><br><span class=\"line\">        <span class=\"built_in\">lru_push_first</span>(lru, tmp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node *tmp = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">        tmp-&gt;k = key;</span><br><span class=\"line\">        tmp-&gt;v = val;</span><br><span class=\"line\">        <span class=\"built_in\">lru_push_first</span>(lru, tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lru_get</span><span class=\"params\">(LRU *lru, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lru) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lru-&gt;cache.<span class=\"built_in\">find</span>(key) != lru-&gt;cache.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">        Node *tmp = <span class=\"built_in\">lru_remove_node</span>(lru, lru-&gt;cache[key]);</span><br><span class=\"line\">        <span class=\"built_in\">lru_push_first</span>(lru, tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp-&gt;v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从双向链表中移除一个节点</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lru_remove_node</span><span class=\"params\">(LRU *lru, Node *node)</span> </span>&#123;</span><br><span class=\"line\">    Node *tmp = node-&gt;next;</span><br><span class=\"line\">    node-&gt;prev-&gt;next = tmp;</span><br><span class=\"line\">    tmp-&gt;prev = node-&gt;prev;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    lru-&gt;len--;</span><br><span class=\"line\">    lru-&gt;cache.<span class=\"built_in\">erase</span>(node-&gt;k);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将节点插入到双向链表头部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_push_first</span><span class=\"params\">(LRU *lru, Node *node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lru || !node) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lru-&gt;len &gt;= lru-&gt;cap) <span class=\"built_in\">lru_pop_last</span>(lru);</span><br><span class=\"line\">    Node *tmp = lru-&gt;head-&gt;next;</span><br><span class=\"line\">    node-&gt;next = tmp;</span><br><span class=\"line\">    tmp-&gt;prev = node;</span><br><span class=\"line\">    lru-&gt;head-&gt;next = node;</span><br><span class=\"line\">    node-&gt;prev = lru-&gt;head;</span><br><span class=\"line\">    lru-&gt;len++;</span><br><span class=\"line\">    lru-&gt;cache[node-&gt;k] = node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 移除双向链表的尾部节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_pop_last</span><span class=\"params\">(LRU *lru)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lru-&gt;len &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Node *tmp = lru-&gt;tail-&gt;prev;</span><br><span class=\"line\">    Node *t = tmp-&gt;prev;</span><br><span class=\"line\">    t-&gt;next = lru-&gt;tail;</span><br><span class=\"line\">    lru-&gt;tail-&gt;prev = t;</span><br><span class=\"line\">    lru-&gt;cache.<span class=\"built_in\">erase</span>(tmp-&gt;k);</span><br><span class=\"line\">    lru-&gt;len--;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 即时打印缓存内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_print</span><span class=\"params\">(LRU *lru)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;----------\\n&quot;</span>;</span><br><span class=\"line\">    Node *tmp = lru-&gt;head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp != lru-&gt;tail) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; tmp-&gt;k &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; tmp-&gt;v &lt;&lt; <span class=\"string\">&quot;) &quot;</span>;</span><br><span class=\"line\">        tmp = tmp-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"验证LRU效果\"><a href=\"#验证LRU效果\" class=\"headerlink\" title=\"验证LRU效果\"></a>验证LRU效果</h3><p>补充main函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LRU *lru = <span class=\"built_in\">lru_create</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lru_put</span>(lru, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lru_put</span>(lru, <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lru_get</span>(lru, <span class=\"number\">3</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lru_put</span>(lru, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lru_get</span>(lru, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lru_get</span>(lru, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lru_put</span>(lru, <span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lru_get</span>(lru, <span class=\"number\">1</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lru_destroy</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>验证一下效果，从左到右是双向链表首至尾的内容：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913224007315.png\" alt=\"LRU执行结果\" style=\"zoom: 67%;\" />\n\n\n\n<h2 id=\"实现LFU\"><a href=\"#实现LFU\" class=\"headerlink\" title=\"实现LFU\"></a>实现LFU</h2><p>对于LFU，虽然比较好理解，但是实现起来笔者还是需要仔细思考一会的，如果是面试场景下问到LRU之后，很容易连坐扯出LFU，所以这里也思考了一下LFU的实现方式，并且给出的具体实现。</p>\n<p><img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913224436981.png\" alt=\"LFU缓存（哈希表+双向链表）\"></p>\n<p>这里笔者继续采用一种基于双向链表的实现方式，不同的是每个双向链表节点Node里面需要多出cnt属性来记录访问该Node节点的次数。除此之外，双向链表的头部是急需淘汰的元素，反而尾部是使用次数cnt最多，不需要淘汰的元素</p>\n<p>对于哈希表，这里依然采用STL中的map来实现。</p>\n<h3 id=\"定义结构体-1\"><a href=\"#定义结构体-1\" class=\"headerlink\" title=\"定义结构体\"></a>定义结构体</h3><p>和LRU的结构体几乎相同，除了节点多出了cnt属性</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * LFU缓存，&quot;最不经常使用&quot;缓存淘汰策略</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt;\t<span class=\"comment\">// 访问次数</span></span><br><span class=\"line\">    Node *prev;</span><br><span class=\"line\">    Node *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LFU</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cap;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    Node *head;</span><br><span class=\"line\">    Node *tail;</span><br><span class=\"line\">    map&lt;<span class=\"keyword\">int</span>, Node *&gt; cache;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LFU *<span class=\"title\">lfu_create</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_put</span><span class=\"params\">(LFU *, <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lfu_get</span><span class=\"params\">(LFU *, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_destroy</span><span class=\"params\">(LFU *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_print</span><span class=\"params\">(LFU *)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lfu_insert_node</span><span class=\"params\">(LFU *, Node *)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lfu_remove_node</span><span class=\"params\">(LFU *, Node *)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>对于LFU，笔者这里核心实现了下面两个方法：</strong></p>\n<ol>\n<li>  <strong>lru_remove_node：移除任意一个节点</strong></li>\n<li>  <strong>lfu_insert_node：将一个节点插入到双向链表中的合适位置（大于node节点cnt数的第一个节点的左边）</strong></li>\n</ol>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913225834248.png\" alt=\"LFU双向链表-插入一个节点\" style=\"zoom:50%;\" />\n\n\n\n<h3 id=\"具体实现-1\"><a href=\"#具体实现-1\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LFU *<span class=\"title\">lfu_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    LFU *tmp = (LFU *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(LFU));</span><br><span class=\"line\">    tmp-&gt;head = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">    tmp-&gt;tail = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">    tmp-&gt;head-&gt;cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;tail-&gt;cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;cap = size;</span><br><span class=\"line\">    tmp-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;head-&gt;next = tmp-&gt;tail;</span><br><span class=\"line\">    tmp-&gt;tail-&gt;prev = tmp-&gt;head;</span><br><span class=\"line\">    tmp-&gt;cache = map&lt;<span class=\"keyword\">int</span>, Node *&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_destroy</span><span class=\"params\">(LFU *lfu)</span> </span>&#123;</span><br><span class=\"line\">    lfu-&gt;cache.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    Node *tmp = lfu-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp) &#123;</span><br><span class=\"line\">        Node *t = tmp;</span><br><span class=\"line\">        tmp = tmp-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将一个节点插入到双向链表中的合适位置(大于node节点cnt数的第一个节点的左边)</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lfu_insert_node</span><span class=\"params\">(LFU *lfu, Node *node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lfu-&gt;cap &lt;= lfu-&gt;len) &#123;</span><br><span class=\"line\">        Node *t = <span class=\"built_in\">lfu_remove_node</span>(lfu, lfu-&gt;head-&gt;next);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node *tmp = lfu-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp != lfu-&gt;tail &amp;&amp; tmp-&gt;cnt &lt;= node-&gt;cnt) tmp = tmp-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp-&gt;prev-&gt;next = node;</span><br><span class=\"line\">    node-&gt;prev = tmp-&gt;prev;</span><br><span class=\"line\">    node-&gt;next = tmp;</span><br><span class=\"line\">    tmp-&gt;prev = node;</span><br><span class=\"line\"></span><br><span class=\"line\">    lfu-&gt;cache[node-&gt;k] = node;</span><br><span class=\"line\">    lfu-&gt;len++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将一个节点从原有双向链表上移除，返回这个移除的节点</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lfu_remove_node</span><span class=\"params\">(LFU *lfu, Node *node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lfu-&gt;len &lt;= <span class=\"number\">0</span> || !node) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class=\"line\">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class=\"line\">    node-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    lfu-&gt;len--;</span><br><span class=\"line\">    lfu-&gt;cache.<span class=\"built_in\">erase</span>(node-&gt;k);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_put</span><span class=\"params\">(LFU *lfu, <span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lfu) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    map&lt;<span class=\"keyword\">int</span>, Node *&gt; mp = lfu-&gt;cache;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mp.<span class=\"built_in\">find</span>(key) != mp.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">        Node *tmp = mp[key];</span><br><span class=\"line\">        tmp = <span class=\"built_in\">lfu_remove_node</span>(lfu, tmp);</span><br><span class=\"line\">        tmp-&gt;cnt++;</span><br><span class=\"line\">        tmp-&gt;v = val;</span><br><span class=\"line\">        <span class=\"built_in\">lfu_insert_node</span>(lfu, tmp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node *tmp = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">        tmp-&gt;cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">        tmp-&gt;k = key;</span><br><span class=\"line\">        tmp-&gt;v = val;</span><br><span class=\"line\">        <span class=\"built_in\">lfu_insert_node</span>(lfu, tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lfu_get</span><span class=\"params\">(LFU *lfu, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lfu) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lfu-&gt;cache.<span class=\"built_in\">find</span>(key) != lfu-&gt;cache.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">        Node *tmp = lfu-&gt;cache[key];</span><br><span class=\"line\">        tmp = <span class=\"built_in\">lfu_remove_node</span>(lfu, tmp);</span><br><span class=\"line\">        tmp-&gt;cnt++;</span><br><span class=\"line\">        tmp = <span class=\"built_in\">lfu_insert_node</span>(lfu, tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp-&gt;v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_print</span><span class=\"params\">(LFU *lfu)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;----------\\n&quot;</span>;</span><br><span class=\"line\">    Node *tmp = lfu-&gt;head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp != lfu-&gt;tail) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; tmp-&gt;k &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; tmp-&gt;v &lt;&lt; <span class=\"string\">&quot;) -&gt; cnt: &quot;</span> &lt;&lt; tmp-&gt;cnt &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">        tmp = tmp-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"验证LFU效果\"><a href=\"#验证LFU效果\" class=\"headerlink\" title=\"验证LFU效果\"></a>验证LFU效果</h3><p>定义一个main函数同时调用LFU即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LFU *lfu = <span class=\"built_in\">lfu_create</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lfu_put</span>(lfu, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lfu_put</span>(lfu, <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lfu_get</span>(lfu, <span class=\"number\">3</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lfu_put</span>(lfu, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lfu_get</span>(lfu, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lfu_get</span>(lfu, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lfu_put</span>(lfu, <span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lfu_get</span>(lfu, <span class=\"number\">1</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lfu_destroy</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到双向链表内部是根据cnt从小到大排列缓存k-v的：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913225229277.png\" alt=\"LFU效果\" style=\"zoom: 67%;\" />\n\n\n\n<h2 id=\"LFU的其他实现方式\"><a href=\"#LFU的其他实现方式\" class=\"headerlink\" title=\"LFU的其他实现方式\"></a>LFU的其他实现方式</h2><p>上面实现LFU使用的是map+双向链表的方法，每次淘汰双向链表头部的元素。</p>\n<p>除此之外，还可以使用优先队列priority_queue来代替双向链表，因为优先队列内部维护了一个二叉队，如果按照cnt元素从小到大维护一个优先队列，每次pop队首元素也是可以的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>可以说LRU、LFU两种缓存淘汰策略是最近面试中常见的问题了，这次笔者就准备采用双向链表来实现一个LRU和LFU。</p>\n<h2 id=\"缓存淘汰策略\"><a href=\"#缓存淘汰策略\" class=\"headerlink\" title=\"缓存淘汰策略\"></a>缓存淘汰策略</h2><p>缓存淘汰策略：一个缓存系统如果缓存大小达到了上限，如果有新的缓存内容存入时，需要淘汰掉一部分旧的缓存内容，这样才有空间存放缓存数据，同时要保证缓存替换的频率尽量低。</p>\n<ul>\n<li>  FIFO淘汰策略：队列式缓存，前出后进</li>\n<li>  LRU淘汰策略：空间不足会淘汰掉最近最少使用的缓存</li>\n<li>  LFU淘汰策略：根据缓存请求次数排序，空间不足会淘汰掉请求次数最少的缓存</li>\n</ul>\n<h2 id=\"实现LRU\"><a href=\"#实现LRU\" class=\"headerlink\" title=\"实现LRU\"></a>实现LRU</h2><p>实现LRU是经典的题目，这里采用哈希表+双向链表来实现LRU，具体的设计图如下：</p>\n<p><img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913223510931.png\" alt=\"LRU缓存（哈希表+双向链表）\"></p>\n<ol>\n<li>  map中存放(key, 节点指针)，指针指向具体的双线链表节点</li>\n<li>  维护一个双向链表，其头部是最近最多使用的缓存，尾部是最近最少使用缓存，如果缓存空间不足，淘汰掉尾部</li>\n<li>  每次访问、存入新的缓存，将其放置在双向链表头部，表示刚刚使用</li>\n</ol>\n<h3 id=\"定义结构体\"><a href=\"#定义结构体\" class=\"headerlink\" title=\"定义结构体\"></a>定义结构体</h3><p>哈希表借助STL中的map，定义一个LRU结构体和双向链表节点Node</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * LRU缓存，&quot;最近最少使用&quot;缓存淘汰策略</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    Node *prev;</span><br><span class=\"line\">    Node *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LRU</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cap;\t<span class=\"comment\">// 总容量</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;\t<span class=\"comment\">// 当前容量</span></span><br><span class=\"line\">    Node *head;</span><br><span class=\"line\">    Node *tail;</span><br><span class=\"line\">    map&lt;<span class=\"keyword\">int</span>, Node *&gt; cache;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LRU *<span class=\"title\">lru_create</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_put</span><span class=\"params\">(LRU *, <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lru_get</span><span class=\"params\">(LRU *, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_destroy</span><span class=\"params\">(LRU *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_print</span><span class=\"params\">(LRU *)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lru_remove_node</span><span class=\"params\">(LRU *, Node *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_push_first</span><span class=\"params\">(LRU *, Node *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_pop_last</span><span class=\"params\">(LRU *)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>对于LRU，笔者这里核心实现了下面三个方法：</strong></p>\n<ol>\n<li>  <strong>lru_remove_node：移除任意一个节点</strong></li>\n<li>  <strong>lru_push_first：向双向链表首部添加节点</strong></li>\n<li>  <strong>lru_pop_last：移除双向链表最后一个节点</strong></li>\n</ol>\n<h3 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LRU *<span class=\"title\">lru_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    LRU *tmp = (LRU *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(LRU));</span><br><span class=\"line\">    tmp-&gt;cache = map&lt;<span class=\"keyword\">int</span>, Node *&gt;();</span><br><span class=\"line\">    tmp-&gt;cap = size;</span><br><span class=\"line\">    tmp-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;head = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">    tmp-&gt;tail = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">    tmp-&gt;head-&gt;next = tmp-&gt;tail;</span><br><span class=\"line\">    tmp-&gt;tail-&gt;prev = tmp-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_destroy</span><span class=\"params\">(LRU *lru)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lru) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Node *tmp = lru-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp) &#123;</span><br><span class=\"line\">        Node *t = tmp;</span><br><span class=\"line\">        tmp = tmp-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_put</span><span class=\"params\">(LRU *lru, <span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lru) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lru-&gt;len &gt;= lru-&gt;cap) <span class=\"built_in\">lru_pop_last</span>(lru);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lru-&gt;cache.<span class=\"built_in\">find</span>(key) != lru-&gt;cache.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">        Node *tmp = lru-&gt;cache[key];</span><br><span class=\"line\">        tmp = <span class=\"built_in\">lru_remove_node</span>(lru, tmp);</span><br><span class=\"line\">        tmp-&gt;v = val;</span><br><span class=\"line\">        <span class=\"built_in\">lru_push_first</span>(lru, tmp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node *tmp = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">        tmp-&gt;k = key;</span><br><span class=\"line\">        tmp-&gt;v = val;</span><br><span class=\"line\">        <span class=\"built_in\">lru_push_first</span>(lru, tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lru_get</span><span class=\"params\">(LRU *lru, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lru) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lru-&gt;cache.<span class=\"built_in\">find</span>(key) != lru-&gt;cache.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">        Node *tmp = <span class=\"built_in\">lru_remove_node</span>(lru, lru-&gt;cache[key]);</span><br><span class=\"line\">        <span class=\"built_in\">lru_push_first</span>(lru, tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp-&gt;v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从双向链表中移除一个节点</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lru_remove_node</span><span class=\"params\">(LRU *lru, Node *node)</span> </span>&#123;</span><br><span class=\"line\">    Node *tmp = node-&gt;next;</span><br><span class=\"line\">    node-&gt;prev-&gt;next = tmp;</span><br><span class=\"line\">    tmp-&gt;prev = node-&gt;prev;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    lru-&gt;len--;</span><br><span class=\"line\">    lru-&gt;cache.<span class=\"built_in\">erase</span>(node-&gt;k);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将节点插入到双向链表头部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_push_first</span><span class=\"params\">(LRU *lru, Node *node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lru || !node) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lru-&gt;len &gt;= lru-&gt;cap) <span class=\"built_in\">lru_pop_last</span>(lru);</span><br><span class=\"line\">    Node *tmp = lru-&gt;head-&gt;next;</span><br><span class=\"line\">    node-&gt;next = tmp;</span><br><span class=\"line\">    tmp-&gt;prev = node;</span><br><span class=\"line\">    lru-&gt;head-&gt;next = node;</span><br><span class=\"line\">    node-&gt;prev = lru-&gt;head;</span><br><span class=\"line\">    lru-&gt;len++;</span><br><span class=\"line\">    lru-&gt;cache[node-&gt;k] = node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 移除双向链表的尾部节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_pop_last</span><span class=\"params\">(LRU *lru)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lru-&gt;len &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    Node *tmp = lru-&gt;tail-&gt;prev;</span><br><span class=\"line\">    Node *t = tmp-&gt;prev;</span><br><span class=\"line\">    t-&gt;next = lru-&gt;tail;</span><br><span class=\"line\">    lru-&gt;tail-&gt;prev = t;</span><br><span class=\"line\">    lru-&gt;cache.<span class=\"built_in\">erase</span>(tmp-&gt;k);</span><br><span class=\"line\">    lru-&gt;len--;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(tmp);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 即时打印缓存内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lru_print</span><span class=\"params\">(LRU *lru)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;----------\\n&quot;</span>;</span><br><span class=\"line\">    Node *tmp = lru-&gt;head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp != lru-&gt;tail) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; tmp-&gt;k &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; tmp-&gt;v &lt;&lt; <span class=\"string\">&quot;) &quot;</span>;</span><br><span class=\"line\">        tmp = tmp-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"验证LRU效果\"><a href=\"#验证LRU效果\" class=\"headerlink\" title=\"验证LRU效果\"></a>验证LRU效果</h3><p>补充main函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LRU *lru = <span class=\"built_in\">lru_create</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lru_put</span>(lru, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lru_put</span>(lru, <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lru_get</span>(lru, <span class=\"number\">3</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lru_put</span>(lru, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lru_get</span>(lru, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lru_get</span>(lru, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lru_put</span>(lru, <span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lru_get</span>(lru, <span class=\"number\">1</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lru_print</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lru_destroy</span>(lru);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>验证一下效果，从左到右是双向链表首至尾的内容：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913224007315.png\" alt=\"LRU执行结果\" style=\"zoom: 67%;\" />\n\n\n\n<h2 id=\"实现LFU\"><a href=\"#实现LFU\" class=\"headerlink\" title=\"实现LFU\"></a>实现LFU</h2><p>对于LFU，虽然比较好理解，但是实现起来笔者还是需要仔细思考一会的，如果是面试场景下问到LRU之后，很容易连坐扯出LFU，所以这里也思考了一下LFU的实现方式，并且给出的具体实现。</p>\n<p><img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913224436981.png\" alt=\"LFU缓存（哈希表+双向链表）\"></p>\n<p>这里笔者继续采用一种基于双向链表的实现方式，不同的是每个双向链表节点Node里面需要多出cnt属性来记录访问该Node节点的次数。除此之外，双向链表的头部是急需淘汰的元素，反而尾部是使用次数cnt最多，不需要淘汰的元素</p>\n<p>对于哈希表，这里依然采用STL中的map来实现。</p>\n<h3 id=\"定义结构体-1\"><a href=\"#定义结构体-1\" class=\"headerlink\" title=\"定义结构体\"></a>定义结构体</h3><p>和LRU的结构体几乎相同，除了节点多出了cnt属性</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * LFU缓存，&quot;最不经常使用&quot;缓存淘汰策略</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> v;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt;\t<span class=\"comment\">// 访问次数</span></span><br><span class=\"line\">    Node *prev;</span><br><span class=\"line\">    Node *next;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LFU</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cap;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    Node *head;</span><br><span class=\"line\">    Node *tail;</span><br><span class=\"line\">    map&lt;<span class=\"keyword\">int</span>, Node *&gt; cache;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">LFU *<span class=\"title\">lfu_create</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_put</span><span class=\"params\">(LFU *, <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lfu_get</span><span class=\"params\">(LFU *, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_destroy</span><span class=\"params\">(LFU *)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_print</span><span class=\"params\">(LFU *)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lfu_insert_node</span><span class=\"params\">(LFU *, Node *)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lfu_remove_node</span><span class=\"params\">(LFU *, Node *)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>对于LFU，笔者这里核心实现了下面两个方法：</strong></p>\n<ol>\n<li>  <strong>lru_remove_node：移除任意一个节点</strong></li>\n<li>  <strong>lfu_insert_node：将一个节点插入到双向链表中的合适位置（大于node节点cnt数的第一个节点的左边）</strong></li>\n</ol>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913225834248.png\" alt=\"LFU双向链表-插入一个节点\" style=\"zoom:50%;\" />\n\n\n\n<h3 id=\"具体实现-1\"><a href=\"#具体实现-1\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LFU *<span class=\"title\">lfu_create</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    LFU *tmp = (LFU *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(LFU));</span><br><span class=\"line\">    tmp-&gt;head = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">    tmp-&gt;tail = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">    tmp-&gt;head-&gt;cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;tail-&gt;cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;cap = size;</span><br><span class=\"line\">    tmp-&gt;len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tmp-&gt;head-&gt;next = tmp-&gt;tail;</span><br><span class=\"line\">    tmp-&gt;tail-&gt;prev = tmp-&gt;head;</span><br><span class=\"line\">    tmp-&gt;cache = map&lt;<span class=\"keyword\">int</span>, Node *&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_destroy</span><span class=\"params\">(LFU *lfu)</span> </span>&#123;</span><br><span class=\"line\">    lfu-&gt;cache.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    Node *tmp = lfu-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp) &#123;</span><br><span class=\"line\">        Node *t = tmp;</span><br><span class=\"line\">        tmp = tmp-&gt;next;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将一个节点插入到双向链表中的合适位置(大于node节点cnt数的第一个节点的左边)</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lfu_insert_node</span><span class=\"params\">(LFU *lfu, Node *node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lfu-&gt;cap &lt;= lfu-&gt;len) &#123;</span><br><span class=\"line\">        Node *t = <span class=\"built_in\">lfu_remove_node</span>(lfu, lfu-&gt;head-&gt;next);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node *tmp = lfu-&gt;head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp != lfu-&gt;tail &amp;&amp; tmp-&gt;cnt &lt;= node-&gt;cnt) tmp = tmp-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">    tmp-&gt;prev-&gt;next = node;</span><br><span class=\"line\">    node-&gt;prev = tmp-&gt;prev;</span><br><span class=\"line\">    node-&gt;next = tmp;</span><br><span class=\"line\">    tmp-&gt;prev = node;</span><br><span class=\"line\"></span><br><span class=\"line\">    lfu-&gt;cache[node-&gt;k] = node;</span><br><span class=\"line\">    lfu-&gt;len++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将一个节点从原有双向链表上移除，返回这个移除的节点</span></span><br><span class=\"line\"><span class=\"function\">Node *<span class=\"title\">lfu_remove_node</span><span class=\"params\">(LFU *lfu, Node *node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lfu-&gt;len &lt;= <span class=\"number\">0</span> || !node) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class=\"line\">    node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class=\"line\">    node-&gt;prev = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    node-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    lfu-&gt;len--;</span><br><span class=\"line\">    lfu-&gt;cache.<span class=\"built_in\">erase</span>(node-&gt;k);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_put</span><span class=\"params\">(LFU *lfu, <span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lfu) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    map&lt;<span class=\"keyword\">int</span>, Node *&gt; mp = lfu-&gt;cache;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mp.<span class=\"built_in\">find</span>(key) != mp.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">        Node *tmp = mp[key];</span><br><span class=\"line\">        tmp = <span class=\"built_in\">lfu_remove_node</span>(lfu, tmp);</span><br><span class=\"line\">        tmp-&gt;cnt++;</span><br><span class=\"line\">        tmp-&gt;v = val;</span><br><span class=\"line\">        <span class=\"built_in\">lfu_insert_node</span>(lfu, tmp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node *tmp = (Node *)<span class=\"built_in\">malloc</span>(<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(Node));</span><br><span class=\"line\">        tmp-&gt;cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">        tmp-&gt;k = key;</span><br><span class=\"line\">        tmp-&gt;v = val;</span><br><span class=\"line\">        <span class=\"built_in\">lfu_insert_node</span>(lfu, tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lfu_get</span><span class=\"params\">(LFU *lfu, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lfu) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lfu-&gt;cache.<span class=\"built_in\">find</span>(key) != lfu-&gt;cache.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">        Node *tmp = lfu-&gt;cache[key];</span><br><span class=\"line\">        tmp = <span class=\"built_in\">lfu_remove_node</span>(lfu, tmp);</span><br><span class=\"line\">        tmp-&gt;cnt++;</span><br><span class=\"line\">        tmp = <span class=\"built_in\">lfu_insert_node</span>(lfu, tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp-&gt;v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lfu_print</span><span class=\"params\">(LFU *lfu)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;----------\\n&quot;</span>;</span><br><span class=\"line\">    Node *tmp = lfu-&gt;head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tmp != lfu-&gt;tail) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; tmp-&gt;k &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; tmp-&gt;v &lt;&lt; <span class=\"string\">&quot;) -&gt; cnt: &quot;</span> &lt;&lt; tmp-&gt;cnt &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">        tmp = tmp-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"验证LFU效果\"><a href=\"#验证LFU效果\" class=\"headerlink\" title=\"验证LFU效果\"></a>验证LFU效果</h3><p>定义一个main函数同时调用LFU即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LFU *lfu = <span class=\"built_in\">lfu_create</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lfu_put</span>(lfu, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lfu_put</span>(lfu, <span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lfu_get</span>(lfu, <span class=\"number\">3</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lfu_put</span>(lfu, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lfu_get</span>(lfu, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lfu_get</span>(lfu, <span class=\"number\">2</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lfu_put</span>(lfu, <span class=\"number\">4</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">lfu_get</span>(lfu, <span class=\"number\">1</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">lfu_print</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">lfu_destroy</span>(lfu);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到双向链表内部是根据cnt从小到大排列缓存k-v的：</p>\n<img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210913225229277.png\" alt=\"LFU效果\" style=\"zoom: 67%;\" />\n\n\n\n<h2 id=\"LFU的其他实现方式\"><a href=\"#LFU的其他实现方式\" class=\"headerlink\" title=\"LFU的其他实现方式\"></a>LFU的其他实现方式</h2><p>上面实现LFU使用的是map+双向链表的方法，每次淘汰双向链表头部的元素。</p>\n<p>除此之外，还可以使用优先队列priority_queue来代替双向链表，因为优先队列内部维护了一个二叉队，如果按照cnt元素从小到大维护一个优先队列，每次pop队首元素也是可以的。</p>\n"},{"title":"线程池的shutdown和shutdownNow方法","date":"2021-09-08T12:29:54.000Z","_content":"\n使用Java的线程池ThreadPoolExecutor类时候发现了两个不同的关闭线程池的方法：shutdown和shutdownNow方法，具体这两个方法有啥区别呢？这次一起来探讨一下：\n\n## 线程池的状态runState\n\n阅读ThreadPoolExecutor类的源码不难看出，线程池实现类中定义了线程池具有几个状态：\n\n```java\n/** The runState provides the main lifecycle control, taking on values:\n*   RUNNING:  Accept new tasks and process queued tasks\n*   SHUTDOWN: Don't accept new tasks, but process queued tasks\n*   STOP:     Don't accept new tasks, don't process queued tasks,\n*             and interrupt in-progress tasks\n*   TIDYING:  All tasks have terminated, workerCount is zero,\n*             the thread transitioning to state TIDYING\n*             will run the terminated() hook method\n*   TERMINATED: terminated() has completed\n*/\n\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n```\n\n同时，类源码中也解释了上面五个状态之间是如何切换的，这里笔者整理成一个状态转换图好了：\n\n![线程池状态转换图](https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210908203537430.png)\n\n从上面的图中可以看到，这次要讨论的shutdown和shutdownNow方法是和SHUTDOWN、STOP状态相关联的\n\n\n\n## shutdown()方法\n\n线程池内部主要存在两个部分：保存工作线程的HashSet集合Workers，保存待执行任务的BlockingQueue集合taskQueue，线程池释放的时候，主要需要处理并且释放的资源内容也就是这两块。\n\n对于shutdown方法，这个方法返回值为void。\n\n-   执行了shutdown方法之后，线程池的状态切换为SHUTDOWN状态\n-   对于taskQueue，线程池不再接受新的任务提交请求，但是会等待队列中已存在的任务全部执行完成\n\n\n\n## shutdownNow()方法\n\n对于shutdownNow方法，这个方法返回List\\<Runnable>，尚未开始执行的任务列表\n\n-   执行了shutdownNow方法之后，线程池的状态切换为STOP状态\n-   对于taskQueue，线程池不再接受新的任务提交请求，并且尝试interrupt中断开始执行的任务（不一定中断成功），队列中尚未执行的任务全部以列表形式返回\n\n\n\n## 何时进入TERMINATED状态\n\n从线程池的状态转换图中可以看到，从调用了shutdown或者shutdownNow方法到最终线程池结束工作的TERMINATED状态仍然有一段距离，因为可能执行的任务还需要执行完成。\n\n一般来说，因为调用shutdown或shutdownNow方法是立即返回的，并不会阻塞等待所有任务完成，所以线程池提供了额外的awaitTermination函数来实现阻塞等待所有工作完成，并且到达了TERMINATED状态。\n\n```java\npublic boolean awaitTermination(long timeout, TimeUnit unit);\n```\n\n方法内部借助一个condition变量实现了阻塞等待，并且在所有任务结束时唤醒返回true\n\n","source":"_posts/线程池的shutdown和shutdownNow方法.md","raw":"---\ntitle: 线程池的shutdown和shutdownNow方法\ndate: 2021-09-08 20:29:54\ncategories:\n- Java\ntags:\n- 面试\n- Java并发编程\n- 线程池\n---\n\n使用Java的线程池ThreadPoolExecutor类时候发现了两个不同的关闭线程池的方法：shutdown和shutdownNow方法，具体这两个方法有啥区别呢？这次一起来探讨一下：\n\n## 线程池的状态runState\n\n阅读ThreadPoolExecutor类的源码不难看出，线程池实现类中定义了线程池具有几个状态：\n\n```java\n/** The runState provides the main lifecycle control, taking on values:\n*   RUNNING:  Accept new tasks and process queued tasks\n*   SHUTDOWN: Don't accept new tasks, but process queued tasks\n*   STOP:     Don't accept new tasks, don't process queued tasks,\n*             and interrupt in-progress tasks\n*   TIDYING:  All tasks have terminated, workerCount is zero,\n*             the thread transitioning to state TIDYING\n*             will run the terminated() hook method\n*   TERMINATED: terminated() has completed\n*/\n\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n```\n\n同时，类源码中也解释了上面五个状态之间是如何切换的，这里笔者整理成一个状态转换图好了：\n\n![线程池状态转换图](https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210908203537430.png)\n\n从上面的图中可以看到，这次要讨论的shutdown和shutdownNow方法是和SHUTDOWN、STOP状态相关联的\n\n\n\n## shutdown()方法\n\n线程池内部主要存在两个部分：保存工作线程的HashSet集合Workers，保存待执行任务的BlockingQueue集合taskQueue，线程池释放的时候，主要需要处理并且释放的资源内容也就是这两块。\n\n对于shutdown方法，这个方法返回值为void。\n\n-   执行了shutdown方法之后，线程池的状态切换为SHUTDOWN状态\n-   对于taskQueue，线程池不再接受新的任务提交请求，但是会等待队列中已存在的任务全部执行完成\n\n\n\n## shutdownNow()方法\n\n对于shutdownNow方法，这个方法返回List\\<Runnable>，尚未开始执行的任务列表\n\n-   执行了shutdownNow方法之后，线程池的状态切换为STOP状态\n-   对于taskQueue，线程池不再接受新的任务提交请求，并且尝试interrupt中断开始执行的任务（不一定中断成功），队列中尚未执行的任务全部以列表形式返回\n\n\n\n## 何时进入TERMINATED状态\n\n从线程池的状态转换图中可以看到，从调用了shutdown或者shutdownNow方法到最终线程池结束工作的TERMINATED状态仍然有一段距离，因为可能执行的任务还需要执行完成。\n\n一般来说，因为调用shutdown或shutdownNow方法是立即返回的，并不会阻塞等待所有任务完成，所以线程池提供了额外的awaitTermination函数来实现阻塞等待所有工作完成，并且到达了TERMINATED状态。\n\n```java\npublic boolean awaitTermination(long timeout, TimeUnit unit);\n```\n\n方法内部借助一个condition变量实现了阻塞等待，并且在所有任务结束时唤醒返回true\n\n","slug":"线程池的shutdown和shutdownNow方法","published":1,"updated":"2021-09-08T12:48:46.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktiszmie0008azqp33ej7aot","content":"<p>使用Java的线程池ThreadPoolExecutor类时候发现了两个不同的关闭线程池的方法：shutdown和shutdownNow方法，具体这两个方法有啥区别呢？这次一起来探讨一下：</p>\n<h2 id=\"线程池的状态runState\"><a href=\"#线程池的状态runState\" class=\"headerlink\" title=\"线程池的状态runState\"></a>线程池的状态runState</h2><p>阅读ThreadPoolExecutor类的源码不难看出，线程池实现类中定义了线程池具有几个状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** The runState provides the main lifecycle control, taking on values:</span></span><br><span class=\"line\"><span class=\"comment\">*   RUNNING:  Accept new tasks and process queued tasks</span></span><br><span class=\"line\"><span class=\"comment\">*   SHUTDOWN: Don&#x27;t accept new tasks, but process queued tasks</span></span><br><span class=\"line\"><span class=\"comment\">*   STOP:     Don&#x27;t accept new tasks, don&#x27;t process queued tasks,</span></span><br><span class=\"line\"><span class=\"comment\">*             and interrupt in-progress tasks</span></span><br><span class=\"line\"><span class=\"comment\">*   TIDYING:  All tasks have terminated, workerCount is zero,</span></span><br><span class=\"line\"><span class=\"comment\">*             the thread transitioning to state TIDYING</span></span><br><span class=\"line\"><span class=\"comment\">*             will run the terminated() hook method</span></span><br><span class=\"line\"><span class=\"comment\">*   TERMINATED: terminated() has completed</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>\n\n<p>同时，类源码中也解释了上面五个状态之间是如何切换的，这里笔者整理成一个状态转换图好了：</p>\n<p><img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210908203537430.png\" alt=\"线程池状态转换图\"></p>\n<p>从上面的图中可以看到，这次要讨论的shutdown和shutdownNow方法是和SHUTDOWN、STOP状态相关联的</p>\n<h2 id=\"shutdown-方法\"><a href=\"#shutdown-方法\" class=\"headerlink\" title=\"shutdown()方法\"></a>shutdown()方法</h2><p>线程池内部主要存在两个部分：保存工作线程的HashSet集合Workers，保存待执行任务的BlockingQueue集合taskQueue，线程池释放的时候，主要需要处理并且释放的资源内容也就是这两块。</p>\n<p>对于shutdown方法，这个方法返回值为void。</p>\n<ul>\n<li>  执行了shutdown方法之后，线程池的状态切换为SHUTDOWN状态</li>\n<li>  对于taskQueue，线程池不再接受新的任务提交请求，但是会等待队列中已存在的任务全部执行完成</li>\n</ul>\n<h2 id=\"shutdownNow-方法\"><a href=\"#shutdownNow-方法\" class=\"headerlink\" title=\"shutdownNow()方法\"></a>shutdownNow()方法</h2><p>对于shutdownNow方法，这个方法返回List&lt;Runnable&gt;，尚未开始执行的任务列表</p>\n<ul>\n<li>  执行了shutdownNow方法之后，线程池的状态切换为STOP状态</li>\n<li>  对于taskQueue，线程池不再接受新的任务提交请求，并且尝试interrupt中断开始执行的任务（不一定中断成功），队列中尚未执行的任务全部以列表形式返回</li>\n</ul>\n<h2 id=\"何时进入TERMINATED状态\"><a href=\"#何时进入TERMINATED状态\" class=\"headerlink\" title=\"何时进入TERMINATED状态\"></a>何时进入TERMINATED状态</h2><p>从线程池的状态转换图中可以看到，从调用了shutdown或者shutdownNow方法到最终线程池结束工作的TERMINATED状态仍然有一段距离，因为可能执行的任务还需要执行完成。</p>\n<p>一般来说，因为调用shutdown或shutdownNow方法是立即返回的，并不会阻塞等待所有任务完成，所以线程池提供了额外的awaitTermination函数来实现阻塞等待所有工作完成，并且到达了TERMINATED状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>方法内部借助一个condition变量实现了阻塞等待，并且在所有任务结束时唤醒返回true</p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用Java的线程池ThreadPoolExecutor类时候发现了两个不同的关闭线程池的方法：shutdown和shutdownNow方法，具体这两个方法有啥区别呢？这次一起来探讨一下：</p>\n<h2 id=\"线程池的状态runState\"><a href=\"#线程池的状态runState\" class=\"headerlink\" title=\"线程池的状态runState\"></a>线程池的状态runState</h2><p>阅读ThreadPoolExecutor类的源码不难看出，线程池实现类中定义了线程池具有几个状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** The runState provides the main lifecycle control, taking on values:</span></span><br><span class=\"line\"><span class=\"comment\">*   RUNNING:  Accept new tasks and process queued tasks</span></span><br><span class=\"line\"><span class=\"comment\">*   SHUTDOWN: Don&#x27;t accept new tasks, but process queued tasks</span></span><br><span class=\"line\"><span class=\"comment\">*   STOP:     Don&#x27;t accept new tasks, don&#x27;t process queued tasks,</span></span><br><span class=\"line\"><span class=\"comment\">*             and interrupt in-progress tasks</span></span><br><span class=\"line\"><span class=\"comment\">*   TIDYING:  All tasks have terminated, workerCount is zero,</span></span><br><span class=\"line\"><span class=\"comment\">*             the thread transitioning to state TIDYING</span></span><br><span class=\"line\"><span class=\"comment\">*             will run the terminated() hook method</span></span><br><span class=\"line\"><span class=\"comment\">*   TERMINATED: terminated() has completed</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>\n\n<p>同时，类源码中也解释了上面五个状态之间是如何切换的，这里笔者整理成一个状态转换图好了：</p>\n<p><img src=\"https://gitee.com/dzzhyk/MarkdownPics/raw/master/image-20210908203537430.png\" alt=\"线程池状态转换图\"></p>\n<p>从上面的图中可以看到，这次要讨论的shutdown和shutdownNow方法是和SHUTDOWN、STOP状态相关联的</p>\n<h2 id=\"shutdown-方法\"><a href=\"#shutdown-方法\" class=\"headerlink\" title=\"shutdown()方法\"></a>shutdown()方法</h2><p>线程池内部主要存在两个部分：保存工作线程的HashSet集合Workers，保存待执行任务的BlockingQueue集合taskQueue，线程池释放的时候，主要需要处理并且释放的资源内容也就是这两块。</p>\n<p>对于shutdown方法，这个方法返回值为void。</p>\n<ul>\n<li>  执行了shutdown方法之后，线程池的状态切换为SHUTDOWN状态</li>\n<li>  对于taskQueue，线程池不再接受新的任务提交请求，但是会等待队列中已存在的任务全部执行完成</li>\n</ul>\n<h2 id=\"shutdownNow-方法\"><a href=\"#shutdownNow-方法\" class=\"headerlink\" title=\"shutdownNow()方法\"></a>shutdownNow()方法</h2><p>对于shutdownNow方法，这个方法返回List&lt;Runnable&gt;，尚未开始执行的任务列表</p>\n<ul>\n<li>  执行了shutdownNow方法之后，线程池的状态切换为STOP状态</li>\n<li>  对于taskQueue，线程池不再接受新的任务提交请求，并且尝试interrupt中断开始执行的任务（不一定中断成功），队列中尚未执行的任务全部以列表形式返回</li>\n</ul>\n<h2 id=\"何时进入TERMINATED状态\"><a href=\"#何时进入TERMINATED状态\" class=\"headerlink\" title=\"何时进入TERMINATED状态\"></a>何时进入TERMINATED状态</h2><p>从线程池的状态转换图中可以看到，从调用了shutdown或者shutdownNow方法到最终线程池结束工作的TERMINATED状态仍然有一段距离，因为可能执行的任务还需要执行完成。</p>\n<p>一般来说，因为调用shutdown或shutdownNow方法是立即返回的，并不会阻塞等待所有任务完成，所以线程池提供了额外的awaitTermination函数来实现阻塞等待所有工作完成，并且到达了TERMINATED状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>方法内部借助一个condition变量实现了阻塞等待，并且在所有任务结束时唤醒返回true</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cktiszmid0007azqp6cjc27os","category_id":"cktiszmib0004azqphxek4xhe","_id":"cktiszmif000bazqp87behs72"},{"post_id":"cktiszmi60001azqph1o6ci47","category_id":"cktiszmib0004azqphxek4xhe","_id":"cktiszmig000eazqpd63q317e"},{"post_id":"cktiszmi90003azqpgnsjdyh4","category_id":"cktiszmie0009azqp0z242w4x","_id":"cktiszmih000gazqp23kkb8wb"},{"post_id":"cktiszmic0006azqpcyzagld4","category_id":"cktiszmie0009azqp0z242w4x","_id":"cktiszmii000jazqpfymdgyi7"},{"post_id":"cktiszmie0008azqp33ej7aot","category_id":"cktiszmih000fazqp782mbhmj","_id":"cktiszmii000nazqpfaisbas2"}],"PostTag":[{"post_id":"cktiszmi60001azqph1o6ci47","tag_id":"cktiszmic0005azqpffdnamtz","_id":"cktiszmih000iazqpbramgexx"},{"post_id":"cktiszmi60001azqph1o6ci47","tag_id":"cktiszmie000aazqpadka8jy3","_id":"cktiszmii000kazqp7ybvga4a"},{"post_id":"cktiszmi60001azqph1o6ci47","tag_id":"cktiszmif000dazqpd1ka80uk","_id":"cktiszmii000mazqp8wq9eypz"},{"post_id":"cktiszmi90003azqpgnsjdyh4","tag_id":"cktiszmih000hazqp2lmagmr1","_id":"cktiszmij000qazqpduwg94st"},{"post_id":"cktiszmi90003azqpgnsjdyh4","tag_id":"cktiszmii000lazqpauoqaf36","_id":"cktiszmij000razqp5oyvewsc"},{"post_id":"cktiszmi90003azqpgnsjdyh4","tag_id":"cktiszmii000oazqp6v9i5p1p","_id":"cktiszmij000tazqp1yjm7fdv"},{"post_id":"cktiszmic0006azqpcyzagld4","tag_id":"cktiszmii000lazqpauoqaf36","_id":"cktiszmik000xazqph49w5t5q"},{"post_id":"cktiszmic0006azqpcyzagld4","tag_id":"cktiszmij000sazqpcepo0eis","_id":"cktiszmik000yazqp7woh03gg"},{"post_id":"cktiszmic0006azqpcyzagld4","tag_id":"cktiszmih000hazqp2lmagmr1","_id":"cktiszmil0010azqp8v7g2jk7"},{"post_id":"cktiszmic0006azqpcyzagld4","tag_id":"cktiszmik000vazqp5klx78cp","_id":"cktiszmil0011azqp5irldie4"},{"post_id":"cktiszmid0007azqp6cjc27os","tag_id":"cktiszmik000wazqpf5c8hh9z","_id":"cktiszmil0015azqp2nb09f3k"},{"post_id":"cktiszmid0007azqp6cjc27os","tag_id":"cktiszmik000zazqpgp6s090d","_id":"cktiszmim0016azqp513046mm"},{"post_id":"cktiszmid0007azqp6cjc27os","tag_id":"cktiszmil0012azqpelyb06yc","_id":"cktiszmim0018azqpdmtm9gha"},{"post_id":"cktiszmid0007azqp6cjc27os","tag_id":"cktiszmil0013azqpflz4fpub","_id":"cktiszmim0019azqp3vcq9wz8"},{"post_id":"cktiszmie0008azqp33ej7aot","tag_id":"cktiszmic0005azqpffdnamtz","_id":"cktiszmim001aazqpcs6n5sx1"},{"post_id":"cktiszmie0008azqp33ej7aot","tag_id":"cktiszmil0014azqp8kgihpge","_id":"cktiszmim001bazqp0ss9df7r"},{"post_id":"cktiszmie0008azqp33ej7aot","tag_id":"cktiszmij000sazqpcepo0eis","_id":"cktiszmim001cazqpe8nhgstp"}],"Tag":[{"name":"面试","_id":"cktiszmic0005azqpffdnamtz"},{"name":"计算机网络","_id":"cktiszmie000aazqpadka8jy3"},{"name":"DNS协议","_id":"cktiszmif000dazqpd1ka80uk"},{"name":"Linux","_id":"cktiszmih000hazqp2lmagmr1"},{"name":"网络编程","_id":"cktiszmii000lazqpauoqaf36"},{"name":"socket","_id":"cktiszmii000oazqp6v9i5p1p"},{"name":"线程池","_id":"cktiszmij000sazqpcepo0eis"},{"name":"pthread","_id":"cktiszmik000vazqp5klx78cp"},{"name":"数据结构","_id":"cktiszmik000wazqpf5c8hh9z"},{"name":"双向链表","_id":"cktiszmik000zazqpgp6s090d"},{"name":"LRU缓存策略","_id":"cktiszmil0012azqpelyb06yc"},{"name":"LFU缓存策略","_id":"cktiszmil0013azqpflz4fpub"},{"name":"Java并发编程","_id":"cktiszmil0014azqp8kgihpge"}]}}